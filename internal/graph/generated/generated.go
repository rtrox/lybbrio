// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"lybbrio"
	"lybbrio/internal/ent"
	"lybbrio/internal/ent/bookfile"
	"lybbrio/internal/ent/schema/ksuid"
	"lybbrio/internal/ent/schema/task_enums"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Author struct {
		Books     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		CalibreID func(childComplexity int) int
		ID        func(childComplexity int) int
		Link      func(childComplexity int) int
		Name      func(childComplexity int) int
		Sort      func(childComplexity int) int
	}

	AuthorConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AuthorEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Book struct {
		Authors       func(childComplexity int) int
		CalibreID     func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		Identifiers   func(childComplexity int) int
		Isbn          func(childComplexity int) int
		Language      func(childComplexity int) int
		Path          func(childComplexity int) int
		PublishedDate func(childComplexity int) int
		Publisher     func(childComplexity int) int
		Series        func(childComplexity int) int
		SeriesIndex   func(childComplexity int) int
		Shelf         func(childComplexity int) int
		Sort          func(childComplexity int) int
		Tags          func(childComplexity int) int
		Title         func(childComplexity int) int
	}

	BookConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BookEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	BookFile struct {
		Book   func(childComplexity int) int
		Format func(childComplexity int) int
		ID     func(childComplexity int) int
		Path   func(childComplexity int) int
		Size   func(childComplexity int) int
	}

	Identifier struct {
		Book      func(childComplexity int) int
		CalibreID func(childComplexity int) int
		ID        func(childComplexity int) int
		Type      func(childComplexity int) int
		Value     func(childComplexity int) int
	}

	IdentifierConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	IdentifierEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Language struct {
		Books     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		CalibreID func(childComplexity int) int
		Code      func(childComplexity int) int
		ID        func(childComplexity int) int
	}

	LanguageConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	LanguageEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Mutation struct {
		CreateAuthor     func(childComplexity int, input ent.CreateAuthorInput) int
		CreateBook       func(childComplexity int, input ent.CreateBookInput) int
		CreateIdentifier func(childComplexity int, input ent.CreateIdentifierInput) int
		CreateLanguage   func(childComplexity int, input ent.CreateLanguageInput) int
		CreatePublisher  func(childComplexity int, input ent.CreatePublisherInput) int
		CreateSeries     func(childComplexity int, input ent.CreateSeriesInput) int
		CreateShelf      func(childComplexity int, input lybbrio.CreateShelfInput) int
		CreateTag        func(childComplexity int, input ent.CreateTagInput) int
		CreateTask       func(childComplexity int, input lybbrio.CreateTaskInput) int
		CreateUser       func(childComplexity int, input ent.CreateUserInput) int
		UpdateAuthor     func(childComplexity int, id ksuid.ID, input ent.UpdateAuthorInput) int
		UpdateBook       func(childComplexity int, id ksuid.ID, input ent.UpdateBookInput) int
		UpdateIdentifier func(childComplexity int, id ksuid.ID, input ent.UpdateIdentifierInput) int
		UpdateLanguage   func(childComplexity int, id ksuid.ID, input ent.UpdateLanguageInput) int
		UpdatePublisher  func(childComplexity int, id ksuid.ID, input ent.UpdatePublisherInput) int
		UpdateSeries     func(childComplexity int, id ksuid.ID, input ent.UpdateSeriesInput) int
		UpdateShelf      func(childComplexity int, id ksuid.ID, input ent.UpdateShelfInput) int
		UpdateTag        func(childComplexity int, id ksuid.ID, input ent.UpdateTagInput) int
		UpdateUser       func(childComplexity int, id ksuid.ID, input ent.UpdateUserInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Publisher struct {
		Books     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		CalibreID func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	PublisherConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	PublisherEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Authors     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.AuthorOrder, where *ent.AuthorWhereInput) int
		BookFiles   func(childComplexity int) int
		Books       func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		Identifiers func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.IdentifierOrder, where *ent.IdentifierWhereInput) int
		Languages   func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.LanguageOrder, where *ent.LanguageWhereInput) int
		Me          func(childComplexity int) int
		Node        func(childComplexity int, id ksuid.ID) int
		Nodes       func(childComplexity int, ids []ksuid.ID) int
		Publishers  func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.PublisherOrder, where *ent.PublisherWhereInput) int
		SeriesSlice func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.SeriesOrder, where *ent.SeriesWhereInput) int
		Shelves     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.ShelfOrder, where *ent.ShelfWhereInput) int
		Tags        func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) int
		Tasks       func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) int
		Users       func(childComplexity int) int
	}

	Series struct {
		Books     func(childComplexity int) int
		CalibreID func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Sort      func(childComplexity int) int
	}

	SeriesConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SeriesEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Shelf struct {
		Books       func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Public      func(childComplexity int) int
		User        func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	ShelfConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ShelfEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Tag struct {
		Books     func(childComplexity int, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) int
		CalibreID func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
	}

	TagConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TagEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Task struct {
		CreateTime   func(childComplexity int) int
		Error        func(childComplexity int) int
		ID           func(childComplexity int) int
		IsSystemTask func(childComplexity int) int
		Message      func(childComplexity int) int
		Progress     func(childComplexity int) int
		Status       func(childComplexity int) int
		Type         func(childComplexity int) int
		UpdateTime   func(childComplexity int) int
		User         func(childComplexity int) int
		UserID       func(childComplexity int) int
	}

	TaskConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TaskEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		Email           func(childComplexity int) int
		ID              func(childComplexity int) int
		Shelves         func(childComplexity int) int
		UserPermissions func(childComplexity int) int
		Username        func(childComplexity int) int
	}

	UserPermissions struct {
		Admin           func(childComplexity int) int
		CanCreatePublic func(childComplexity int) int
		CanEdit         func(childComplexity int) int
		ID              func(childComplexity int) int
		User            func(childComplexity int) int
		UserID          func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateBook(ctx context.Context, input ent.CreateBookInput) (*ent.Book, error)
	UpdateBook(ctx context.Context, id ksuid.ID, input ent.UpdateBookInput) (*ent.Book, error)
	CreateAuthor(ctx context.Context, input ent.CreateAuthorInput) (*ent.Author, error)
	UpdateAuthor(ctx context.Context, id ksuid.ID, input ent.UpdateAuthorInput) (*ent.Author, error)
	CreateShelf(ctx context.Context, input lybbrio.CreateShelfInput) (*ent.Shelf, error)
	UpdateShelf(ctx context.Context, id ksuid.ID, input ent.UpdateShelfInput) (*ent.Shelf, error)
	CreateTag(ctx context.Context, input ent.CreateTagInput) (*ent.Tag, error)
	UpdateTag(ctx context.Context, id ksuid.ID, input ent.UpdateTagInput) (*ent.Tag, error)
	CreatePublisher(ctx context.Context, input ent.CreatePublisherInput) (*ent.Publisher, error)
	UpdatePublisher(ctx context.Context, id ksuid.ID, input ent.UpdatePublisherInput) (*ent.Publisher, error)
	CreateLanguage(ctx context.Context, input ent.CreateLanguageInput) (*ent.Language, error)
	UpdateLanguage(ctx context.Context, id ksuid.ID, input ent.UpdateLanguageInput) (*ent.Language, error)
	CreateSeries(ctx context.Context, input ent.CreateSeriesInput) (*ent.Series, error)
	UpdateSeries(ctx context.Context, id ksuid.ID, input ent.UpdateSeriesInput) (*ent.Series, error)
	CreateIdentifier(ctx context.Context, input ent.CreateIdentifierInput) (*ent.Identifier, error)
	UpdateIdentifier(ctx context.Context, id ksuid.ID, input ent.UpdateIdentifierInput) (*ent.Identifier, error)
	CreateUser(ctx context.Context, input ent.CreateUserInput) (*ent.User, error)
	UpdateUser(ctx context.Context, id ksuid.ID, input ent.UpdateUserInput) (*ent.User, error)
	CreateTask(ctx context.Context, input lybbrio.CreateTaskInput) (*ent.Task, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id ksuid.ID) (ent.Noder, error)
	Nodes(ctx context.Context, ids []ksuid.ID) ([]ent.Noder, error)
	Authors(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.AuthorOrder, where *ent.AuthorWhereInput) (*ent.AuthorConnection, error)
	Books(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.BookOrder, where *ent.BookWhereInput) (*ent.BookConnection, error)
	BookFiles(ctx context.Context) ([]*ent.BookFile, error)
	Identifiers(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.IdentifierOrder, where *ent.IdentifierWhereInput) (*ent.IdentifierConnection, error)
	Languages(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.LanguageOrder, where *ent.LanguageWhereInput) (*ent.LanguageConnection, error)
	Publishers(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.PublisherOrder, where *ent.PublisherWhereInput) (*ent.PublisherConnection, error)
	SeriesSlice(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.SeriesOrder, where *ent.SeriesWhereInput) (*ent.SeriesConnection, error)
	Shelves(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.ShelfOrder, where *ent.ShelfWhereInput) (*ent.ShelfConnection, error)
	Tags(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.TagOrder, where *ent.TagWhereInput) (*ent.TagConnection, error)
	Tasks(ctx context.Context, after *entgql.Cursor[ksuid.ID], first *int, before *entgql.Cursor[ksuid.ID], last *int, orderBy []*ent.TaskOrder, where *ent.TaskWhereInput) (*ent.TaskConnection, error)
	Users(ctx context.Context) ([]*ent.User, error)
	Me(ctx context.Context) (*ent.User, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Author.books":
		if e.complexity.Author.Books == nil {
			break
		}

		args, err := ec.field_Author_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Author.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Author.calibreID":
		if e.complexity.Author.CalibreID == nil {
			break
		}

		return e.complexity.Author.CalibreID(childComplexity), true

	case "Author.id":
		if e.complexity.Author.ID == nil {
			break
		}

		return e.complexity.Author.ID(childComplexity), true

	case "Author.link":
		if e.complexity.Author.Link == nil {
			break
		}

		return e.complexity.Author.Link(childComplexity), true

	case "Author.name":
		if e.complexity.Author.Name == nil {
			break
		}

		return e.complexity.Author.Name(childComplexity), true

	case "Author.sort":
		if e.complexity.Author.Sort == nil {
			break
		}

		return e.complexity.Author.Sort(childComplexity), true

	case "AuthorConnection.edges":
		if e.complexity.AuthorConnection.Edges == nil {
			break
		}

		return e.complexity.AuthorConnection.Edges(childComplexity), true

	case "AuthorConnection.pageInfo":
		if e.complexity.AuthorConnection.PageInfo == nil {
			break
		}

		return e.complexity.AuthorConnection.PageInfo(childComplexity), true

	case "AuthorConnection.totalCount":
		if e.complexity.AuthorConnection.TotalCount == nil {
			break
		}

		return e.complexity.AuthorConnection.TotalCount(childComplexity), true

	case "AuthorEdge.cursor":
		if e.complexity.AuthorEdge.Cursor == nil {
			break
		}

		return e.complexity.AuthorEdge.Cursor(childComplexity), true

	case "AuthorEdge.node":
		if e.complexity.AuthorEdge.Node == nil {
			break
		}

		return e.complexity.AuthorEdge.Node(childComplexity), true

	case "Book.authors":
		if e.complexity.Book.Authors == nil {
			break
		}

		return e.complexity.Book.Authors(childComplexity), true

	case "Book.calibreID":
		if e.complexity.Book.CalibreID == nil {
			break
		}

		return e.complexity.Book.CalibreID(childComplexity), true

	case "Book.description":
		if e.complexity.Book.Description == nil {
			break
		}

		return e.complexity.Book.Description(childComplexity), true

	case "Book.id":
		if e.complexity.Book.ID == nil {
			break
		}

		return e.complexity.Book.ID(childComplexity), true

	case "Book.identifiers":
		if e.complexity.Book.Identifiers == nil {
			break
		}

		return e.complexity.Book.Identifiers(childComplexity), true

	case "Book.isbn":
		if e.complexity.Book.Isbn == nil {
			break
		}

		return e.complexity.Book.Isbn(childComplexity), true

	case "Book.language":
		if e.complexity.Book.Language == nil {
			break
		}

		return e.complexity.Book.Language(childComplexity), true

	case "Book.path":
		if e.complexity.Book.Path == nil {
			break
		}

		return e.complexity.Book.Path(childComplexity), true

	case "Book.publishedDate":
		if e.complexity.Book.PublishedDate == nil {
			break
		}

		return e.complexity.Book.PublishedDate(childComplexity), true

	case "Book.publisher":
		if e.complexity.Book.Publisher == nil {
			break
		}

		return e.complexity.Book.Publisher(childComplexity), true

	case "Book.series":
		if e.complexity.Book.Series == nil {
			break
		}

		return e.complexity.Book.Series(childComplexity), true

	case "Book.seriesIndex":
		if e.complexity.Book.SeriesIndex == nil {
			break
		}

		return e.complexity.Book.SeriesIndex(childComplexity), true

	case "Book.shelf":
		if e.complexity.Book.Shelf == nil {
			break
		}

		return e.complexity.Book.Shelf(childComplexity), true

	case "Book.sort":
		if e.complexity.Book.Sort == nil {
			break
		}

		return e.complexity.Book.Sort(childComplexity), true

	case "Book.tags":
		if e.complexity.Book.Tags == nil {
			break
		}

		return e.complexity.Book.Tags(childComplexity), true

	case "Book.title":
		if e.complexity.Book.Title == nil {
			break
		}

		return e.complexity.Book.Title(childComplexity), true

	case "BookConnection.edges":
		if e.complexity.BookConnection.Edges == nil {
			break
		}

		return e.complexity.BookConnection.Edges(childComplexity), true

	case "BookConnection.pageInfo":
		if e.complexity.BookConnection.PageInfo == nil {
			break
		}

		return e.complexity.BookConnection.PageInfo(childComplexity), true

	case "BookConnection.totalCount":
		if e.complexity.BookConnection.TotalCount == nil {
			break
		}

		return e.complexity.BookConnection.TotalCount(childComplexity), true

	case "BookEdge.cursor":
		if e.complexity.BookEdge.Cursor == nil {
			break
		}

		return e.complexity.BookEdge.Cursor(childComplexity), true

	case "BookEdge.node":
		if e.complexity.BookEdge.Node == nil {
			break
		}

		return e.complexity.BookEdge.Node(childComplexity), true

	case "BookFile.book":
		if e.complexity.BookFile.Book == nil {
			break
		}

		return e.complexity.BookFile.Book(childComplexity), true

	case "BookFile.format":
		if e.complexity.BookFile.Format == nil {
			break
		}

		return e.complexity.BookFile.Format(childComplexity), true

	case "BookFile.id":
		if e.complexity.BookFile.ID == nil {
			break
		}

		return e.complexity.BookFile.ID(childComplexity), true

	case "BookFile.path":
		if e.complexity.BookFile.Path == nil {
			break
		}

		return e.complexity.BookFile.Path(childComplexity), true

	case "BookFile.size":
		if e.complexity.BookFile.Size == nil {
			break
		}

		return e.complexity.BookFile.Size(childComplexity), true

	case "Identifier.book":
		if e.complexity.Identifier.Book == nil {
			break
		}

		return e.complexity.Identifier.Book(childComplexity), true

	case "Identifier.calibreID":
		if e.complexity.Identifier.CalibreID == nil {
			break
		}

		return e.complexity.Identifier.CalibreID(childComplexity), true

	case "Identifier.id":
		if e.complexity.Identifier.ID == nil {
			break
		}

		return e.complexity.Identifier.ID(childComplexity), true

	case "Identifier.type":
		if e.complexity.Identifier.Type == nil {
			break
		}

		return e.complexity.Identifier.Type(childComplexity), true

	case "Identifier.value":
		if e.complexity.Identifier.Value == nil {
			break
		}

		return e.complexity.Identifier.Value(childComplexity), true

	case "IdentifierConnection.edges":
		if e.complexity.IdentifierConnection.Edges == nil {
			break
		}

		return e.complexity.IdentifierConnection.Edges(childComplexity), true

	case "IdentifierConnection.pageInfo":
		if e.complexity.IdentifierConnection.PageInfo == nil {
			break
		}

		return e.complexity.IdentifierConnection.PageInfo(childComplexity), true

	case "IdentifierConnection.totalCount":
		if e.complexity.IdentifierConnection.TotalCount == nil {
			break
		}

		return e.complexity.IdentifierConnection.TotalCount(childComplexity), true

	case "IdentifierEdge.cursor":
		if e.complexity.IdentifierEdge.Cursor == nil {
			break
		}

		return e.complexity.IdentifierEdge.Cursor(childComplexity), true

	case "IdentifierEdge.node":
		if e.complexity.IdentifierEdge.Node == nil {
			break
		}

		return e.complexity.IdentifierEdge.Node(childComplexity), true

	case "Language.books":
		if e.complexity.Language.Books == nil {
			break
		}

		args, err := ec.field_Language_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Language.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Language.calibreID":
		if e.complexity.Language.CalibreID == nil {
			break
		}

		return e.complexity.Language.CalibreID(childComplexity), true

	case "Language.code":
		if e.complexity.Language.Code == nil {
			break
		}

		return e.complexity.Language.Code(childComplexity), true

	case "Language.id":
		if e.complexity.Language.ID == nil {
			break
		}

		return e.complexity.Language.ID(childComplexity), true

	case "LanguageConnection.edges":
		if e.complexity.LanguageConnection.Edges == nil {
			break
		}

		return e.complexity.LanguageConnection.Edges(childComplexity), true

	case "LanguageConnection.pageInfo":
		if e.complexity.LanguageConnection.PageInfo == nil {
			break
		}

		return e.complexity.LanguageConnection.PageInfo(childComplexity), true

	case "LanguageConnection.totalCount":
		if e.complexity.LanguageConnection.TotalCount == nil {
			break
		}

		return e.complexity.LanguageConnection.TotalCount(childComplexity), true

	case "LanguageEdge.cursor":
		if e.complexity.LanguageEdge.Cursor == nil {
			break
		}

		return e.complexity.LanguageEdge.Cursor(childComplexity), true

	case "LanguageEdge.node":
		if e.complexity.LanguageEdge.Node == nil {
			break
		}

		return e.complexity.LanguageEdge.Node(childComplexity), true

	case "Mutation.createAuthor":
		if e.complexity.Mutation.CreateAuthor == nil {
			break
		}

		args, err := ec.field_Mutation_createAuthor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAuthor(childComplexity, args["input"].(ent.CreateAuthorInput)), true

	case "Mutation.createBook":
		if e.complexity.Mutation.CreateBook == nil {
			break
		}

		args, err := ec.field_Mutation_createBook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBook(childComplexity, args["input"].(ent.CreateBookInput)), true

	case "Mutation.createIdentifier":
		if e.complexity.Mutation.CreateIdentifier == nil {
			break
		}

		args, err := ec.field_Mutation_createIdentifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateIdentifier(childComplexity, args["input"].(ent.CreateIdentifierInput)), true

	case "Mutation.createLanguage":
		if e.complexity.Mutation.CreateLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_createLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLanguage(childComplexity, args["input"].(ent.CreateLanguageInput)), true

	case "Mutation.createPublisher":
		if e.complexity.Mutation.CreatePublisher == nil {
			break
		}

		args, err := ec.field_Mutation_createPublisher_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublisher(childComplexity, args["input"].(ent.CreatePublisherInput)), true

	case "Mutation.createSeries":
		if e.complexity.Mutation.CreateSeries == nil {
			break
		}

		args, err := ec.field_Mutation_createSeries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSeries(childComplexity, args["input"].(ent.CreateSeriesInput)), true

	case "Mutation.createShelf":
		if e.complexity.Mutation.CreateShelf == nil {
			break
		}

		args, err := ec.field_Mutation_createShelf_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateShelf(childComplexity, args["input"].(lybbrio.CreateShelfInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(ent.CreateTagInput)), true

	case "Mutation.createTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_createTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["input"].(lybbrio.CreateTaskInput)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(ent.CreateUserInput)), true

	case "Mutation.updateAuthor":
		if e.complexity.Mutation.UpdateAuthor == nil {
			break
		}

		args, err := ec.field_Mutation_updateAuthor_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAuthor(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateAuthorInput)), true

	case "Mutation.updateBook":
		if e.complexity.Mutation.UpdateBook == nil {
			break
		}

		args, err := ec.field_Mutation_updateBook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBook(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateBookInput)), true

	case "Mutation.updateIdentifier":
		if e.complexity.Mutation.UpdateIdentifier == nil {
			break
		}

		args, err := ec.field_Mutation_updateIdentifier_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateIdentifier(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateIdentifierInput)), true

	case "Mutation.updateLanguage":
		if e.complexity.Mutation.UpdateLanguage == nil {
			break
		}

		args, err := ec.field_Mutation_updateLanguage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLanguage(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateLanguageInput)), true

	case "Mutation.updatePublisher":
		if e.complexity.Mutation.UpdatePublisher == nil {
			break
		}

		args, err := ec.field_Mutation_updatePublisher_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublisher(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdatePublisherInput)), true

	case "Mutation.updateSeries":
		if e.complexity.Mutation.UpdateSeries == nil {
			break
		}

		args, err := ec.field_Mutation_updateSeries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSeries(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateSeriesInput)), true

	case "Mutation.updateShelf":
		if e.complexity.Mutation.UpdateShelf == nil {
			break
		}

		args, err := ec.field_Mutation_updateShelf_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateShelf(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateShelfInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateTagInput)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["id"].(ksuid.ID), args["input"].(ent.UpdateUserInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Publisher.books":
		if e.complexity.Publisher.Books == nil {
			break
		}

		args, err := ec.field_Publisher_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Publisher.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Publisher.calibreID":
		if e.complexity.Publisher.CalibreID == nil {
			break
		}

		return e.complexity.Publisher.CalibreID(childComplexity), true

	case "Publisher.id":
		if e.complexity.Publisher.ID == nil {
			break
		}

		return e.complexity.Publisher.ID(childComplexity), true

	case "Publisher.name":
		if e.complexity.Publisher.Name == nil {
			break
		}

		return e.complexity.Publisher.Name(childComplexity), true

	case "PublisherConnection.edges":
		if e.complexity.PublisherConnection.Edges == nil {
			break
		}

		return e.complexity.PublisherConnection.Edges(childComplexity), true

	case "PublisherConnection.pageInfo":
		if e.complexity.PublisherConnection.PageInfo == nil {
			break
		}

		return e.complexity.PublisherConnection.PageInfo(childComplexity), true

	case "PublisherConnection.totalCount":
		if e.complexity.PublisherConnection.TotalCount == nil {
			break
		}

		return e.complexity.PublisherConnection.TotalCount(childComplexity), true

	case "PublisherEdge.cursor":
		if e.complexity.PublisherEdge.Cursor == nil {
			break
		}

		return e.complexity.PublisherEdge.Cursor(childComplexity), true

	case "PublisherEdge.node":
		if e.complexity.PublisherEdge.Node == nil {
			break
		}

		return e.complexity.PublisherEdge.Node(childComplexity), true

	case "Query.authors":
		if e.complexity.Query.Authors == nil {
			break
		}

		args, err := ec.field_Query_authors_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Authors(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.AuthorOrder), args["where"].(*ent.AuthorWhereInput)), true

	case "Query.bookFiles":
		if e.complexity.Query.BookFiles == nil {
			break
		}

		return e.complexity.Query.BookFiles(childComplexity), true

	case "Query.books":
		if e.complexity.Query.Books == nil {
			break
		}

		args, err := ec.field_Query_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Query.identifiers":
		if e.complexity.Query.Identifiers == nil {
			break
		}

		args, err := ec.field_Query_identifiers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Identifiers(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.IdentifierOrder), args["where"].(*ent.IdentifierWhereInput)), true

	case "Query.languages":
		if e.complexity.Query.Languages == nil {
			break
		}

		args, err := ec.field_Query_languages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Languages(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.LanguageOrder), args["where"].(*ent.LanguageWhereInput)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(ksuid.ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]ksuid.ID)), true

	case "Query.publishers":
		if e.complexity.Query.Publishers == nil {
			break
		}

		args, err := ec.field_Query_publishers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Publishers(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.PublisherOrder), args["where"].(*ent.PublisherWhereInput)), true

	case "Query.seriesSlice":
		if e.complexity.Query.SeriesSlice == nil {
			break
		}

		args, err := ec.field_Query_seriesSlice_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SeriesSlice(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.SeriesOrder), args["where"].(*ent.SeriesWhereInput)), true

	case "Query.shelves":
		if e.complexity.Query.Shelves == nil {
			break
		}

		args, err := ec.field_Query_shelves_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Shelves(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.ShelfOrder), args["where"].(*ent.ShelfWhereInput)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		args, err := ec.field_Query_tags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tags(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.TagOrder), args["where"].(*ent.TagWhereInput)), true

	case "Query.tasks":
		if e.complexity.Query.Tasks == nil {
			break
		}

		args, err := ec.field_Query_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tasks(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.TaskOrder), args["where"].(*ent.TaskWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "Series.books":
		if e.complexity.Series.Books == nil {
			break
		}

		return e.complexity.Series.Books(childComplexity), true

	case "Series.calibreID":
		if e.complexity.Series.CalibreID == nil {
			break
		}

		return e.complexity.Series.CalibreID(childComplexity), true

	case "Series.id":
		if e.complexity.Series.ID == nil {
			break
		}

		return e.complexity.Series.ID(childComplexity), true

	case "Series.name":
		if e.complexity.Series.Name == nil {
			break
		}

		return e.complexity.Series.Name(childComplexity), true

	case "Series.sort":
		if e.complexity.Series.Sort == nil {
			break
		}

		return e.complexity.Series.Sort(childComplexity), true

	case "SeriesConnection.edges":
		if e.complexity.SeriesConnection.Edges == nil {
			break
		}

		return e.complexity.SeriesConnection.Edges(childComplexity), true

	case "SeriesConnection.pageInfo":
		if e.complexity.SeriesConnection.PageInfo == nil {
			break
		}

		return e.complexity.SeriesConnection.PageInfo(childComplexity), true

	case "SeriesConnection.totalCount":
		if e.complexity.SeriesConnection.TotalCount == nil {
			break
		}

		return e.complexity.SeriesConnection.TotalCount(childComplexity), true

	case "SeriesEdge.cursor":
		if e.complexity.SeriesEdge.Cursor == nil {
			break
		}

		return e.complexity.SeriesEdge.Cursor(childComplexity), true

	case "SeriesEdge.node":
		if e.complexity.SeriesEdge.Node == nil {
			break
		}

		return e.complexity.SeriesEdge.Node(childComplexity), true

	case "Shelf.books":
		if e.complexity.Shelf.Books == nil {
			break
		}

		args, err := ec.field_Shelf_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Shelf.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Shelf.description":
		if e.complexity.Shelf.Description == nil {
			break
		}

		return e.complexity.Shelf.Description(childComplexity), true

	case "Shelf.id":
		if e.complexity.Shelf.ID == nil {
			break
		}

		return e.complexity.Shelf.ID(childComplexity), true

	case "Shelf.name":
		if e.complexity.Shelf.Name == nil {
			break
		}

		return e.complexity.Shelf.Name(childComplexity), true

	case "Shelf.public":
		if e.complexity.Shelf.Public == nil {
			break
		}

		return e.complexity.Shelf.Public(childComplexity), true

	case "Shelf.user":
		if e.complexity.Shelf.User == nil {
			break
		}

		return e.complexity.Shelf.User(childComplexity), true

	case "Shelf.userID":
		if e.complexity.Shelf.UserID == nil {
			break
		}

		return e.complexity.Shelf.UserID(childComplexity), true

	case "ShelfConnection.edges":
		if e.complexity.ShelfConnection.Edges == nil {
			break
		}

		return e.complexity.ShelfConnection.Edges(childComplexity), true

	case "ShelfConnection.pageInfo":
		if e.complexity.ShelfConnection.PageInfo == nil {
			break
		}

		return e.complexity.ShelfConnection.PageInfo(childComplexity), true

	case "ShelfConnection.totalCount":
		if e.complexity.ShelfConnection.TotalCount == nil {
			break
		}

		return e.complexity.ShelfConnection.TotalCount(childComplexity), true

	case "ShelfEdge.cursor":
		if e.complexity.ShelfEdge.Cursor == nil {
			break
		}

		return e.complexity.ShelfEdge.Cursor(childComplexity), true

	case "ShelfEdge.node":
		if e.complexity.ShelfEdge.Node == nil {
			break
		}

		return e.complexity.ShelfEdge.Node(childComplexity), true

	case "Tag.books":
		if e.complexity.Tag.Books == nil {
			break
		}

		args, err := ec.field_Tag_books_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Tag.Books(childComplexity, args["after"].(*entgql.Cursor[ksuid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[ksuid.ID]), args["last"].(*int), args["orderBy"].([]*ent.BookOrder), args["where"].(*ent.BookWhereInput)), true

	case "Tag.calibreID":
		if e.complexity.Tag.CalibreID == nil {
			break
		}

		return e.complexity.Tag.CalibreID(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "TagConnection.edges":
		if e.complexity.TagConnection.Edges == nil {
			break
		}

		return e.complexity.TagConnection.Edges(childComplexity), true

	case "TagConnection.pageInfo":
		if e.complexity.TagConnection.PageInfo == nil {
			break
		}

		return e.complexity.TagConnection.PageInfo(childComplexity), true

	case "TagConnection.totalCount":
		if e.complexity.TagConnection.TotalCount == nil {
			break
		}

		return e.complexity.TagConnection.TotalCount(childComplexity), true

	case "TagEdge.cursor":
		if e.complexity.TagEdge.Cursor == nil {
			break
		}

		return e.complexity.TagEdge.Cursor(childComplexity), true

	case "TagEdge.node":
		if e.complexity.TagEdge.Node == nil {
			break
		}

		return e.complexity.TagEdge.Node(childComplexity), true

	case "Task.createTime":
		if e.complexity.Task.CreateTime == nil {
			break
		}

		return e.complexity.Task.CreateTime(childComplexity), true

	case "Task.error":
		if e.complexity.Task.Error == nil {
			break
		}

		return e.complexity.Task.Error(childComplexity), true

	case "Task.id":
		if e.complexity.Task.ID == nil {
			break
		}

		return e.complexity.Task.ID(childComplexity), true

	case "Task.isSystemTask":
		if e.complexity.Task.IsSystemTask == nil {
			break
		}

		return e.complexity.Task.IsSystemTask(childComplexity), true

	case "Task.message":
		if e.complexity.Task.Message == nil {
			break
		}

		return e.complexity.Task.Message(childComplexity), true

	case "Task.progress":
		if e.complexity.Task.Progress == nil {
			break
		}

		return e.complexity.Task.Progress(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.type":
		if e.complexity.Task.Type == nil {
			break
		}

		return e.complexity.Task.Type(childComplexity), true

	case "Task.updateTime":
		if e.complexity.Task.UpdateTime == nil {
			break
		}

		return e.complexity.Task.UpdateTime(childComplexity), true

	case "Task.user":
		if e.complexity.Task.User == nil {
			break
		}

		return e.complexity.Task.User(childComplexity), true

	case "Task.userID":
		if e.complexity.Task.UserID == nil {
			break
		}

		return e.complexity.Task.UserID(childComplexity), true

	case "TaskConnection.edges":
		if e.complexity.TaskConnection.Edges == nil {
			break
		}

		return e.complexity.TaskConnection.Edges(childComplexity), true

	case "TaskConnection.pageInfo":
		if e.complexity.TaskConnection.PageInfo == nil {
			break
		}

		return e.complexity.TaskConnection.PageInfo(childComplexity), true

	case "TaskConnection.totalCount":
		if e.complexity.TaskConnection.TotalCount == nil {
			break
		}

		return e.complexity.TaskConnection.TotalCount(childComplexity), true

	case "TaskEdge.cursor":
		if e.complexity.TaskEdge.Cursor == nil {
			break
		}

		return e.complexity.TaskEdge.Cursor(childComplexity), true

	case "TaskEdge.node":
		if e.complexity.TaskEdge.Node == nil {
			break
		}

		return e.complexity.TaskEdge.Node(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.shelves":
		if e.complexity.User.Shelves == nil {
			break
		}

		return e.complexity.User.Shelves(childComplexity), true

	case "User.userPermissions":
		if e.complexity.User.UserPermissions == nil {
			break
		}

		return e.complexity.User.UserPermissions(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserPermissions.admin":
		if e.complexity.UserPermissions.Admin == nil {
			break
		}

		return e.complexity.UserPermissions.Admin(childComplexity), true

	case "UserPermissions.cancreatepublic":
		if e.complexity.UserPermissions.CanCreatePublic == nil {
			break
		}

		return e.complexity.UserPermissions.CanCreatePublic(childComplexity), true

	case "UserPermissions.canedit":
		if e.complexity.UserPermissions.CanEdit == nil {
			break
		}

		return e.complexity.UserPermissions.CanEdit(childComplexity), true

	case "UserPermissions.id":
		if e.complexity.UserPermissions.ID == nil {
			break
		}

		return e.complexity.UserPermissions.ID(childComplexity), true

	case "UserPermissions.user":
		if e.complexity.UserPermissions.User == nil {
			break
		}

		return e.complexity.UserPermissions.User(childComplexity), true

	case "UserPermissions.userID":
		if e.complexity.UserPermissions.UserID == nil {
			break
		}

		return e.complexity.UserPermissions.UserID(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAuthorOrder,
		ec.unmarshalInputAuthorWhereInput,
		ec.unmarshalInputBookFileWhereInput,
		ec.unmarshalInputBookOrder,
		ec.unmarshalInputBookWhereInput,
		ec.unmarshalInputCreateAuthorInput,
		ec.unmarshalInputCreateBookInput,
		ec.unmarshalInputCreateIdentifierInput,
		ec.unmarshalInputCreateLanguageInput,
		ec.unmarshalInputCreatePublisherInput,
		ec.unmarshalInputCreateSeriesInput,
		ec.unmarshalInputCreateShelfInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputCreateTaskInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputIdentifierOrder,
		ec.unmarshalInputIdentifierWhereInput,
		ec.unmarshalInputLanguageOrder,
		ec.unmarshalInputLanguageWhereInput,
		ec.unmarshalInputPublisherOrder,
		ec.unmarshalInputPublisherWhereInput,
		ec.unmarshalInputSeriesOrder,
		ec.unmarshalInputSeriesWhereInput,
		ec.unmarshalInputShelfOrder,
		ec.unmarshalInputShelfWhereInput,
		ec.unmarshalInputTagOrder,
		ec.unmarshalInputTagWhereInput,
		ec.unmarshalInputTaskOrder,
		ec.unmarshalInputTaskWhereInput,
		ec.unmarshalInputUpdateAuthorInput,
		ec.unmarshalInputUpdateBookInput,
		ec.unmarshalInputUpdateIdentifierInput,
		ec.unmarshalInputUpdateLanguageInput,
		ec.unmarshalInputUpdatePublisherInput,
		ec.unmarshalInputUpdateSeriesInput,
		ec.unmarshalInputUpdateShelfInput,
		ec.unmarshalInputUpdateTagInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserOrder,
		ec.unmarshalInputUserPermissionsWhereInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Author implements Node {
  id: ID!
  calibreID: Int
  name: String!
  sort: String!
  link: String
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
}
"""A connection to a list of items."""
type AuthorConnection {
  """A list of edges."""
  edges: [AuthorEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type AuthorEdge {
  """The item at the end of the edge."""
  node: Author
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Author connections"""
input AuthorOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Authors."""
  field: AuthorOrderField!
}
"""Properties by which Author connections can be ordered."""
enum AuthorOrderField {
  NAME
  BOOKS_COUNT
}
"""
AuthorWhereInput is used for filtering Author objects.
Input was generated by ent.
"""
input AuthorWhereInput {
  not: AuthorWhereInput
  and: [AuthorWhereInput!]
  or: [AuthorWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """sort field predicates"""
  sort: String
  sortNEQ: String
  sortIn: [String!]
  sortNotIn: [String!]
  sortGT: String
  sortGTE: String
  sortLT: String
  sortLTE: String
  sortContains: String
  sortHasPrefix: String
  sortHasSuffix: String
  sortEqualFold: String
  sortContainsFold: String
  """link field predicates"""
  link: String
  linkNEQ: String
  linkIn: [String!]
  linkNotIn: [String!]
  linkGT: String
  linkGTE: String
  linkLT: String
  linkLTE: String
  linkContains: String
  linkHasPrefix: String
  linkHasSuffix: String
  linkIsNil: Boolean
  linkNotNil: Boolean
  linkEqualFold: String
  linkContainsFold: String
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
type Book implements Node {
  id: ID!
  calibreID: Int
  title: String!
  sort: String!
  publishedDate: Time
  path: String!
  isbn: String
  description: String
  seriesIndex: Float
  authors: [Author!]
  publisher: [Publisher!]
  series: [Series!]
  identifiers: [Identifier!]
  tags: [Tag!]
  language: [Language!]
  shelf: [Shelf!]
}
"""A connection to a list of items."""
type BookConnection {
  """A list of edges."""
  edges: [BookEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type BookEdge {
  """The item at the end of the edge."""
  node: Book
  """A cursor for use in pagination."""
  cursor: Cursor!
}
type BookFile implements Node {
  id: ID!
  path: String!
  """Size in bytes"""
  size: Int!
  format: BookFileFormat!
  book: Book!
}
"""BookFileFormat is enum for the field format"""
enum BookFileFormat @goModel(model: "lybbrio/internal/ent/bookfile.Format") {
  AZW3
  EPUB
  KEPUB
  PDF
  CBC
  CBR
  CB7
  CBZ
  CBT
}
"""
BookFileWhereInput is used for filtering BookFile objects.
Input was generated by ent.
"""
input BookFileWhereInput {
  not: BookFileWhereInput
  and: [BookFileWhereInput!]
  or: [BookFileWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """path field predicates"""
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """size field predicates"""
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  """format field predicates"""
  format: BookFileFormat
  formatNEQ: BookFileFormat
  formatIn: [BookFileFormat!]
  formatNotIn: [BookFileFormat!]
  """book edge predicates"""
  hasBook: Boolean
  hasBookWith: [BookWhereInput!]
}
"""Ordering options for Book connections"""
input BookOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Books."""
  field: BookOrderField!
}
"""Properties by which Book connections can be ordered."""
enum BookOrderField {
  TITLE
  NAME
  PUB_DATE
  ISBN
}
"""
BookWhereInput is used for filtering Book objects.
Input was generated by ent.
"""
input BookWhereInput {
  not: BookWhereInput
  and: [BookWhereInput!]
  or: [BookWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """title field predicates"""
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleEqualFold: String
  titleContainsFold: String
  """sort field predicates"""
  sort: String
  sortNEQ: String
  sortIn: [String!]
  sortNotIn: [String!]
  sortGT: String
  sortGTE: String
  sortLT: String
  sortLTE: String
  sortContains: String
  sortHasPrefix: String
  sortHasSuffix: String
  sortEqualFold: String
  sortContainsFold: String
  """published_date field predicates"""
  publishedDate: Time
  publishedDateNEQ: Time
  publishedDateIn: [Time!]
  publishedDateNotIn: [Time!]
  publishedDateGT: Time
  publishedDateGTE: Time
  publishedDateLT: Time
  publishedDateLTE: Time
  publishedDateIsNil: Boolean
  publishedDateNotNil: Boolean
  """path field predicates"""
  path: String
  pathNEQ: String
  pathIn: [String!]
  pathNotIn: [String!]
  pathGT: String
  pathGTE: String
  pathLT: String
  pathLTE: String
  pathContains: String
  pathHasPrefix: String
  pathHasSuffix: String
  pathEqualFold: String
  pathContainsFold: String
  """isbn field predicates"""
  isbn: String
  isbnNEQ: String
  isbnIn: [String!]
  isbnNotIn: [String!]
  isbnGT: String
  isbnGTE: String
  isbnLT: String
  isbnLTE: String
  isbnContains: String
  isbnHasPrefix: String
  isbnHasSuffix: String
  isbnIsNil: Boolean
  isbnNotNil: Boolean
  isbnEqualFold: String
  isbnContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """series_index field predicates"""
  seriesIndex: Float
  seriesIndexNEQ: Float
  seriesIndexIn: [Float!]
  seriesIndexNotIn: [Float!]
  seriesIndexGT: Float
  seriesIndexGTE: Float
  seriesIndexLT: Float
  seriesIndexLTE: Float
  seriesIndexIsNil: Boolean
  seriesIndexNotNil: Boolean
  """authors edge predicates"""
  hasAuthors: Boolean
  hasAuthorsWith: [AuthorWhereInput!]
  """publisher edge predicates"""
  hasPublisher: Boolean
  hasPublisherWith: [PublisherWhereInput!]
  """series edge predicates"""
  hasSeries: Boolean
  hasSeriesWith: [SeriesWhereInput!]
  """identifiers edge predicates"""
  hasIdentifiers: Boolean
  hasIdentifiersWith: [IdentifierWhereInput!]
  """tags edge predicates"""
  hasTags: Boolean
  hasTagsWith: [TagWhereInput!]
  """language edge predicates"""
  hasLanguage: Boolean
  hasLanguageWith: [LanguageWhereInput!]
  """shelf edge predicates"""
  hasShelf: Boolean
  hasShelfWith: [ShelfWhereInput!]
}
"""
CreateAuthorInput is used for create Author object.
Input was generated by ent.
"""
input CreateAuthorInput {
  calibreID: Int
  name: String!
  sort: String!
  link: String
  bookIDs: [ID!]
}
"""
CreateBookInput is used for create Book object.
Input was generated by ent.
"""
input CreateBookInput {
  calibreID: Int
  title: String!
  sort: String!
  publishedDate: Time
  path: String!
  isbn: String
  description: String
  seriesIndex: Float
  authorIDs: [ID!]
  publisherIDs: [ID!]
  seriesIDs: [ID!]
  identifierIDs: [ID!]
  tagIDs: [ID!]
  languageIDs: [ID!]
  shelfIDs: [ID!]
}
"""
CreateIdentifierInput is used for create Identifier object.
Input was generated by ent.
"""
input CreateIdentifierInput {
  calibreID: Int
  type: String!
  value: String!
  bookID: ID!
}
"""
CreateLanguageInput is used for create Language object.
Input was generated by ent.
"""
input CreateLanguageInput {
  calibreID: Int
  code: String!
  bookIDs: [ID!]
}
"""
CreatePublisherInput is used for create Publisher object.
Input was generated by ent.
"""
input CreatePublisherInput {
  calibreID: Int
  name: String!
  bookIDs: [ID!]
}
"""
CreateSeriesInput is used for create Series object.
Input was generated by ent.
"""
input CreateSeriesInput {
  calibreID: Int
  name: String!
  sort: String!
  bookIDs: [ID!]
}
"""
CreateTagInput is used for create Tag object.
Input was generated by ent.
"""
input CreateTagInput {
  calibreID: Int
  name: String!
  bookIDs: [ID!]
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  username: String!
  passwordHash: String
  email: String!
  shelfIDs: [ID!]
  userPermissionsID: ID!
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Identifier implements Node {
  id: ID!
  calibreID: Int
  type: String!
  value: String!
  book: Book!
}
"""A connection to a list of items."""
type IdentifierConnection {
  """A list of edges."""
  edges: [IdentifierEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type IdentifierEdge {
  """The item at the end of the edge."""
  node: Identifier
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Identifier connections"""
input IdentifierOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Identifiers."""
  field: IdentifierOrderField!
}
"""Properties by which Identifier connections can be ordered."""
enum IdentifierOrderField {
  TYPE
  VALUE
}
"""
IdentifierWhereInput is used for filtering Identifier objects.
Input was generated by ent.
"""
input IdentifierWhereInput {
  not: IdentifierWhereInput
  and: [IdentifierWhereInput!]
  or: [IdentifierWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """type field predicates"""
  type: String
  typeNEQ: String
  typeIn: [String!]
  typeNotIn: [String!]
  typeGT: String
  typeGTE: String
  typeLT: String
  typeLTE: String
  typeContains: String
  typeHasPrefix: String
  typeHasSuffix: String
  typeEqualFold: String
  typeContainsFold: String
  """value field predicates"""
  value: String
  valueNEQ: String
  valueIn: [String!]
  valueNotIn: [String!]
  valueGT: String
  valueGTE: String
  valueLT: String
  valueLTE: String
  valueContains: String
  valueHasPrefix: String
  valueHasSuffix: String
  valueEqualFold: String
  valueContainsFold: String
  """book edge predicates"""
  hasBook: Boolean
  hasBookWith: [BookWhereInput!]
}
type Language implements Node {
  id: ID!
  calibreID: Int
  code: String!
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
}
"""A connection to a list of items."""
type LanguageConnection {
  """A list of edges."""
  edges: [LanguageEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type LanguageEdge {
  """The item at the end of the edge."""
  node: Language
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Language connections"""
input LanguageOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Languages."""
  field: LanguageOrderField!
}
"""Properties by which Language connections can be ordered."""
enum LanguageOrderField {
  BOOKS_COUNT
}
"""
LanguageWhereInput is used for filtering Language objects.
Input was generated by ent.
"""
input LanguageWhereInput {
  not: LanguageWhereInput
  and: [LanguageWhereInput!]
  or: [LanguageWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """code field predicates"""
  code: String
  codeNEQ: String
  codeIn: [String!]
  codeNotIn: [String!]
  codeGT: String
  codeGTE: String
  codeLT: String
  codeLTE: String
  codeContains: String
  codeHasPrefix: String
  codeHasSuffix: String
  codeEqualFold: String
  codeContainsFold: String
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "lybbrio/internal/ent.Noder") {
  """The id of the object."""
  id: ID!
}
"""Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument."""
enum OrderDirection {
  """Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  ASC
  """Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument."""
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}
type Publisher implements Node {
  id: ID!
  calibreID: Int
  name: String!
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
}
"""A connection to a list of items."""
type PublisherConnection {
  """A list of edges."""
  edges: [PublisherEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type PublisherEdge {
  """The item at the end of the edge."""
  node: Publisher
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Publisher connections"""
input PublisherOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Publishers."""
  field: PublisherOrderField!
}
"""Properties by which Publisher connections can be ordered."""
enum PublisherOrderField {
  NAME
  BOOKS_COUNT
}
"""
PublisherWhereInput is used for filtering Publisher objects.
Input was generated by ent.
"""
input PublisherWhereInput {
  not: PublisherWhereInput
  and: [PublisherWhereInput!]
  or: [PublisherWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
type Query {
  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node
  """Lookup nodes by a list of IDs."""
  nodes(
    """The list of node IDs."""
    ids: [ID!]!
  ): [Node]!
  authors(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Authors returned from the connection."""
    orderBy: [AuthorOrder!]

    """Filtering options for Authors returned from the connection."""
    where: AuthorWhereInput
  ): AuthorConnection!
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
  bookFiles: [BookFile!]!
  identifiers(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Identifiers returned from the connection."""
    orderBy: [IdentifierOrder!]

    """Filtering options for Identifiers returned from the connection."""
    where: IdentifierWhereInput
  ): IdentifierConnection!
  languages(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Languages returned from the connection."""
    orderBy: [LanguageOrder!]

    """Filtering options for Languages returned from the connection."""
    where: LanguageWhereInput
  ): LanguageConnection!
  publishers(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Publishers returned from the connection."""
    orderBy: [PublisherOrder!]

    """Filtering options for Publishers returned from the connection."""
    where: PublisherWhereInput
  ): PublisherConnection!
  seriesSlice(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for SeriesSlice returned from the connection."""
    orderBy: [SeriesOrder!]

    """Filtering options for SeriesSlice returned from the connection."""
    where: SeriesWhereInput
  ): SeriesConnection!
  shelves(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Shelves returned from the connection."""
    orderBy: [ShelfOrder!]

    """Filtering options for Shelves returned from the connection."""
    where: ShelfWhereInput
  ): ShelfConnection!
  tags(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tags returned from the connection."""
    orderBy: [TagOrder!]

    """Filtering options for Tags returned from the connection."""
    where: TagWhereInput
  ): TagConnection!
  tasks(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Tasks returned from the connection."""
    orderBy: [TaskOrder!]

    """Filtering options for Tasks returned from the connection."""
    where: TaskWhereInput
  ): TaskConnection!
  users: [User!]!
}
type Series implements Node {
  id: ID!
  calibreID: Int
  name: String!
  sort: String!
  books: [Book!]
}
"""A connection to a list of items."""
type SeriesConnection {
  """A list of edges."""
  edges: [SeriesEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type SeriesEdge {
  """The item at the end of the edge."""
  node: Series
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Series connections"""
input SeriesOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order SeriesSlice."""
  field: SeriesOrderField!
}
"""Properties by which Series connections can be ordered."""
enum SeriesOrderField {
  NAME
}
"""
SeriesWhereInput is used for filtering Series objects.
Input was generated by ent.
"""
input SeriesWhereInput {
  not: SeriesWhereInput
  and: [SeriesWhereInput!]
  or: [SeriesWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """sort field predicates"""
  sort: String
  sortNEQ: String
  sortIn: [String!]
  sortNotIn: [String!]
  sortGT: String
  sortGTE: String
  sortLT: String
  sortLTE: String
  sortContains: String
  sortHasPrefix: String
  sortHasSuffix: String
  sortEqualFold: String
  sortContainsFold: String
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
type Shelf implements Node {
  id: ID!
  public: Boolean!
  userID: ID!
  name: String!
  description: String
  user: User!
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
}
"""A connection to a list of items."""
type ShelfConnection {
  """A list of edges."""
  edges: [ShelfEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type ShelfEdge {
  """The item at the end of the edge."""
  node: Shelf
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Shelf connections"""
input ShelfOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Shelves."""
  field: ShelfOrderField!
}
"""Properties by which Shelf connections can be ordered."""
enum ShelfOrderField {
  NAME
  BOOKS_COUNT
}
"""
ShelfWhereInput is used for filtering Shelf objects.
Input was generated by ent.
"""
input ShelfWhereInput {
  not: ShelfWhereInput
  and: [ShelfWhereInput!]
  or: [ShelfWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """public field predicates"""
  public: Boolean
  publicNEQ: Boolean
  """user_id field predicates"""
  userID: ID
  userIDNEQ: ID
  userIDIn: [ID!]
  userIDNotIn: [ID!]
  userIDGT: ID
  userIDGTE: ID
  userIDLT: ID
  userIDLTE: ID
  userIDContains: ID
  userIDHasPrefix: ID
  userIDHasSuffix: ID
  userIDEqualFold: ID
  userIDContainsFold: ID
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """description field predicates"""
  description: String
  descriptionNEQ: String
  descriptionIn: [String!]
  descriptionNotIn: [String!]
  descriptionGT: String
  descriptionGTE: String
  descriptionLT: String
  descriptionLTE: String
  descriptionContains: String
  descriptionHasPrefix: String
  descriptionHasSuffix: String
  descriptionIsNil: Boolean
  descriptionNotNil: Boolean
  descriptionEqualFold: String
  descriptionContainsFold: String
  """user edge predicates"""
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
type Tag implements Node {
  id: ID!
  calibreID: Int
  name: String!
  books(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the elements in the list that come before the specified cursor."""
    before: Cursor

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for Books returned from the connection."""
    orderBy: [BookOrder!]

    """Filtering options for Books returned from the connection."""
    where: BookWhereInput
  ): BookConnection!
}
"""A connection to a list of items."""
type TagConnection {
  """A list of edges."""
  edges: [TagEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TagEdge {
  """The item at the end of the edge."""
  node: Tag
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Tag connections"""
input TagOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tags."""
  field: TagOrderField!
}
"""Properties by which Tag connections can be ordered."""
enum TagOrderField {
  NAME
  BOOKS_COUNT
}
"""
TagWhereInput is used for filtering Tag objects.
Input was generated by ent.
"""
input TagWhereInput {
  not: TagWhereInput
  and: [TagWhereInput!]
  or: [TagWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """calibre_id field predicates"""
  calibreID: Int
  calibreIDNEQ: Int
  calibreIDIn: [Int!]
  calibreIDNotIn: [Int!]
  calibreIDGT: Int
  calibreIDGTE: Int
  calibreIDLT: Int
  calibreIDLTE: Int
  calibreIDIsNil: Boolean
  calibreIDNotNil: Boolean
  """name field predicates"""
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """books edge predicates"""
  hasBooks: Boolean
  hasBooksWith: [BookWhereInput!]
}
type Task implements Node {
  id: ID!
  createTime: Time!
  updateTime: Time!
  type: TaskTaskType!
  status: TaskStatus!
  """Progress of the task. 0-1"""
  progress: Float!
  """Message of the task"""
  message: String
  """Error message of the task"""
  error: String
  """The user who created this task. Empty for System Task"""
  userID: ID
  """Whether this task is created by the system"""
  isSystemTask: Boolean!
  user: User
}
"""A connection to a list of items."""
type TaskConnection {
  """A list of edges."""
  edges: [TaskEdge]
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Identifies the total count of items in the connection."""
  totalCount: Int!
}
"""An edge in a connection."""
type TaskEdge {
  """The item at the end of the edge."""
  node: Task
  """A cursor for use in pagination."""
  cursor: Cursor!
}
"""Ordering options for Task connections"""
input TaskOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Tasks."""
  field: TaskOrderField!
}
"""Properties by which Task connections can be ordered."""
enum TaskOrderField {
  TYPE
  STATUS
}
"""TaskStatus is enum for the field status"""
enum TaskStatus @goModel(model: "lybbrio/internal/ent/schema/task_enums.Status") {
  pending
  in_progress
  success
  failure
}
"""TaskTaskType is enum for the field type"""
enum TaskTaskType @goModel(model: "lybbrio/internal/ent/schema/task_enums.TaskType") {
  noop
  calibre_import
}
"""
TaskWhereInput is used for filtering Task objects.
Input was generated by ent.
"""
input TaskWhereInput {
  not: TaskWhereInput
  and: [TaskWhereInput!]
  or: [TaskWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """create_time field predicates"""
  createTime: Time
  createTimeNEQ: Time
  createTimeIn: [Time!]
  createTimeNotIn: [Time!]
  createTimeGT: Time
  createTimeGTE: Time
  createTimeLT: Time
  createTimeLTE: Time
  """update_time field predicates"""
  updateTime: Time
  updateTimeNEQ: Time
  updateTimeIn: [Time!]
  updateTimeNotIn: [Time!]
  updateTimeGT: Time
  updateTimeGTE: Time
  updateTimeLT: Time
  updateTimeLTE: Time
  """type field predicates"""
  type: TaskTaskType
  typeNEQ: TaskTaskType
  typeIn: [TaskTaskType!]
  typeNotIn: [TaskTaskType!]
  """status field predicates"""
  status: TaskStatus
  statusNEQ: TaskStatus
  statusIn: [TaskStatus!]
  statusNotIn: [TaskStatus!]
  """progress field predicates"""
  progress: Float
  progressNEQ: Float
  progressIn: [Float!]
  progressNotIn: [Float!]
  progressGT: Float
  progressGTE: Float
  progressLT: Float
  progressLTE: Float
  """message field predicates"""
  message: String
  messageNEQ: String
  messageIn: [String!]
  messageNotIn: [String!]
  messageGT: String
  messageGTE: String
  messageLT: String
  messageLTE: String
  messageContains: String
  messageHasPrefix: String
  messageHasSuffix: String
  messageIsNil: Boolean
  messageNotNil: Boolean
  messageEqualFold: String
  messageContainsFold: String
  """error field predicates"""
  error: String
  errorNEQ: String
  errorIn: [String!]
  errorNotIn: [String!]
  errorGT: String
  errorGTE: String
  errorLT: String
  errorLTE: String
  errorContains: String
  errorHasPrefix: String
  errorHasSuffix: String
  errorIsNil: Boolean
  errorNotNil: Boolean
  errorEqualFold: String
  errorContainsFold: String
  """user_id field predicates"""
  userID: ID
  userIDNEQ: ID
  userIDIn: [ID!]
  userIDNotIn: [ID!]
  userIDGT: ID
  userIDGTE: ID
  userIDLT: ID
  userIDLTE: ID
  userIDContains: ID
  userIDHasPrefix: ID
  userIDHasSuffix: ID
  userIDIsNil: Boolean
  userIDNotNil: Boolean
  userIDEqualFold: ID
  userIDContainsFold: ID
  """is_system_task field predicates"""
  isSystemTask: Boolean
  isSystemTaskNEQ: Boolean
  """user edge predicates"""
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
"""The builtin Time type"""
scalar Time
"""
UpdateAuthorInput is used for update Author object.
Input was generated by ent.
"""
input UpdateAuthorInput {
  calibreID: Int
  clearCalibreID: Boolean
  name: String
  sort: String
  link: String
  clearLink: Boolean
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdateBookInput is used for update Book object.
Input was generated by ent.
"""
input UpdateBookInput {
  calibreID: Int
  clearCalibreID: Boolean
  title: String
  sort: String
  publishedDate: Time
  clearPublishedDate: Boolean
  path: String
  isbn: String
  clearIsbn: Boolean
  description: String
  clearDescription: Boolean
  seriesIndex: Float
  clearSeriesIndex: Boolean
  addAuthorIDs: [ID!]
  removeAuthorIDs: [ID!]
  clearAuthors: Boolean
  addPublisherIDs: [ID!]
  removePublisherIDs: [ID!]
  clearPublisher: Boolean
  addSeriesIDs: [ID!]
  removeSeriesIDs: [ID!]
  clearSeries: Boolean
  addIdentifierIDs: [ID!]
  removeIdentifierIDs: [ID!]
  clearIdentifiers: Boolean
  addTagIDs: [ID!]
  removeTagIDs: [ID!]
  clearTags: Boolean
  addLanguageIDs: [ID!]
  removeLanguageIDs: [ID!]
  clearLanguage: Boolean
  addShelfIDs: [ID!]
  removeShelfIDs: [ID!]
  clearShelf: Boolean
}
"""
UpdateIdentifierInput is used for update Identifier object.
Input was generated by ent.
"""
input UpdateIdentifierInput {
  calibreID: Int
  clearCalibreID: Boolean
  type: String
  value: String
  bookID: ID
}
"""
UpdateLanguageInput is used for update Language object.
Input was generated by ent.
"""
input UpdateLanguageInput {
  calibreID: Int
  clearCalibreID: Boolean
  code: String
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdatePublisherInput is used for update Publisher object.
Input was generated by ent.
"""
input UpdatePublisherInput {
  calibreID: Int
  clearCalibreID: Boolean
  name: String
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdateSeriesInput is used for update Series object.
Input was generated by ent.
"""
input UpdateSeriesInput {
  calibreID: Int
  clearCalibreID: Boolean
  name: String
  sort: String
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdateShelfInput is used for update Shelf object.
Input was generated by ent.
"""
input UpdateShelfInput {
  public: Boolean
  name: String
  description: String
  clearDescription: Boolean
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdateTagInput is used for update Tag object.
Input was generated by ent.
"""
input UpdateTagInput {
  calibreID: Int
  clearCalibreID: Boolean
  name: String
  addBookIDs: [ID!]
  removeBookIDs: [ID!]
  clearBooks: Boolean
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  username: String
  passwordHash: String
  clearPasswordHash: Boolean
  email: String
  addShelfIDs: [ID!]
  removeShelfIDs: [ID!]
  clearShelves: Boolean
}
type User implements Node {
  id: ID!
  username: String!
  email: String!
  shelves: [Shelf!]
  userPermissions: UserPermissions!
}
"""Ordering options for User connections"""
input UserOrder {
  """The ordering direction."""
  direction: OrderDirection! = ASC
  """The field by which to order Users."""
  field: UserOrderField!
}
"""Properties by which User connections can be ordered."""
enum UserOrderField {
  USERNAME
}
type UserPermissions implements Node {
  id: ID!
  userID: ID
  admin: Boolean!
  cancreatepublic: Boolean! @goField(name: "CanCreatePublic", forceResolver: false)
  canedit: Boolean! @goField(name: "CanEdit", forceResolver: false)
  user: User
}
"""
UserPermissionsWhereInput is used for filtering UserPermissions objects.
Input was generated by ent.
"""
input UserPermissionsWhereInput {
  not: UserPermissionsWhereInput
  and: [UserPermissionsWhereInput!]
  or: [UserPermissionsWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """user_id field predicates"""
  userID: ID
  userIDNEQ: ID
  userIDIn: [ID!]
  userIDNotIn: [ID!]
  userIDGT: ID
  userIDGTE: ID
  userIDLT: ID
  userIDLTE: ID
  userIDContains: ID
  userIDHasPrefix: ID
  userIDHasSuffix: ID
  userIDIsNil: Boolean
  userIDNotNil: Boolean
  userIDEqualFold: ID
  userIDContainsFold: ID
  """Admin field predicates"""
  admin: Boolean
  adminNEQ: Boolean
  """CanCreatePublic field predicates"""
  cancreatepublic: Boolean
  cancreatepublicNEQ: Boolean
  """CanEdit field predicates"""
  canedit: Boolean
  caneditNEQ: Boolean
  """user edge predicates"""
  hasUser: Boolean
  hasUserWith: [UserWhereInput!]
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """id field predicates"""
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """username field predicates"""
  username: String
  usernameNEQ: String
  usernameIn: [String!]
  usernameNotIn: [String!]
  usernameGT: String
  usernameGTE: String
  usernameLT: String
  usernameLTE: String
  usernameContains: String
  usernameHasPrefix: String
  usernameHasSuffix: String
  usernameEqualFold: String
  usernameContainsFold: String
  """email field predicates"""
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """shelves edge predicates"""
  hasShelves: Boolean
  hasShelvesWith: [ShelfWhereInput!]
  """user_permissions edge predicates"""
  hasUserPermissions: Boolean
  hasUserPermissionsWith: [UserPermissionsWhereInput!]
}
`, BuiltIn: false},
	{Name: "../me.graphql", Input: `extend type Query {
    """Returns the currently logged in user"""
    me: User!
}`, BuiltIn: false},
	{Name: "../mutation.graphql", Input: `input CreateShelfInput {
    name: String!
    description: String
    public: Boolean
    bookIDs: [ID!]
}

"""
CreateTaskInput is used for create Task object.
Input was generated by ent.
"""
input CreateTaskInput {
  type: TaskTaskType!
}

type Mutation {
    # The input and the output are types generated by Ent.
    createBook(input: CreateBookInput!): Book # Delete later, should only be createable from disk.
    updateBook(id: ID!, input: UpdateBookInput!): Book

    createAuthor(input: CreateAuthorInput!): Author
    updateAuthor(id: ID!, input: UpdateAuthorInput!): Author

    createShelf(input: CreateShelfInput!): Shelf
    updateShelf(id: ID!, input: UpdateShelfInput!): Shelf

    createTag(input: CreateTagInput!): Tag
    updateTag(id: ID!, input: UpdateTagInput!): Tag

    createPublisher(input: CreatePublisherInput!): Publisher
    updatePublisher(id: ID!, input: UpdatePublisherInput!): Publisher

    createLanguage(input: CreateLanguageInput!): Language
    updateLanguage(id: ID!, input: UpdateLanguageInput!): Language

    createSeries(input: CreateSeriesInput!): Series
    updateSeries(id: ID!, input: UpdateSeriesInput!): Series

    createIdentifier(input: CreateIdentifierInput!): Identifier
    updateIdentifier(id: ID!, input: UpdateIdentifierInput!): Identifier

    createUser(input: CreateUserInput!): User
    updateUser(id: ID!, input: UpdateUserInput!): User
    # TODO: User Mutations should have a more bespoke flow.

    createTask(input: CreateTaskInput!): Task
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Author_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Language_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_createAuthor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateAuthorInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateAuthorInput2lybbriointernalentCreateAuthorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createBook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateBookInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateBookInput2lybbriointernalentCreateBookInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createIdentifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateIdentifierInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateIdentifierInput2lybbriointernalentCreateIdentifierInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateLanguageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLanguageInput2lybbriointernalentCreateLanguageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createPublisher_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreatePublisherInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreatePublisherInput2lybbriointernalentCreatePublisherInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createSeries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateSeriesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSeriesInput2lybbriointernalentCreateSeriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createShelf_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 lybbrio.CreateShelfInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateShelfInput2lybbrioCreateShelfInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateTagInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateTagInput2lybbriointernalentCreateTagInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 lybbrio.CreateTaskInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateTaskInput2lybbrioCreateTaskInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ent.CreateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUserInput2lybbriointernalentCreateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateAuthor_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateAuthorInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateAuthorInput2lybbriointernalentUpdateAuthorInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateBook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateBookInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateBookInput2lybbriointernalentUpdateBookInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateIdentifier_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateIdentifierInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateIdentifierInput2lybbriointernalentUpdateIdentifierInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLanguage_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateLanguageInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateLanguageInput2lybbriointernalentUpdateLanguageInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePublisher_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdatePublisherInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdatePublisherInput2lybbriointernalentUpdatePublisherInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSeries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateSeriesInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateSeriesInput2lybbriointernalentUpdateSeriesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateShelf_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateShelfInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateShelfInput2lybbriointernalentUpdateShelfInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateTagInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateTagInput2lybbriointernalentUpdateTagInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 ent.UpdateUserInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNUpdateUserInput2lybbriointernalentUpdateUserInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Publisher_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_authors_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.AuthorOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOAuthorOrder2lybbriointernalentAuthorOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.AuthorWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_identifiers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.IdentifierOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOIdentifierOrder2lybbriointernalentIdentifierOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.IdentifierWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_languages_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.LanguageOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOLanguageOrder2lybbriointernalentLanguageOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.LanguageWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ksuid.ID
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []ksuid.ID
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_publishers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.PublisherOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOPublisherOrder2lybbriointernalentPublisherOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.PublisherWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_seriesSlice_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.SeriesOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOSeriesOrder2lybbriointernalentSeriesOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.SeriesWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_shelves_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.ShelfOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOShelfOrder2lybbriointernalentShelfOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ShelfWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_tags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.TagOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTagOrder2lybbriointernalentTagOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TagWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_tasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.TaskOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOTaskOrder2lybbriointernalentTaskOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.TaskWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Shelf_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Tag_books_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[ksuid.ID]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2entgoiocontribentgqlCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 []*ent.BookOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOBookOrder2lybbriointernalentBookOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.BookWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Author_id(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Author_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Author_name(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Author_sort(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_sort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_sort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Author_link(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Author_books(ctx context.Context, field graphql.CollectedField, obj *ent.Author) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Author_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Author_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Author",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Author_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _AuthorConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.AuthorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthorConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AuthorEdge)
	fc.Result = res
	return ec.marshalOAuthorEdge2lybbriointernalentAuthorEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthorConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_AuthorEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_AuthorEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthorEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthorConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.AuthorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthorConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthorConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthorConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.AuthorConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthorConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthorConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthorConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthorEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.AuthorEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthorEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Author)
	fc.Result = res
	return ec.marshalOAuthor2lybbriointernalentAuthor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthorEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Author_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Author_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Author_name(ctx, field)
			case "sort":
				return ec.fieldContext_Author_sort(ctx, field)
			case "link":
				return ec.fieldContext_Author_link(ctx, field)
			case "books":
				return ec.fieldContext_Author_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Author", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthorEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.AuthorEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthorEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthorEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthorEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_id(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_title(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_sort(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_sort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_sort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_publishedDate(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_publishedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublishedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_publishedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_path(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_isbn(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_isbn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Isbn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_isbn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_description(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_seriesIndex(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_seriesIndex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeriesIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_seriesIndex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_authors(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_authors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Authors(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Author)
	fc.Result = res
	return ec.marshalOAuthor2lybbriointernalentAuthor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_authors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Author_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Author_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Author_name(ctx, field)
			case "sort":
				return ec.fieldContext_Author_sort(ctx, field)
			case "link":
				return ec.fieldContext_Author_link(ctx, field)
			case "books":
				return ec.fieldContext_Author_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Author", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_publisher(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_publisher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Publisher(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Publisher)
	fc.Result = res
	return ec.marshalOPublisher2lybbriointernalentPublisher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_publisher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Publisher_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Publisher_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Publisher_name(ctx, field)
			case "books":
				return ec.fieldContext_Publisher_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Publisher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_series(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_series(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Series(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Series)
	fc.Result = res
	return ec.marshalOSeries2lybbriointernalentSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_series(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Series_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Series_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Series_name(ctx, field)
			case "sort":
				return ec.fieldContext_Series_sort(ctx, field)
			case "books":
				return ec.fieldContext_Series_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Series", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_identifiers(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_identifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifiers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Identifier)
	fc.Result = res
	return ec.marshalOIdentifier2lybbriointernalentIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_identifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identifier_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Identifier_calibreID(ctx, field)
			case "type":
				return ec.fieldContext_Identifier_type(ctx, field)
			case "value":
				return ec.fieldContext_Identifier_value(ctx, field)
			case "book":
				return ec.fieldContext_Identifier_book(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2lybbriointernalentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Tag_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "books":
				return ec.fieldContext_Tag_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_language(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2lybbriointernalentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Language_calibreID(ctx, field)
			case "code":
				return ec.fieldContext_Language_code(ctx, field)
			case "books":
				return ec.fieldContext_Language_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Book_shelf(ctx context.Context, field graphql.CollectedField, obj *ent.Book) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Book_shelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shelf(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Shelf)
	fc.Result = res
	return ec.marshalOShelf2lybbriointernalentShelf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Book_shelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Book",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shelf_id(ctx, field)
			case "public":
				return ec.fieldContext_Shelf_public(ctx, field)
			case "userID":
				return ec.fieldContext_Shelf_userID(ctx, field)
			case "name":
				return ec.fieldContext_Shelf_name(ctx, field)
			case "description":
				return ec.fieldContext_Shelf_description(ctx, field)
			case "user":
				return ec.fieldContext_Shelf_user(ctx, field)
			case "books":
				return ec.fieldContext_Shelf_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shelf", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.BookConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.BookEdge)
	fc.Result = res
	return ec.marshalOBookEdge2lybbriointernalentBookEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_BookEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_BookEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.BookConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.BookConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.BookEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Book)
	fc.Result = res
	return ec.marshalOBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.BookEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookFile_id(ctx context.Context, field graphql.CollectedField, obj *ent.BookFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookFile_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookFile_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookFile_path(ctx context.Context, field graphql.CollectedField, obj *ent.BookFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookFile_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookFile_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookFile_size(ctx context.Context, field graphql.CollectedField, obj *ent.BookFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookFile_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookFile_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookFile_format(ctx context.Context, field graphql.CollectedField, obj *ent.BookFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookFile_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bookfile.Format)
	fc.Result = res
	return ec.marshalNBookFileFormat2lybbriointernalentbookfileFormat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookFile_format(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BookFileFormat does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BookFile_book(ctx context.Context, field graphql.CollectedField, obj *ent.BookFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BookFile_book(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Book(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Book)
	fc.Result = res
	return ec.marshalNBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BookFile_book(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BookFile",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identifier_id(ctx context.Context, field graphql.CollectedField, obj *ent.Identifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identifier_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identifier_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identifier_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Identifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identifier_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identifier_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identifier_type(ctx context.Context, field graphql.CollectedField, obj *ent.Identifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identifier_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identifier_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identifier_value(ctx context.Context, field graphql.CollectedField, obj *ent.Identifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identifier_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identifier_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identifier_book(ctx context.Context, field graphql.CollectedField, obj *ent.Identifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identifier_book(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Book(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Book)
	fc.Result = res
	return ec.marshalNBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identifier_book(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identifier",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IdentifierConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.IdentifierConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IdentifierConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.IdentifierEdge)
	fc.Result = res
	return ec.marshalOIdentifierEdge2lybbriointernalentIdentifierEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IdentifierConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IdentifierConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_IdentifierEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_IdentifierEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IdentifierEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IdentifierConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.IdentifierConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IdentifierConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IdentifierConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IdentifierConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IdentifierConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.IdentifierConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IdentifierConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IdentifierConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IdentifierConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IdentifierEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.IdentifierEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IdentifierEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Identifier)
	fc.Result = res
	return ec.marshalOIdentifier2lybbriointernalentIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IdentifierEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IdentifierEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identifier_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Identifier_calibreID(ctx, field)
			case "type":
				return ec.fieldContext_Identifier_type(ctx, field)
			case "value":
				return ec.fieldContext_Identifier_value(ctx, field)
			case "book":
				return ec.fieldContext_Identifier_book(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IdentifierEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.IdentifierEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IdentifierEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IdentifierEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IdentifierEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_id(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_code(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Language_books(ctx context.Context, field graphql.CollectedField, obj *ent.Language) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Language_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Language_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Language",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Language_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _LanguageConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.LanguageEdge)
	fc.Result = res
	return ec.marshalOLanguageEdge2lybbriointernalentLanguageEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_LanguageEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_LanguageEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LanguageEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2lybbriointernalentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Language_calibreID(ctx, field)
			case "code":
				return ec.fieldContext_Language_code(ctx, field)
			case "books":
				return ec.fieldContext_Language_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LanguageEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.LanguageEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LanguageEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LanguageEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LanguageEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateBook(rctx, fc.Args["input"].(ent.CreateBookInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Book)
	fc.Result = res
	return ec.marshalOBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBook(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateBookInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Book)
	fc.Result = res
	return ec.marshalOBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBook_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAuthor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAuthor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAuthor(rctx, fc.Args["input"].(ent.CreateAuthorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Author)
	fc.Result = res
	return ec.marshalOAuthor2lybbriointernalentAuthor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAuthor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Author_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Author_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Author_name(ctx, field)
			case "sort":
				return ec.fieldContext_Author_sort(ctx, field)
			case "link":
				return ec.fieldContext_Author_link(ctx, field)
			case "books":
				return ec.fieldContext_Author_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Author", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAuthor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateAuthor(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateAuthor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateAuthor(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateAuthorInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Author)
	fc.Result = res
	return ec.marshalOAuthor2lybbriointernalentAuthor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateAuthor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Author_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Author_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Author_name(ctx, field)
			case "sort":
				return ec.fieldContext_Author_sort(ctx, field)
			case "link":
				return ec.fieldContext_Author_link(ctx, field)
			case "books":
				return ec.fieldContext_Author_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Author", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateAuthor_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createShelf(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createShelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateShelf(rctx, fc.Args["input"].(lybbrio.CreateShelfInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Shelf)
	fc.Result = res
	return ec.marshalOShelf2lybbriointernalentShelf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createShelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shelf_id(ctx, field)
			case "public":
				return ec.fieldContext_Shelf_public(ctx, field)
			case "userID":
				return ec.fieldContext_Shelf_userID(ctx, field)
			case "name":
				return ec.fieldContext_Shelf_name(ctx, field)
			case "description":
				return ec.fieldContext_Shelf_description(ctx, field)
			case "user":
				return ec.fieldContext_Shelf_user(ctx, field)
			case "books":
				return ec.fieldContext_Shelf_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shelf", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createShelf_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateShelf(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateShelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateShelf(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateShelfInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Shelf)
	fc.Result = res
	return ec.marshalOShelf2lybbriointernalentShelf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateShelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shelf_id(ctx, field)
			case "public":
				return ec.fieldContext_Shelf_public(ctx, field)
			case "userID":
				return ec.fieldContext_Shelf_userID(ctx, field)
			case "name":
				return ec.fieldContext_Shelf_name(ctx, field)
			case "description":
				return ec.fieldContext_Shelf_description(ctx, field)
			case "user":
				return ec.fieldContext_Shelf_user(ctx, field)
			case "books":
				return ec.fieldContext_Shelf_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shelf", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateShelf_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(ent.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2lybbriointernalentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Tag_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "books":
				return ec.fieldContext_Tag_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2lybbriointernalentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Tag_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "books":
				return ec.fieldContext_Tag_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPublisher(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPublisher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePublisher(rctx, fc.Args["input"].(ent.CreatePublisherInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Publisher)
	fc.Result = res
	return ec.marshalOPublisher2lybbriointernalentPublisher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPublisher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Publisher_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Publisher_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Publisher_name(ctx, field)
			case "books":
				return ec.fieldContext_Publisher_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Publisher", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPublisher_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePublisher(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePublisher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePublisher(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdatePublisherInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Publisher)
	fc.Result = res
	return ec.marshalOPublisher2lybbriointernalentPublisher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePublisher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Publisher_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Publisher_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Publisher_name(ctx, field)
			case "books":
				return ec.fieldContext_Publisher_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Publisher", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePublisher_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLanguage(rctx, fc.Args["input"].(ent.CreateLanguageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2lybbriointernalentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Language_calibreID(ctx, field)
			case "code":
				return ec.fieldContext_Language_code(ctx, field)
			case "books":
				return ec.fieldContext_Language_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLanguage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLanguage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLanguage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLanguage(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateLanguageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Language)
	fc.Result = res
	return ec.marshalOLanguage2lybbriointernalentLanguage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLanguage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Language_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Language_calibreID(ctx, field)
			case "code":
				return ec.fieldContext_Language_code(ctx, field)
			case "books":
				return ec.fieldContext_Language_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Language", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLanguage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createSeries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSeries(rctx, fc.Args["input"].(ent.CreateSeriesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Series)
	fc.Result = res
	return ec.marshalOSeries2lybbriointernalentSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Series_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Series_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Series_name(ctx, field)
			case "sort":
				return ec.fieldContext_Series_sort(ctx, field)
			case "books":
				return ec.fieldContext_Series_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Series", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createSeries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSeries(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSeries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSeries(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateSeriesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Series)
	fc.Result = res
	return ec.marshalOSeries2lybbriointernalentSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSeries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Series_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Series_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Series_name(ctx, field)
			case "sort":
				return ec.fieldContext_Series_sort(ctx, field)
			case "books":
				return ec.fieldContext_Series_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Series", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSeries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createIdentifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateIdentifier(rctx, fc.Args["input"].(ent.CreateIdentifierInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Identifier)
	fc.Result = res
	return ec.marshalOIdentifier2lybbriointernalentIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identifier_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Identifier_calibreID(ctx, field)
			case "type":
				return ec.fieldContext_Identifier_type(ctx, field)
			case "value":
				return ec.fieldContext_Identifier_value(ctx, field)
			case "book":
				return ec.fieldContext_Identifier_book(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identifier", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createIdentifier_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateIdentifier(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateIdentifier(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateIdentifierInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Identifier)
	fc.Result = res
	return ec.marshalOIdentifier2lybbriointernalentIdentifier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identifier_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Identifier_calibreID(ctx, field)
			case "type":
				return ec.fieldContext_Identifier_type(ctx, field)
			case "value":
				return ec.fieldContext_Identifier_value(ctx, field)
			case "book":
				return ec.fieldContext_Identifier_book(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identifier", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateIdentifier_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["input"].(ent.CreateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUser(rctx, fc.Args["id"].(ksuid.ID), fc.Args["input"].(ent.UpdateUserInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTask(rctx, fc.Args["input"].(lybbrio.CreateTaskInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Task)
	fc.Result = res
	return ec.marshalOTask2lybbriointernalentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "progress":
				return ec.fieldContext_Task_progress(ctx, field)
			case "message":
				return ec.fieldContext_Task_message(ctx, field)
			case "error":
				return ec.fieldContext_Task_error(ctx, field)
			case "userID":
				return ec.fieldContext_Task_userID(ctx, field)
			case "isSystemTask":
				return ec.fieldContext_Task_isSystemTask(ctx, field)
			case "user":
				return ec.fieldContext_Task_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[ksuid.ID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[ksuid.ID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[ksuid.ID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[ksuid.ID]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalOCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Publisher_id(ctx context.Context, field graphql.CollectedField, obj *ent.Publisher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Publisher_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Publisher_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Publisher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Publisher_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Publisher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Publisher_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Publisher_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Publisher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Publisher_name(ctx context.Context, field graphql.CollectedField, obj *ent.Publisher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Publisher_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Publisher_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Publisher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Publisher_books(ctx context.Context, field graphql.CollectedField, obj *ent.Publisher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Publisher_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Publisher_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Publisher",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Publisher_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _PublisherConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.PublisherConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublisherConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.PublisherEdge)
	fc.Result = res
	return ec.marshalOPublisherEdge2lybbriointernalentPublisherEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublisherConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublisherConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_PublisherEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_PublisherEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublisherEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublisherConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.PublisherConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublisherConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublisherConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublisherConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublisherConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.PublisherConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublisherConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublisherConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublisherConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublisherEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.PublisherEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublisherEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Publisher)
	fc.Result = res
	return ec.marshalOPublisher2lybbriointernalentPublisher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublisherEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublisherEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Publisher_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Publisher_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Publisher_name(ctx, field)
			case "books":
				return ec.fieldContext_Publisher_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Publisher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublisherEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.PublisherEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublisherEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublisherEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublisherEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(ksuid.ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2lybbriointernalentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]ksuid.ID))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2lybbriointernalentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_authors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_authors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Authors(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.AuthorOrder), fc.Args["where"].(*ent.AuthorWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AuthorConnection)
	fc.Result = res
	return ec.marshalNAuthorConnection2lybbriointernalentAuthorConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_authors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_AuthorConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AuthorConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_AuthorConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthorConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_authors_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_books(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Books(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bookFiles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bookFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BookFiles(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.BookFile)
	fc.Result = res
	return ec.marshalNBookFile2lybbriointernalentBookFile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bookFiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BookFile_id(ctx, field)
			case "path":
				return ec.fieldContext_BookFile_path(ctx, field)
			case "size":
				return ec.fieldContext_BookFile_size(ctx, field)
			case "format":
				return ec.fieldContext_BookFile_format(ctx, field)
			case "book":
				return ec.fieldContext_BookFile_book(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookFile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_identifiers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_identifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Identifiers(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.IdentifierOrder), fc.Args["where"].(*ent.IdentifierWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.IdentifierConnection)
	fc.Result = res
	return ec.marshalNIdentifierConnection2lybbriointernalentIdentifierConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_identifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_IdentifierConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_IdentifierConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_IdentifierConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IdentifierConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_identifiers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_languages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Languages(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.LanguageOrder), fc.Args["where"].(*ent.LanguageWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.LanguageConnection)
	fc.Result = res
	return ec.marshalNLanguageConnection2lybbriointernalentLanguageConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_languages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_LanguageConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_LanguageConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_LanguageConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LanguageConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_languages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_publishers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_publishers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Publishers(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.PublisherOrder), fc.Args["where"].(*ent.PublisherWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.PublisherConnection)
	fc.Result = res
	return ec.marshalNPublisherConnection2lybbriointernalentPublisherConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_publishers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_PublisherConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_PublisherConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_PublisherConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublisherConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_publishers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_seriesSlice(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_seriesSlice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SeriesSlice(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.SeriesOrder), fc.Args["where"].(*ent.SeriesWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SeriesConnection)
	fc.Result = res
	return ec.marshalNSeriesConnection2lybbriointernalentSeriesConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_seriesSlice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SeriesConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SeriesConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SeriesConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SeriesConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_seriesSlice_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_shelves(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_shelves(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Shelves(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.ShelfOrder), fc.Args["where"].(*ent.ShelfWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ShelfConnection)
	fc.Result = res
	return ec.marshalNShelfConnection2lybbriointernalentShelfConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_shelves(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ShelfConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ShelfConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ShelfConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ShelfConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_shelves_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tags(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.TagOrder), fc.Args["where"].(*ent.TagWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TagConnection)
	fc.Result = res
	return ec.marshalNTagConnection2lybbriointernalentTagConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TagConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TagConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TagConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tasks(rctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.TaskOrder), fc.Args["where"].(*ent.TaskWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.TaskConnection)
	fc.Result = res
	return ec.marshalNTaskConnection2lybbriointernalentTaskConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_TaskConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_TaskConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_TaskConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Series_id(ctx context.Context, field graphql.CollectedField, obj *ent.Series) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Series_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Series_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Series",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Series_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Series) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Series_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Series_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Series",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Series_name(ctx context.Context, field graphql.CollectedField, obj *ent.Series) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Series_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Series_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Series",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Series_sort(ctx context.Context, field graphql.CollectedField, obj *ent.Series) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Series_sort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Series_sort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Series",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Series_books(ctx context.Context, field graphql.CollectedField, obj *ent.Series) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Series_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Book)
	fc.Result = res
	return ec.marshalOBook2lybbriointernalentBook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Series_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Series",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Book_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Book_calibreID(ctx, field)
			case "title":
				return ec.fieldContext_Book_title(ctx, field)
			case "sort":
				return ec.fieldContext_Book_sort(ctx, field)
			case "publishedDate":
				return ec.fieldContext_Book_publishedDate(ctx, field)
			case "path":
				return ec.fieldContext_Book_path(ctx, field)
			case "isbn":
				return ec.fieldContext_Book_isbn(ctx, field)
			case "description":
				return ec.fieldContext_Book_description(ctx, field)
			case "seriesIndex":
				return ec.fieldContext_Book_seriesIndex(ctx, field)
			case "authors":
				return ec.fieldContext_Book_authors(ctx, field)
			case "publisher":
				return ec.fieldContext_Book_publisher(ctx, field)
			case "series":
				return ec.fieldContext_Book_series(ctx, field)
			case "identifiers":
				return ec.fieldContext_Book_identifiers(ctx, field)
			case "tags":
				return ec.fieldContext_Book_tags(ctx, field)
			case "language":
				return ec.fieldContext_Book_language(ctx, field)
			case "shelf":
				return ec.fieldContext_Book_shelf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Book", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeriesConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SeriesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeriesConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SeriesEdge)
	fc.Result = res
	return ec.marshalOSeriesEdge2lybbriointernalentSeriesEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeriesConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeriesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SeriesEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SeriesEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SeriesEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeriesConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SeriesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeriesConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeriesConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeriesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeriesConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SeriesConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeriesConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeriesConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeriesConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeriesEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SeriesEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeriesEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Series)
	fc.Result = res
	return ec.marshalOSeries2lybbriointernalentSeries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeriesEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeriesEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Series_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Series_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Series_name(ctx, field)
			case "sort":
				return ec.fieldContext_Series_sort(ctx, field)
			case "books":
				return ec.fieldContext_Series_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Series", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SeriesEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SeriesEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SeriesEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SeriesEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SeriesEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_id(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_public(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_public(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Public, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_public(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_userID(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_name(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_description(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_user(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalNUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shelf_books(ctx context.Context, field graphql.CollectedField, obj *ent.Shelf) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shelf_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shelf_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shelf",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Shelf_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ShelfConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ShelfConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShelfConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ShelfEdge)
	fc.Result = res
	return ec.marshalOShelfEdge2lybbriointernalentShelfEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShelfConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShelfConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ShelfEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ShelfEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ShelfEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShelfConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ShelfConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShelfConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShelfConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShelfConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShelfConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ShelfConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShelfConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShelfConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShelfConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShelfEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ShelfEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShelfEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Shelf)
	fc.Result = res
	return ec.marshalOShelf2lybbriointernalentShelf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShelfEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShelfEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shelf_id(ctx, field)
			case "public":
				return ec.fieldContext_Shelf_public(ctx, field)
			case "userID":
				return ec.fieldContext_Shelf_userID(ctx, field)
			case "name":
				return ec.fieldContext_Shelf_name(ctx, field)
			case "description":
				return ec.fieldContext_Shelf_description(ctx, field)
			case "user":
				return ec.fieldContext_Shelf_user(ctx, field)
			case "books":
				return ec.fieldContext_Shelf_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shelf", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ShelfEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ShelfEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ShelfEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ShelfEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ShelfEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_calibreID(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_calibreID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CalibreID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_calibreID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_books(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_books(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Books(ctx, fc.Args["after"].(*entgql.Cursor[ksuid.ID]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[ksuid.ID]), fc.Args["last"].(*int), fc.Args["orderBy"].([]*ent.BookOrder), fc.Args["where"].(*ent.BookWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BookConnection)
	fc.Result = res
	return ec.marshalNBookConnection2lybbriointernalentBookConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_books(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BookConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BookConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BookConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BookConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Tag_books_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _TagConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TagConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TagEdge)
	fc.Result = res
	return ec.marshalOTagEdge2lybbriointernalentTagEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TagEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TagEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TagConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TagConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TagEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2lybbriointernalentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "calibreID":
				return ec.fieldContext_Tag_calibreID(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "books":
				return ec.fieldContext_Tag_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TagEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createTime(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_updateTime(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_updateTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_updateTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_type(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(task_enums.TaskType)
	fc.Result = res
	return ec.marshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskTaskType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(task_enums.Status)
	fc.Result = res
	return ec.marshalNTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_progress(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Progress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_message(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_error(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_userID(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalOID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_isSystemTask(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_isSystemTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSystemTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_isSystemTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_user(ctx context.Context, field graphql.CollectedField, obj *ent.Task) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.TaskConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.TaskEdge)
	fc.Result = res
	return ec.marshalOTaskEdge2lybbriointernalentTaskEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_TaskEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_TaskEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.TaskConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[ksuid.ID])
	fc.Result = res
	return ec.marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.TaskConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.TaskEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Task)
	fc.Result = res
	return ec.marshalOTask2lybbriointernalentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "updateTime":
				return ec.fieldContext_Task_updateTime(ctx, field)
			case "type":
				return ec.fieldContext_Task_type(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "progress":
				return ec.fieldContext_Task_progress(ctx, field)
			case "message":
				return ec.fieldContext_Task_message(ctx, field)
			case "error":
				return ec.fieldContext_Task_error(ctx, field)
			case "userID":
				return ec.fieldContext_Task_userID(ctx, field)
			case "isSystemTask":
				return ec.fieldContext_Task_isSystemTask(ctx, field)
			case "user":
				return ec.fieldContext_Task_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.TaskEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[ksuid.ID])
	fc.Result = res
	return ec.marshalNCursor2entgoiocontribentgqlCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_username(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_shelves(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_shelves(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shelves(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Shelf)
	fc.Result = res
	return ec.marshalOShelf2lybbriointernalentShelf(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_shelves(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shelf_id(ctx, field)
			case "public":
				return ec.fieldContext_Shelf_public(ctx, field)
			case "userID":
				return ec.fieldContext_Shelf_userID(ctx, field)
			case "name":
				return ec.fieldContext_Shelf_name(ctx, field)
			case "description":
				return ec.fieldContext_Shelf_description(ctx, field)
			case "user":
				return ec.fieldContext_Shelf_user(ctx, field)
			case "books":
				return ec.fieldContext_Shelf_books(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shelf", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userPermissions(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserPermissions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.UserPermissions)
	fc.Result = res
	return ec.marshalNUserPermissions2lybbriointernalentUserPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserPermissions_id(ctx, field)
			case "userID":
				return ec.fieldContext_UserPermissions_userID(ctx, field)
			case "admin":
				return ec.fieldContext_UserPermissions_admin(ctx, field)
			case "cancreatepublic":
				return ec.fieldContext_UserPermissions_cancreatepublic(ctx, field)
			case "canedit":
				return ec.fieldContext_UserPermissions_canedit(ctx, field)
			case "user":
				return ec.fieldContext_UserPermissions_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserPermissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_id(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalNID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_userID(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_userID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ksuid.ID)
	fc.Result = res
	return ec.marshalOID2lybbriointernalentschemaksuidID(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_userID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_admin(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_admin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_admin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_cancreatepublic(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_cancreatepublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanCreatePublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_cancreatepublic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_canedit(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_canedit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanEdit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_canedit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserPermissions_user(ctx context.Context, field graphql.CollectedField, obj *ent.UserPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserPermissions_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.User)
	fc.Result = res
	return ec.marshalOUser2lybbriointernalentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserPermissions_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserPermissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "username":
				return ec.fieldContext_User_username(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "shelves":
				return ec.fieldContext_User_shelves(ctx, field)
			case "userPermissions":
				return ec.fieldContext_User_userPermissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAuthorOrder(ctx context.Context, obj interface{}) (ent.AuthorOrder, error) {
	var it ent.AuthorOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNAuthorOrderField2lybbriointernalentAuthorOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthorWhereInput(ctx context.Context, obj interface{}) (ent.AuthorWhereInput, error) {
	var it ent.AuthorWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "sort", "sortNEQ", "sortIn", "sortNotIn", "sortGT", "sortGTE", "sortLT", "sortLTE", "sortContains", "sortHasPrefix", "sortHasSuffix", "sortEqualFold", "sortContainsFold", "link", "linkNEQ", "linkIn", "linkNotIn", "linkGT", "linkGTE", "linkLT", "linkLTE", "linkContains", "linkHasPrefix", "linkHasSuffix", "linkIsNil", "linkNotNil", "linkEqualFold", "linkContainsFold", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "sortNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNEQ = data
		case "sortIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortIn = data
		case "sortNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNotIn = data
		case "sortGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGT = data
		case "sortGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGTE = data
		case "sortLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLT = data
		case "sortLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLTE = data
		case "sortContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContains = data
		case "sortHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasPrefix = data
		case "sortHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasSuffix = data
		case "sortEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortEqualFold = data
		case "sortContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContainsFold = data
		case "link":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		case "linkNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkNEQ = data
		case "linkIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkIn = data
		case "linkNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkNotIn = data
		case "linkGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkGT = data
		case "linkGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkGTE = data
		case "linkLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkLT = data
		case "linkLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkLTE = data
		case "linkContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkContains = data
		case "linkHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkHasPrefix = data
		case "linkHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkHasSuffix = data
		case "linkIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkIsNil = data
		case "linkNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkNotNil = data
		case "linkEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkEqualFold = data
		case "linkContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("linkContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LinkContainsFold = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBookFileWhereInput(ctx context.Context, obj interface{}) (ent.BookFileWhereInput, error) {
	var it ent.BookFileWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "path", "pathNEQ", "pathIn", "pathNotIn", "pathGT", "pathGTE", "pathLT", "pathLTE", "pathContains", "pathHasPrefix", "pathHasSuffix", "pathEqualFold", "pathContainsFold", "size", "sizeNEQ", "sizeIn", "sizeNotIn", "sizeGT", "sizeGTE", "sizeLT", "sizeLTE", "format", "formatNEQ", "formatIn", "formatNotIn", "hasBook", "hasBookWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "pathNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathNEQ = data
		case "pathIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathIn = data
		case "pathNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathNotIn = data
		case "pathGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathGT = data
		case "pathGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathGTE = data
		case "pathLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathLT = data
		case "pathLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathLTE = data
		case "pathContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathContains = data
		case "pathHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathHasPrefix = data
		case "pathHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathHasSuffix = data
		case "pathEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathEqualFold = data
		case "pathContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathContainsFold = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "sizeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeNEQ = data
		case "sizeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeIn = data
		case "sizeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeNotIn = data
		case "sizeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeGT = data
		case "sizeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeGTE = data
		case "sizeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeLT = data
		case "sizeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sizeLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SizeLTE = data
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "formatNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatNEQ"))
			data, err := ec.unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatNEQ = data
		case "formatIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatIn"))
			data, err := ec.unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatIn = data
		case "formatNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatNotIn"))
			data, err := ec.unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatNotIn = data
		case "hasBook":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBook"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBook = data
		case "hasBookWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBookWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBookWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBookOrder(ctx context.Context, obj interface{}) (ent.BookOrder, error) {
	var it ent.BookOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNBookOrderField2lybbriointernalentBookOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBookWhereInput(ctx context.Context, obj interface{}) (ent.BookWhereInput, error) {
	var it ent.BookWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleEqualFold", "titleContainsFold", "sort", "sortNEQ", "sortIn", "sortNotIn", "sortGT", "sortGTE", "sortLT", "sortLTE", "sortContains", "sortHasPrefix", "sortHasSuffix", "sortEqualFold", "sortContainsFold", "publishedDate", "publishedDateNEQ", "publishedDateIn", "publishedDateNotIn", "publishedDateGT", "publishedDateGTE", "publishedDateLT", "publishedDateLTE", "publishedDateIsNil", "publishedDateNotNil", "path", "pathNEQ", "pathIn", "pathNotIn", "pathGT", "pathGTE", "pathLT", "pathLTE", "pathContains", "pathHasPrefix", "pathHasSuffix", "pathEqualFold", "pathContainsFold", "isbn", "isbnNEQ", "isbnIn", "isbnNotIn", "isbnGT", "isbnGTE", "isbnLT", "isbnLTE", "isbnContains", "isbnHasPrefix", "isbnHasSuffix", "isbnIsNil", "isbnNotNil", "isbnEqualFold", "isbnContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "seriesIndex", "seriesIndexNEQ", "seriesIndexIn", "seriesIndexNotIn", "seriesIndexGT", "seriesIndexGTE", "seriesIndexLT", "seriesIndexLTE", "seriesIndexIsNil", "seriesIndexNotNil", "hasAuthors", "hasAuthorsWith", "hasPublisher", "hasPublisherWith", "hasSeries", "hasSeriesWith", "hasIdentifiers", "hasIdentifiersWith", "hasTags", "hasTagsWith", "hasLanguage", "hasLanguageWith", "hasShelf", "hasShelfWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "sortNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNEQ = data
		case "sortIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortIn = data
		case "sortNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNotIn = data
		case "sortGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGT = data
		case "sortGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGTE = data
		case "sortLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLT = data
		case "sortLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLTE = data
		case "sortContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContains = data
		case "sortHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasPrefix = data
		case "sortHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasSuffix = data
		case "sortEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortEqualFold = data
		case "sortContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContainsFold = data
		case "publishedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDate = data
		case "publishedDateNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateNEQ = data
		case "publishedDateIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateIn = data
		case "publishedDateNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateNotIn = data
		case "publishedDateGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateGT = data
		case "publishedDateGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateGTE = data
		case "publishedDateLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateLT = data
		case "publishedDateLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateLTE = data
		case "publishedDateIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateIsNil = data
		case "publishedDateNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDateNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDateNotNil = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "pathNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathNEQ = data
		case "pathIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathIn = data
		case "pathNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathNotIn = data
		case "pathGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathGT = data
		case "pathGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathGTE = data
		case "pathLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathLT = data
		case "pathLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathLTE = data
		case "pathContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathContains = data
		case "pathHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathHasPrefix = data
		case "pathHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathHasSuffix = data
		case "pathEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathEqualFold = data
		case "pathContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PathContainsFold = data
		case "isbn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Isbn = data
		case "isbnNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnNEQ = data
		case "isbnIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnIn = data
		case "isbnNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnNotIn = data
		case "isbnGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnGT = data
		case "isbnGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnGTE = data
		case "isbnLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnLT = data
		case "isbnLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnLTE = data
		case "isbnContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnContains = data
		case "isbnHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnHasPrefix = data
		case "isbnHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnHasSuffix = data
		case "isbnIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnIsNil = data
		case "isbnNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnNotNil = data
		case "isbnEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnEqualFold = data
		case "isbnContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbnContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsbnContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIsNil = data
		case "descriptionNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotNil = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "seriesIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndex"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndex = data
		case "seriesIndexNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexNEQ"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexNEQ = data
		case "seriesIndexIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexIn = data
		case "seriesIndexNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexNotIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexNotIn = data
		case "seriesIndexGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexGT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexGT = data
		case "seriesIndexGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexGTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexGTE = data
		case "seriesIndexLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexLT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexLT = data
		case "seriesIndexLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexLTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexLTE = data
		case "seriesIndexIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexIsNil = data
		case "seriesIndexNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndexNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndexNotNil = data
		case "hasAuthors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAuthors"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAuthors = data
		case "hasAuthorsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAuthorsWith"))
			data, err := ec.unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAuthorsWith = data
		case "hasPublisher":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPublisher"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPublisher = data
		case "hasPublisherWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasPublisherWith"))
			data, err := ec.unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasPublisherWith = data
		case "hasSeries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSeries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSeries = data
		case "hasSeriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasSeriesWith"))
			data, err := ec.unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasSeriesWith = data
		case "hasIdentifiers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIdentifiers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIdentifiers = data
		case "hasIdentifiersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIdentifiersWith"))
			data, err := ec.unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIdentifiersWith = data
		case "hasTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTags"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTags = data
		case "hasTagsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasTagsWith"))
			data, err := ec.unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasTagsWith = data
		case "hasLanguage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguage"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguage = data
		case "hasLanguageWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasLanguageWith"))
			data, err := ec.unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasLanguageWith = data
		case "hasShelf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasShelf"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasShelf = data
		case "hasShelfWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasShelfWith"))
			data, err := ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasShelfWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateAuthorInput(ctx context.Context, obj interface{}) (ent.CreateAuthorInput, error) {
	var it ent.CreateAuthorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "name", "sort", "link", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "link":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateBookInput(ctx context.Context, obj interface{}) (ent.CreateBookInput, error) {
	var it ent.CreateBookInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "title", "sort", "publishedDate", "path", "isbn", "description", "seriesIndex", "authorIDs", "publisherIDs", "seriesIDs", "identifierIDs", "tagIDs", "languageIDs", "shelfIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "publishedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDate = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "isbn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Isbn = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "seriesIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndex"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndex = data
		case "authorIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthorIDs = data
		case "publisherIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publisherIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublisherIDs = data
		case "seriesIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIDs = data
		case "identifierIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifierIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IdentifierIDs = data
		case "tagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagIDs = data
		case "languageIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("languageIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.LanguageIDs = data
		case "shelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShelfIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateIdentifierInput(ctx context.Context, obj interface{}) (ent.CreateIdentifierInput, error) {
	var it ent.CreateIdentifierInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "type", "value", "bookID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "bookID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookID"))
			data, err := ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLanguageInput(ctx context.Context, obj interface{}) (ent.CreateLanguageInput, error) {
	var it ent.CreateLanguageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "code", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreatePublisherInput(ctx context.Context, obj interface{}) (ent.CreatePublisherInput, error) {
	var it ent.CreatePublisherInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "name", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSeriesInput(ctx context.Context, obj interface{}) (ent.CreateSeriesInput, error) {
	var it ent.CreateSeriesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "name", "sort", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateShelfInput(ctx context.Context, obj interface{}) (lybbrio.CreateShelfInput, error) {
	var it lybbrio.CreateShelfInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "public", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "public":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Public = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj interface{}) (ent.CreateTagInput, error) {
	var it ent.CreateTagInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "name", "bookIDs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "bookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookIDs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTaskInput(ctx context.Context, obj interface{}) (lybbrio.CreateTaskInput, error) {
	var it lybbrio.CreateTaskInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUserInput(ctx context.Context, obj interface{}) (ent.CreateUserInput, error) {
	var it ent.CreateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "passwordHash", "email", "shelfIDs", "userPermissionsID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "passwordHash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordHash"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordHash = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "shelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShelfIDs = data
		case "userPermissionsID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userPermissionsID"))
			data, err := ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserPermissionsID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIdentifierOrder(ctx context.Context, obj interface{}) (ent.IdentifierOrder, error) {
	var it ent.IdentifierOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNIdentifierOrderField2lybbriointernalentIdentifierOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIdentifierWhereInput(ctx context.Context, obj interface{}) (ent.IdentifierWhereInput, error) {
	var it ent.IdentifierWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "type", "typeNEQ", "typeIn", "typeNotIn", "typeGT", "typeGTE", "typeLT", "typeLTE", "typeContains", "typeHasPrefix", "typeHasSuffix", "typeEqualFold", "typeContainsFold", "value", "valueNEQ", "valueIn", "valueNotIn", "valueGT", "valueGTE", "valueLT", "valueLTE", "valueContains", "valueHasPrefix", "valueHasSuffix", "valueEqualFold", "valueContainsFold", "hasBook", "hasBookWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "typeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeGT = data
		case "typeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeGTE = data
		case "typeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeLT = data
		case "typeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeLTE = data
		case "typeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeContains = data
		case "typeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeHasPrefix = data
		case "typeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeHasSuffix = data
		case "typeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeEqualFold = data
		case "typeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeContainsFold = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "valueNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueNEQ = data
		case "valueIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueIn = data
		case "valueNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueNotIn = data
		case "valueGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueGT = data
		case "valueGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueGTE = data
		case "valueLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueLT = data
		case "valueLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueLTE = data
		case "valueContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueContains = data
		case "valueHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueHasPrefix = data
		case "valueHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueHasSuffix = data
		case "valueEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueEqualFold = data
		case "valueContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("valueContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValueContainsFold = data
		case "hasBook":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBook"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBook = data
		case "hasBookWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBookWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBookWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageOrder(ctx context.Context, obj interface{}) (ent.LanguageOrder, error) {
	var it ent.LanguageOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNLanguageOrderField2lybbriointernalentLanguageOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLanguageWhereInput(ctx context.Context, obj interface{}) (ent.LanguageWhereInput, error) {
	var it ent.LanguageWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "code", "codeNEQ", "codeIn", "codeNotIn", "codeGT", "codeGTE", "codeLT", "codeLTE", "codeContains", "codeHasPrefix", "codeHasSuffix", "codeEqualFold", "codeContainsFold", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "codeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNEQ = data
		case "codeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeIn = data
		case "codeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeNotIn = data
		case "codeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGT = data
		case "codeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeGTE = data
		case "codeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLT = data
		case "codeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeLTE = data
		case "codeContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContains = data
		case "codeHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasPrefix = data
		case "codeHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeHasSuffix = data
		case "codeEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeEqualFold = data
		case "codeContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("codeContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CodeContainsFold = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublisherOrder(ctx context.Context, obj interface{}) (ent.PublisherOrder, error) {
	var it ent.PublisherOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNPublisherOrderField2lybbriointernalentPublisherOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublisherWhereInput(ctx context.Context, obj interface{}) (ent.PublisherWhereInput, error) {
	var it ent.PublisherWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSeriesOrder(ctx context.Context, obj interface{}) (ent.SeriesOrder, error) {
	var it ent.SeriesOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSeriesOrderField2lybbriointernalentSeriesOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSeriesWhereInput(ctx context.Context, obj interface{}) (ent.SeriesWhereInput, error) {
	var it ent.SeriesWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "sort", "sortNEQ", "sortIn", "sortNotIn", "sortGT", "sortGTE", "sortLT", "sortLTE", "sortContains", "sortHasPrefix", "sortHasSuffix", "sortEqualFold", "sortContainsFold", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "sortNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNEQ = data
		case "sortIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortIn = data
		case "sortNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortNotIn = data
		case "sortGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGT = data
		case "sortGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortGTE = data
		case "sortLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLT = data
		case "sortLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortLTE = data
		case "sortContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContains = data
		case "sortHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasPrefix = data
		case "sortHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortHasSuffix = data
		case "sortEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortEqualFold = data
		case "sortContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortContainsFold = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputShelfOrder(ctx context.Context, obj interface{}) (ent.ShelfOrder, error) {
	var it ent.ShelfOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNShelfOrderField2lybbriointernalentShelfOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputShelfWhereInput(ctx context.Context, obj interface{}) (ent.ShelfWhereInput, error) {
	var it ent.ShelfWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "public", "publicNEQ", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "userIDGT", "userIDGTE", "userIDLT", "userIDLTE", "userIDContains", "userIDHasPrefix", "userIDHasSuffix", "userIDEqualFold", "userIDContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "description", "descriptionNEQ", "descriptionIn", "descriptionNotIn", "descriptionGT", "descriptionGTE", "descriptionLT", "descriptionLTE", "descriptionContains", "descriptionHasPrefix", "descriptionHasSuffix", "descriptionIsNil", "descriptionNotNil", "descriptionEqualFold", "descriptionContainsFold", "hasUser", "hasUserWith", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "public":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Public = data
		case "publicNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicNEQ = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "userIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGT = data
		case "userIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGTE = data
		case "userIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLT = data
		case "userIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLTE = data
		case "userIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContains"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContains = data
		case "userIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasPrefix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasPrefix = data
		case "userIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasSuffix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasSuffix = data
		case "userIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDEqualFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDEqualFold = data
		case "userIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContainsFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "descriptionNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNEQ = data
		case "descriptionIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIn = data
		case "descriptionNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotIn = data
		case "descriptionGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGT = data
		case "descriptionGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionGTE = data
		case "descriptionLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLT = data
		case "descriptionLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionLTE = data
		case "descriptionContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContains = data
		case "descriptionHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasPrefix = data
		case "descriptionHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionHasSuffix = data
		case "descriptionIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionIsNil = data
		case "descriptionNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionNotNil = data
		case "descriptionEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionEqualFold = data
		case "descriptionContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DescriptionContainsFold = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagOrder(ctx context.Context, obj interface{}) (ent.TagOrder, error) {
	var it ent.TagOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTagOrderField2lybbriointernalentTagOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagWhereInput(ctx context.Context, obj interface{}) (ent.TagWhereInput, error) {
	var it ent.TagWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "calibreID", "calibreIDNEQ", "calibreIDIn", "calibreIDNotIn", "calibreIDGT", "calibreIDGTE", "calibreIDLT", "calibreIDLTE", "calibreIDIsNil", "calibreIDNotNil", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "hasBooks", "hasBooksWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "calibreIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNEQ"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNEQ = data
		case "calibreIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIn = data
		case "calibreIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotIn"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotIn = data
		case "calibreIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGT = data
		case "calibreIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDGTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDGTE = data
		case "calibreIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLT"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLT = data
		case "calibreIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDLTE"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDLTE = data
		case "calibreIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDIsNil = data
		case "calibreIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreIDNotNil = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "hasBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooks = data
		case "hasBooksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBooksWith"))
			data, err := ec.unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBooksWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskOrder(ctx context.Context, obj interface{}) (ent.TaskOrder, error) {
	var it ent.TaskOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNTaskOrderField2lybbriointernalentTaskOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskWhereInput(ctx context.Context, obj interface{}) (ent.TaskWhereInput, error) {
	var it ent.TaskWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "createTime", "createTimeNEQ", "createTimeIn", "createTimeNotIn", "createTimeGT", "createTimeGTE", "createTimeLT", "createTimeLTE", "updateTime", "updateTimeNEQ", "updateTimeIn", "updateTimeNotIn", "updateTimeGT", "updateTimeGTE", "updateTimeLT", "updateTimeLTE", "type", "typeNEQ", "typeIn", "typeNotIn", "status", "statusNEQ", "statusIn", "statusNotIn", "progress", "progressNEQ", "progressIn", "progressNotIn", "progressGT", "progressGTE", "progressLT", "progressLTE", "message", "messageNEQ", "messageIn", "messageNotIn", "messageGT", "messageGTE", "messageLT", "messageLTE", "messageContains", "messageHasPrefix", "messageHasSuffix", "messageIsNil", "messageNotNil", "messageEqualFold", "messageContainsFold", "error", "errorNEQ", "errorIn", "errorNotIn", "errorGT", "errorGTE", "errorLT", "errorLTE", "errorContains", "errorHasPrefix", "errorHasSuffix", "errorIsNil", "errorNotNil", "errorEqualFold", "errorContainsFold", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "userIDGT", "userIDGTE", "userIDLT", "userIDLTE", "userIDContains", "userIDHasPrefix", "userIDHasSuffix", "userIDIsNil", "userIDNotNil", "userIDEqualFold", "userIDContainsFold", "isSystemTask", "isSystemTaskNEQ", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "createTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTime = data
		case "createTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNEQ = data
		case "createTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeIn = data
		case "createTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeNotIn = data
		case "createTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGT = data
		case "createTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeGTE = data
		case "createTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLT = data
		case "createTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreateTimeLTE = data
		case "updateTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTime = data
		case "updateTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNEQ"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNEQ = data
		case "updateTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeIn = data
		case "updateTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeNotIn"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeNotIn = data
		case "updateTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGT = data
		case "updateTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeGTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeGTE = data
		case "updateTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLT"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLT = data
		case "updateTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateTimeLTE"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdateTimeLTE = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "statusNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNEQ"))
			data, err := ec.unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusNEQ = data
		case "statusIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusIn"))
			data, err := ec.unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusIn = data
		case "statusNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusNotIn"))
			data, err := ec.unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.StatusNotIn = data
		case "progress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progress"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Progress = data
		case "progressNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNEQ"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNEQ = data
		case "progressIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressIn = data
		case "progressNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressNotIn"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressNotIn = data
		case "progressGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGT = data
		case "progressGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressGTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressGTE = data
		case "progressLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLT"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLT = data
		case "progressLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("progressLTE"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProgressLTE = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "messageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageNEQ = data
		case "messageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageIn = data
		case "messageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageNotIn = data
		case "messageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageGT = data
		case "messageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageGTE = data
		case "messageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageLT = data
		case "messageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageLTE = data
		case "messageContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageContains = data
		case "messageHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageHasPrefix = data
		case "messageHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageHasSuffix = data
		case "messageIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageIsNil = data
		case "messageNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageNotNil = data
		case "messageEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageEqualFold = data
		case "messageContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messageContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MessageContainsFold = data
		case "error":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("error"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Error = data
		case "errorNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorNEQ = data
		case "errorIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorIn = data
		case "errorNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorNotIn = data
		case "errorGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorGT = data
		case "errorGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorGTE = data
		case "errorLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorLT = data
		case "errorLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorLTE = data
		case "errorContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorContains = data
		case "errorHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorHasPrefix = data
		case "errorHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorHasSuffix = data
		case "errorIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorIsNil = data
		case "errorNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorNotNil = data
		case "errorEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorEqualFold = data
		case "errorContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("errorContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ErrorContainsFold = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "userIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGT = data
		case "userIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGTE = data
		case "userIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLT = data
		case "userIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLTE = data
		case "userIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContains"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContains = data
		case "userIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasPrefix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasPrefix = data
		case "userIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasSuffix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasSuffix = data
		case "userIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIsNil = data
		case "userIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotNil = data
		case "userIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDEqualFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDEqualFold = data
		case "userIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContainsFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContainsFold = data
		case "isSystemTask":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSystemTask"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSystemTask = data
		case "isSystemTaskNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSystemTaskNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSystemTaskNEQ = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateAuthorInput(ctx context.Context, obj interface{}) (ent.UpdateAuthorInput, error) {
	var it ent.UpdateAuthorInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "name", "sort", "link", "clearLink", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "link":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Link = data
		case "clearLink":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLink"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearLink = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBookInput(ctx context.Context, obj interface{}) (ent.UpdateBookInput, error) {
	var it ent.UpdateBookInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "title", "sort", "publishedDate", "clearPublishedDate", "path", "isbn", "clearIsbn", "description", "clearDescription", "seriesIndex", "clearSeriesIndex", "addAuthorIDs", "removeAuthorIDs", "clearAuthors", "addPublisherIDs", "removePublisherIDs", "clearPublisher", "addSeriesIDs", "removeSeriesIDs", "clearSeries", "addIdentifierIDs", "removeIdentifierIDs", "clearIdentifiers", "addTagIDs", "removeTagIDs", "clearTags", "addLanguageIDs", "removeLanguageIDs", "clearLanguage", "addShelfIDs", "removeShelfIDs", "clearShelf"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "publishedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publishedDate"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublishedDate = data
		case "clearPublishedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPublishedDate"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearPublishedDate = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "isbn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isbn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Isbn = data
		case "clearIsbn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearIsbn"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearIsbn = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "seriesIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seriesIndex"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SeriesIndex = data
		case "clearSeriesIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSeriesIndex"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSeriesIndex = data
		case "addAuthorIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addAuthorIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddAuthorIDs = data
		case "removeAuthorIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeAuthorIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveAuthorIDs = data
		case "clearAuthors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearAuthors"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearAuthors = data
		case "addPublisherIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addPublisherIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddPublisherIDs = data
		case "removePublisherIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removePublisherIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemovePublisherIDs = data
		case "clearPublisher":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPublisher"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearPublisher = data
		case "addSeriesIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addSeriesIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddSeriesIDs = data
		case "removeSeriesIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeSeriesIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveSeriesIDs = data
		case "clearSeries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearSeries"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearSeries = data
		case "addIdentifierIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addIdentifierIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddIdentifierIDs = data
		case "removeIdentifierIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeIdentifierIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveIdentifierIDs = data
		case "clearIdentifiers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearIdentifiers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearIdentifiers = data
		case "addTagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addTagIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddTagIDs = data
		case "removeTagIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeTagIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveTagIDs = data
		case "clearTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearTags"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearTags = data
		case "addLanguageIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addLanguageIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddLanguageIDs = data
		case "removeLanguageIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeLanguageIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveLanguageIDs = data
		case "clearLanguage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearLanguage"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearLanguage = data
		case "addShelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addShelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddShelfIDs = data
		case "removeShelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeShelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveShelfIDs = data
		case "clearShelf":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearShelf"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearShelf = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateIdentifierInput(ctx context.Context, obj interface{}) (ent.UpdateIdentifierInput, error) {
	var it ent.UpdateIdentifierInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "type", "value", "bookID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		case "bookID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bookID"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.BookID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLanguageInput(ctx context.Context, obj interface{}) (ent.UpdateLanguageInput, error) {
	var it ent.UpdateLanguageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "code", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "code":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("code"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Code = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdatePublisherInput(ctx context.Context, obj interface{}) (ent.UpdatePublisherInput, error) {
	var it ent.UpdatePublisherInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "name", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSeriesInput(ctx context.Context, obj interface{}) (ent.UpdateSeriesInput, error) {
	var it ent.UpdateSeriesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "name", "sort", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateShelfInput(ctx context.Context, obj interface{}) (ent.UpdateShelfInput, error) {
	var it ent.UpdateShelfInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"public", "name", "description", "clearDescription", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "public":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("public"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Public = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "clearDescription":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearDescription"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearDescription = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj interface{}) (ent.UpdateTagInput, error) {
	var it ent.UpdateTagInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"calibreID", "clearCalibreID", "name", "addBookIDs", "removeBookIDs", "clearBooks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "calibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("calibreID"))
			data, err := ec.unmarshalOInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CalibreID = data
		case "clearCalibreID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearCalibreID"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearCalibreID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "addBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddBookIDs = data
		case "removeBookIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeBookIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveBookIDs = data
		case "clearBooks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearBooks"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearBooks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUserInput(ctx context.Context, obj interface{}) (ent.UpdateUserInput, error) {
	var it ent.UpdateUserInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "passwordHash", "clearPasswordHash", "email", "addShelfIDs", "removeShelfIDs", "clearShelves"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "passwordHash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordHash"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PasswordHash = data
		case "clearPasswordHash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearPasswordHash"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearPasswordHash = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "addShelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addShelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddShelfIDs = data
		case "removeShelfIDs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("removeShelfIDs"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemoveShelfIDs = data
		case "clearShelves":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clearShelves"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClearShelves = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserOrder(ctx context.Context, obj interface{}) (ent.UserOrder, error) {
	var it ent.UserOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNUserOrderField2lybbriointernalentUserOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserPermissionsWhereInput(ctx context.Context, obj interface{}) (ent.UserPermissionsWhereInput, error) {
	var it ent.UserPermissionsWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "userID", "userIDNEQ", "userIDIn", "userIDNotIn", "userIDGT", "userIDGTE", "userIDLT", "userIDLTE", "userIDContains", "userIDHasPrefix", "userIDHasSuffix", "userIDIsNil", "userIDNotNil", "userIDEqualFold", "userIDContainsFold", "admin", "adminNEQ", "cancreatepublic", "cancreatepublicNEQ", "canedit", "caneditNEQ", "hasUser", "hasUserWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "userID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserID = data
		case "userIDNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNEQ = data
		case "userIDIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIn = data
		case "userIDNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotIn = data
		case "userIDGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGT = data
		case "userIDGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDGTE = data
		case "userIDLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLT = data
		case "userIDLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDLTE = data
		case "userIDContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContains"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContains = data
		case "userIDHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasPrefix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasPrefix = data
		case "userIDHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDHasSuffix"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDHasSuffix = data
		case "userIDIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDIsNil = data
		case "userIDNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDNotNil = data
		case "userIDEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDEqualFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDEqualFold = data
		case "userIDContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userIDContainsFold"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserIDContainsFold = data
		case "admin":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admin"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admin = data
		case "adminNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminNEQ = data
		case "cancreatepublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancreatepublic"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanCreatePublic = data
		case "cancreatepublicNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancreatepublicNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanCreatePublicNEQ = data
		case "canedit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("canedit"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanEdit = data
		case "caneditNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caneditNEQ"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CanEditNEQ = data
		case "hasUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUser"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUser = data
		case "hasUserWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserWith"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserWhereInput(ctx context.Context, obj interface{}) (ent.UserWhereInput, error) {
	var it ent.UserWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "username", "usernameNEQ", "usernameIn", "usernameNotIn", "usernameGT", "usernameGTE", "usernameLT", "usernameLTE", "usernameContains", "usernameHasPrefix", "usernameHasSuffix", "usernameEqualFold", "usernameContainsFold", "email", "emailNEQ", "emailIn", "emailNotIn", "emailGT", "emailGTE", "emailLT", "emailLTE", "emailContains", "emailHasPrefix", "emailHasSuffix", "emailEqualFold", "emailContainsFold", "hasShelves", "hasShelvesWith", "hasUserPermissions", "hasUserPermissionsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2lybbriointernalentschemaksuidID(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "usernameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameNEQ = data
		case "usernameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameIn = data
		case "usernameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameNotIn = data
		case "usernameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameGT = data
		case "usernameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameGTE = data
		case "usernameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameLT = data
		case "usernameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameLTE = data
		case "usernameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameContains = data
		case "usernameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameHasPrefix = data
		case "usernameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameHasSuffix = data
		case "usernameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameEqualFold = data
		case "usernameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("usernameContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UsernameContainsFold = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "emailNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNEQ"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNEQ = data
		case "emailIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailIn = data
		case "emailNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotIn"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotIn = data
		case "emailGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGT = data
		case "emailGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailGTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailGTE = data
		case "emailLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLT"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLT = data
		case "emailLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailLTE"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailLTE = data
		case "emailContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContains"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContains = data
		case "emailHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasPrefix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasPrefix = data
		case "emailHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailHasSuffix"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailHasSuffix = data
		case "emailEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailEqualFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailEqualFold = data
		case "emailContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailContainsFold"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailContainsFold = data
		case "hasShelves":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasShelves"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasShelves = data
		case "hasShelvesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasShelvesWith"))
			data, err := ec.unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasShelvesWith = data
		case "hasUserPermissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserPermissions"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserPermissions = data
		case "hasUserPermissionsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUserPermissionsWith"))
			data, err := ec.unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUserPermissionsWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.Author:
		if obj == nil {
			return graphql.Null
		}
		return ec._Author(ctx, sel, obj)
	case *ent.Book:
		if obj == nil {
			return graphql.Null
		}
		return ec._Book(ctx, sel, obj)
	case *ent.BookFile:
		if obj == nil {
			return graphql.Null
		}
		return ec._BookFile(ctx, sel, obj)
	case *ent.Identifier:
		if obj == nil {
			return graphql.Null
		}
		return ec._Identifier(ctx, sel, obj)
	case *ent.Language:
		if obj == nil {
			return graphql.Null
		}
		return ec._Language(ctx, sel, obj)
	case *ent.Publisher:
		if obj == nil {
			return graphql.Null
		}
		return ec._Publisher(ctx, sel, obj)
	case *ent.Series:
		if obj == nil {
			return graphql.Null
		}
		return ec._Series(ctx, sel, obj)
	case *ent.Shelf:
		if obj == nil {
			return graphql.Null
		}
		return ec._Shelf(ctx, sel, obj)
	case *ent.Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	case *ent.Task:
		if obj == nil {
			return graphql.Null
		}
		return ec._Task(ctx, sel, obj)
	case *ent.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case *ent.UserPermissions:
		if obj == nil {
			return graphql.Null
		}
		return ec._UserPermissions(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var authorImplementors = []string{"Author", "Node"}

func (ec *executionContext) _Author(ctx context.Context, sel ast.SelectionSet, obj *ent.Author) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Author")
		case "id":
			out.Values[i] = ec._Author_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Author_calibreID(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Author_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sort":
			out.Values[i] = ec._Author_sort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "link":
			out.Values[i] = ec._Author_link(ctx, field, obj)
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Author_books(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authorConnectionImplementors = []string{"AuthorConnection"}

func (ec *executionContext) _AuthorConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.AuthorConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authorConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthorConnection")
		case "edges":
			out.Values[i] = ec._AuthorConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._AuthorConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._AuthorConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authorEdgeImplementors = []string{"AuthorEdge"}

func (ec *executionContext) _AuthorEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.AuthorEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authorEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthorEdge")
		case "node":
			out.Values[i] = ec._AuthorEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._AuthorEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bookImplementors = []string{"Book", "Node"}

func (ec *executionContext) _Book(ctx context.Context, sel ast.SelectionSet, obj *ent.Book) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Book")
		case "id":
			out.Values[i] = ec._Book_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Book_calibreID(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Book_title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sort":
			out.Values[i] = ec._Book_sort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "publishedDate":
			out.Values[i] = ec._Book_publishedDate(ctx, field, obj)
		case "path":
			out.Values[i] = ec._Book_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isbn":
			out.Values[i] = ec._Book_isbn(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Book_description(ctx, field, obj)
		case "seriesIndex":
			out.Values[i] = ec._Book_seriesIndex(ctx, field, obj)
		case "authors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_authors(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "publisher":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_publisher(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "series":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_series(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "identifiers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_identifiers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_tags(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "language":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_language(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "shelf":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Book_shelf(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bookConnectionImplementors = []string{"BookConnection"}

func (ec *executionContext) _BookConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.BookConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bookConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BookConnection")
		case "edges":
			out.Values[i] = ec._BookConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._BookConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._BookConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bookEdgeImplementors = []string{"BookEdge"}

func (ec *executionContext) _BookEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.BookEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bookEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BookEdge")
		case "node":
			out.Values[i] = ec._BookEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._BookEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bookFileImplementors = []string{"BookFile", "Node"}

func (ec *executionContext) _BookFile(ctx context.Context, sel ast.SelectionSet, obj *ent.BookFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bookFileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BookFile")
		case "id":
			out.Values[i] = ec._BookFile_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "path":
			out.Values[i] = ec._BookFile_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._BookFile_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "format":
			out.Values[i] = ec._BookFile_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "book":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BookFile_book(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var identifierImplementors = []string{"Identifier", "Node"}

func (ec *executionContext) _Identifier(ctx context.Context, sel ast.SelectionSet, obj *ent.Identifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, identifierImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Identifier")
		case "id":
			out.Values[i] = ec._Identifier_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Identifier_calibreID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Identifier_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "value":
			out.Values[i] = ec._Identifier_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "book":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identifier_book(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var identifierConnectionImplementors = []string{"IdentifierConnection"}

func (ec *executionContext) _IdentifierConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.IdentifierConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, identifierConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IdentifierConnection")
		case "edges":
			out.Values[i] = ec._IdentifierConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._IdentifierConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._IdentifierConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var identifierEdgeImplementors = []string{"IdentifierEdge"}

func (ec *executionContext) _IdentifierEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.IdentifierEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, identifierEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IdentifierEdge")
		case "node":
			out.Values[i] = ec._IdentifierEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._IdentifierEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var languageImplementors = []string{"Language", "Node"}

func (ec *executionContext) _Language(ctx context.Context, sel ast.SelectionSet, obj *ent.Language) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Language")
		case "id":
			out.Values[i] = ec._Language_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Language_calibreID(ctx, field, obj)
		case "code":
			out.Values[i] = ec._Language_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Language_books(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var languageConnectionImplementors = []string{"LanguageConnection"}

func (ec *executionContext) _LanguageConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.LanguageConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LanguageConnection")
		case "edges":
			out.Values[i] = ec._LanguageConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._LanguageConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._LanguageConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var languageEdgeImplementors = []string{"LanguageEdge"}

func (ec *executionContext) _LanguageEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.LanguageEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, languageEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LanguageEdge")
		case "node":
			out.Values[i] = ec._LanguageEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._LanguageEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createBook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBook(ctx, field)
			})
		case "updateBook":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBook(ctx, field)
			})
		case "createAuthor":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAuthor(ctx, field)
			})
		case "updateAuthor":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateAuthor(ctx, field)
			})
		case "createShelf":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createShelf(ctx, field)
			})
		case "updateShelf":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateShelf(ctx, field)
			})
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
		case "createPublisher":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPublisher(ctx, field)
			})
		case "updatePublisher":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePublisher(ctx, field)
			})
		case "createLanguage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLanguage(ctx, field)
			})
		case "updateLanguage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLanguage(ctx, field)
			})
		case "createSeries":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createSeries(ctx, field)
			})
		case "updateSeries":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSeries(ctx, field)
			})
		case "createIdentifier":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createIdentifier(ctx, field)
			})
		case "updateIdentifier":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateIdentifier(ctx, field)
			})
		case "createUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})
		case "updateUser":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUser(ctx, field)
			})
		case "createTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTask(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[ksuid.ID]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publisherImplementors = []string{"Publisher", "Node"}

func (ec *executionContext) _Publisher(ctx context.Context, sel ast.SelectionSet, obj *ent.Publisher) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publisherImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Publisher")
		case "id":
			out.Values[i] = ec._Publisher_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Publisher_calibreID(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Publisher_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Publisher_books(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publisherConnectionImplementors = []string{"PublisherConnection"}

func (ec *executionContext) _PublisherConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.PublisherConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publisherConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublisherConnection")
		case "edges":
			out.Values[i] = ec._PublisherConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._PublisherConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._PublisherConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publisherEdgeImplementors = []string{"PublisherEdge"}

func (ec *executionContext) _PublisherEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.PublisherEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publisherEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublisherEdge")
		case "node":
			out.Values[i] = ec._PublisherEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._PublisherEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "authors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_authors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_books(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bookFiles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bookFiles(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "identifiers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_identifiers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "languages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_languages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "publishers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_publishers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "seriesSlice":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_seriesSlice(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "shelves":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_shelves(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tasks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "users":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "me":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var seriesImplementors = []string{"Series", "Node"}

func (ec *executionContext) _Series(ctx context.Context, sel ast.SelectionSet, obj *ent.Series) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Series")
		case "id":
			out.Values[i] = ec._Series_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Series_calibreID(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Series_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sort":
			out.Values[i] = ec._Series_sort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Series_books(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var seriesConnectionImplementors = []string{"SeriesConnection"}

func (ec *executionContext) _SeriesConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SeriesConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seriesConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SeriesConnection")
		case "edges":
			out.Values[i] = ec._SeriesConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._SeriesConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._SeriesConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var seriesEdgeImplementors = []string{"SeriesEdge"}

func (ec *executionContext) _SeriesEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SeriesEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, seriesEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SeriesEdge")
		case "node":
			out.Values[i] = ec._SeriesEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._SeriesEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var shelfImplementors = []string{"Shelf", "Node"}

func (ec *executionContext) _Shelf(ctx context.Context, sel ast.SelectionSet, obj *ent.Shelf) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shelfImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Shelf")
		case "id":
			out.Values[i] = ec._Shelf_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "public":
			out.Values[i] = ec._Shelf_public(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._Shelf_userID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Shelf_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "description":
			out.Values[i] = ec._Shelf_description(ctx, field, obj)
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Shelf_user(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Shelf_books(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var shelfConnectionImplementors = []string{"ShelfConnection"}

func (ec *executionContext) _ShelfConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ShelfConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shelfConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ShelfConnection")
		case "edges":
			out.Values[i] = ec._ShelfConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._ShelfConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ShelfConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var shelfEdgeImplementors = []string{"ShelfEdge"}

func (ec *executionContext) _ShelfEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ShelfEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shelfEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ShelfEdge")
		case "node":
			out.Values[i] = ec._ShelfEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._ShelfEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagImplementors = []string{"Tag", "Node"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *ent.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			out.Values[i] = ec._Tag_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "calibreID":
			out.Values[i] = ec._Tag_calibreID(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Tag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "books":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_books(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagConnectionImplementors = []string{"TagConnection"}

func (ec *executionContext) _TagConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TagConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagConnection")
		case "edges":
			out.Values[i] = ec._TagConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TagConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TagConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var tagEdgeImplementors = []string{"TagEdge"}

func (ec *executionContext) _TagEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TagEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagEdge")
		case "node":
			out.Values[i] = ec._TagEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TagEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task", "Node"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *ent.Task) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createTime":
			out.Values[i] = ec._Task_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updateTime":
			out.Values[i] = ec._Task_updateTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Task_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Task_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "progress":
			out.Values[i] = ec._Task_progress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "message":
			out.Values[i] = ec._Task_message(ctx, field, obj)
		case "error":
			out.Values[i] = ec._Task_error(ctx, field, obj)
		case "userID":
			out.Values[i] = ec._Task_userID(ctx, field, obj)
		case "isSystemTask":
			out.Values[i] = ec._Task_isSystemTask(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskConnectionImplementors = []string{"TaskConnection"}

func (ec *executionContext) _TaskConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.TaskConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskConnection")
		case "edges":
			out.Values[i] = ec._TaskConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._TaskConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._TaskConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEdgeImplementors = []string{"TaskEdge"}

func (ec *executionContext) _TaskEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.TaskEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEdge")
		case "node":
			out.Values[i] = ec._TaskEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._TaskEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User", "Node"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			out.Values[i] = ec._User_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "username":
			out.Values[i] = ec._User_username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "email":
			out.Values[i] = ec._User_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shelves":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_shelves(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_userPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userPermissionsImplementors = []string{"UserPermissions", "Node"}

func (ec *executionContext) _UserPermissions(ctx context.Context, sel ast.SelectionSet, obj *ent.UserPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserPermissions")
		case "id":
			out.Values[i] = ec._UserPermissions_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userID":
			out.Values[i] = ec._UserPermissions_userID(ctx, field, obj)
		case "admin":
			out.Values[i] = ec._UserPermissions_admin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cancreatepublic":
			out.Values[i] = ec._UserPermissions_cancreatepublic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "canedit":
			out.Values[i] = ec._UserPermissions_canedit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._UserPermissions_user(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAuthor2lybbriointernalentAuthor(ctx context.Context, sel ast.SelectionSet, v *ent.Author) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Author(ctx, sel, v)
}

func (ec *executionContext) marshalNAuthorConnection2lybbriointernalentAuthorConnection(ctx context.Context, sel ast.SelectionSet, v ent.AuthorConnection) graphql.Marshaler {
	return ec._AuthorConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthorConnection2lybbriointernalentAuthorConnection(ctx context.Context, sel ast.SelectionSet, v *ent.AuthorConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthorConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAuthorOrder2lybbriointernalentAuthorOrder(ctx context.Context, v interface{}) (*ent.AuthorOrder, error) {
	res, err := ec.unmarshalInputAuthorOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAuthorOrderField2lybbriointernalentAuthorOrderField(ctx context.Context, v interface{}) (*ent.AuthorOrderField, error) {
	var res = new(ent.AuthorOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAuthorOrderField2lybbriointernalentAuthorOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.AuthorOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx context.Context, v interface{}) (*ent.AuthorWhereInput, error) {
	res, err := ec.unmarshalInputAuthorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBook2lybbriointernalentBook(ctx context.Context, sel ast.SelectionSet, v *ent.Book) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Book(ctx, sel, v)
}

func (ec *executionContext) marshalNBookConnection2lybbriointernalentBookConnection(ctx context.Context, sel ast.SelectionSet, v ent.BookConnection) graphql.Marshaler {
	return ec._BookConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBookConnection2lybbriointernalentBookConnection(ctx context.Context, sel ast.SelectionSet, v *ent.BookConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BookConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNBookFile2lybbriointernalentBookFile(ctx context.Context, sel ast.SelectionSet, v []*ent.BookFile) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBookFile2lybbriointernalentBookFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBookFile2lybbriointernalentBookFile(ctx context.Context, sel ast.SelectionSet, v *ent.BookFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BookFile(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, v interface{}) (bookfile.Format, error) {
	var res bookfile.Format
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, sel ast.SelectionSet, v bookfile.Format) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx context.Context, v interface{}) (*ent.BookFileWhereInput, error) {
	res, err := ec.unmarshalInputBookFileWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBookOrder2lybbriointernalentBookOrder(ctx context.Context, v interface{}) (*ent.BookOrder, error) {
	res, err := ec.unmarshalInputBookOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBookOrderField2lybbriointernalentBookOrderField(ctx context.Context, v interface{}) (*ent.BookOrderField, error) {
	var res = new(ent.BookOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBookOrderField2lybbriointernalentBookOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.BookOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNBookWhereInput2lybbriointernalentBookWhereInput(ctx context.Context, v interface{}) (*ent.BookWhereInput, error) {
	res, err := ec.unmarshalInputBookWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCreateAuthorInput2lybbriointernalentCreateAuthorInput(ctx context.Context, v interface{}) (ent.CreateAuthorInput, error) {
	res, err := ec.unmarshalInputCreateAuthorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateBookInput2lybbriointernalentCreateBookInput(ctx context.Context, v interface{}) (ent.CreateBookInput, error) {
	res, err := ec.unmarshalInputCreateBookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateIdentifierInput2lybbriointernalentCreateIdentifierInput(ctx context.Context, v interface{}) (ent.CreateIdentifierInput, error) {
	res, err := ec.unmarshalInputCreateIdentifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateLanguageInput2lybbriointernalentCreateLanguageInput(ctx context.Context, v interface{}) (ent.CreateLanguageInput, error) {
	res, err := ec.unmarshalInputCreateLanguageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreatePublisherInput2lybbriointernalentCreatePublisherInput(ctx context.Context, v interface{}) (ent.CreatePublisherInput, error) {
	res, err := ec.unmarshalInputCreatePublisherInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateSeriesInput2lybbriointernalentCreateSeriesInput(ctx context.Context, v interface{}) (ent.CreateSeriesInput, error) {
	res, err := ec.unmarshalInputCreateSeriesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateShelfInput2lybbrioCreateShelfInput(ctx context.Context, v interface{}) (lybbrio.CreateShelfInput, error) {
	res, err := ec.unmarshalInputCreateShelfInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTagInput2lybbriointernalentCreateTagInput(ctx context.Context, v interface{}) (ent.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateTaskInput2lybbrioCreateTaskInput(ctx context.Context, v interface{}) (lybbrio.CreateTaskInput, error) {
	res, err := ec.unmarshalInputCreateTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUserInput2lybbriointernalentCreateUserInput(ctx context.Context, v interface{}) (ent.CreateUserInput, error) {
	res, err := ec.unmarshalInputCreateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (entgql.Cursor[ksuid.ID], error) {
	var res entgql.Cursor[ksuid.ID]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[ksuid.ID]) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2lybbriointernalentschemaksuidID(ctx context.Context, v interface{}) (ksuid.ID, error) {
	var res ksuid.ID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2lybbriointernalentschemaksuidID(ctx context.Context, sel ast.SelectionSet, v ksuid.ID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNID2lybbriointernalentschemaksuidID(ctx context.Context, v interface{}) ([]ksuid.ID, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]ksuid.ID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2lybbriointernalentschemaksuidID(ctx context.Context, sel ast.SelectionSet, v []ksuid.ID) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2lybbriointernalentschemaksuidID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNIdentifier2lybbriointernalentIdentifier(ctx context.Context, sel ast.SelectionSet, v *ent.Identifier) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Identifier(ctx, sel, v)
}

func (ec *executionContext) marshalNIdentifierConnection2lybbriointernalentIdentifierConnection(ctx context.Context, sel ast.SelectionSet, v ent.IdentifierConnection) graphql.Marshaler {
	return ec._IdentifierConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNIdentifierConnection2lybbriointernalentIdentifierConnection(ctx context.Context, sel ast.SelectionSet, v *ent.IdentifierConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._IdentifierConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNIdentifierOrder2lybbriointernalentIdentifierOrder(ctx context.Context, v interface{}) (*ent.IdentifierOrder, error) {
	res, err := ec.unmarshalInputIdentifierOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNIdentifierOrderField2lybbriointernalentIdentifierOrderField(ctx context.Context, v interface{}) (*ent.IdentifierOrderField, error) {
	var res = new(ent.IdentifierOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNIdentifierOrderField2lybbriointernalentIdentifierOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.IdentifierOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx context.Context, v interface{}) (*ent.IdentifierWhereInput, error) {
	res, err := ec.unmarshalInputIdentifierWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLanguage2lybbriointernalentLanguage(ctx context.Context, sel ast.SelectionSet, v *ent.Language) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Language(ctx, sel, v)
}

func (ec *executionContext) marshalNLanguageConnection2lybbriointernalentLanguageConnection(ctx context.Context, sel ast.SelectionSet, v ent.LanguageConnection) graphql.Marshaler {
	return ec._LanguageConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNLanguageConnection2lybbriointernalentLanguageConnection(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LanguageConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLanguageOrder2lybbriointernalentLanguageOrder(ctx context.Context, v interface{}) (*ent.LanguageOrder, error) {
	res, err := ec.unmarshalInputLanguageOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNLanguageOrderField2lybbriointernalentLanguageOrderField(ctx context.Context, v interface{}) (*ent.LanguageOrderField, error) {
	var res = new(ent.LanguageOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLanguageOrderField2lybbriointernalentLanguageOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2lybbriointernalentNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2lybbriointernalentNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoiocontribentgqlOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoiocontribentgqlPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[ksuid.ID]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPublisher2lybbriointernalentPublisher(ctx context.Context, sel ast.SelectionSet, v *ent.Publisher) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Publisher(ctx, sel, v)
}

func (ec *executionContext) marshalNPublisherConnection2lybbriointernalentPublisherConnection(ctx context.Context, sel ast.SelectionSet, v ent.PublisherConnection) graphql.Marshaler {
	return ec._PublisherConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNPublisherConnection2lybbriointernalentPublisherConnection(ctx context.Context, sel ast.SelectionSet, v *ent.PublisherConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublisherConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublisherOrder2lybbriointernalentPublisherOrder(ctx context.Context, v interface{}) (*ent.PublisherOrder, error) {
	res, err := ec.unmarshalInputPublisherOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPublisherOrderField2lybbriointernalentPublisherOrderField(ctx context.Context, v interface{}) (*ent.PublisherOrderField, error) {
	var res = new(ent.PublisherOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPublisherOrderField2lybbriointernalentPublisherOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.PublisherOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx context.Context, v interface{}) (*ent.PublisherWhereInput, error) {
	res, err := ec.unmarshalInputPublisherWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeries2lybbriointernalentSeries(ctx context.Context, sel ast.SelectionSet, v *ent.Series) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Series(ctx, sel, v)
}

func (ec *executionContext) marshalNSeriesConnection2lybbriointernalentSeriesConnection(ctx context.Context, sel ast.SelectionSet, v ent.SeriesConnection) graphql.Marshaler {
	return ec._SeriesConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSeriesConnection2lybbriointernalentSeriesConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SeriesConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SeriesConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSeriesOrder2lybbriointernalentSeriesOrder(ctx context.Context, v interface{}) (*ent.SeriesOrder, error) {
	res, err := ec.unmarshalInputSeriesOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSeriesOrderField2lybbriointernalentSeriesOrderField(ctx context.Context, v interface{}) (*ent.SeriesOrderField, error) {
	var res = new(ent.SeriesOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeriesOrderField2lybbriointernalentSeriesOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SeriesOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx context.Context, v interface{}) (*ent.SeriesWhereInput, error) {
	res, err := ec.unmarshalInputSeriesWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNShelf2lybbriointernalentShelf(ctx context.Context, sel ast.SelectionSet, v *ent.Shelf) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Shelf(ctx, sel, v)
}

func (ec *executionContext) marshalNShelfConnection2lybbriointernalentShelfConnection(ctx context.Context, sel ast.SelectionSet, v ent.ShelfConnection) graphql.Marshaler {
	return ec._ShelfConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNShelfConnection2lybbriointernalentShelfConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ShelfConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ShelfConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNShelfOrder2lybbriointernalentShelfOrder(ctx context.Context, v interface{}) (*ent.ShelfOrder, error) {
	res, err := ec.unmarshalInputShelfOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNShelfOrderField2lybbriointernalentShelfOrderField(ctx context.Context, v interface{}) (*ent.ShelfOrderField, error) {
	var res = new(ent.ShelfOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNShelfOrderField2lybbriointernalentShelfOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ShelfOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNShelfWhereInput2lybbriointernalentShelfWhereInput(ctx context.Context, v interface{}) (*ent.ShelfWhereInput, error) {
	res, err := ec.unmarshalInputShelfWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTag2lybbriointernalentTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTagConnection2lybbriointernalentTagConnection(ctx context.Context, sel ast.SelectionSet, v ent.TagConnection) graphql.Marshaler {
	return ec._TagConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTagConnection2lybbriointernalentTagConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TagConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagOrder2lybbriointernalentTagOrder(ctx context.Context, v interface{}) (*ent.TagOrder, error) {
	res, err := ec.unmarshalInputTagOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagOrderField2lybbriointernalentTagOrderField(ctx context.Context, v interface{}) (*ent.TagOrderField, error) {
	var res = new(ent.TagOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagOrderField2lybbriointernalentTagOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TagOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTagWhereInput2lybbriointernalentTagWhereInput(ctx context.Context, v interface{}) (*ent.TagWhereInput, error) {
	res, err := ec.unmarshalInputTagWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskConnection2lybbriointernalentTaskConnection(ctx context.Context, sel ast.SelectionSet, v ent.TaskConnection) graphql.Marshaler {
	return ec._TaskConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskConnection2lybbriointernalentTaskConnection(ctx context.Context, sel ast.SelectionSet, v *ent.TaskConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskOrder2lybbriointernalentTaskOrder(ctx context.Context, v interface{}) (*ent.TaskOrder, error) {
	res, err := ec.unmarshalInputTaskOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTaskOrderField2lybbriointernalentTaskOrderField(ctx context.Context, v interface{}) (*ent.TaskOrderField, error) {
	var res = new(ent.TaskOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskOrderField2lybbriointernalentTaskOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.TaskOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, v interface{}) (task_enums.Status, error) {
	var res task_enums.Status
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, sel ast.SelectionSet, v task_enums.Status) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, v interface{}) (task_enums.TaskType, error) {
	var res task_enums.TaskType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, sel ast.SelectionSet, v task_enums.TaskType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskWhereInput2lybbriointernalentTaskWhereInput(ctx context.Context, v interface{}) (*ent.TaskWhereInput, error) {
	res, err := ec.unmarshalInputTaskWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUpdateAuthorInput2lybbriointernalentUpdateAuthorInput(ctx context.Context, v interface{}) (ent.UpdateAuthorInput, error) {
	res, err := ec.unmarshalInputUpdateAuthorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateBookInput2lybbriointernalentUpdateBookInput(ctx context.Context, v interface{}) (ent.UpdateBookInput, error) {
	res, err := ec.unmarshalInputUpdateBookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateIdentifierInput2lybbriointernalentUpdateIdentifierInput(ctx context.Context, v interface{}) (ent.UpdateIdentifierInput, error) {
	res, err := ec.unmarshalInputUpdateIdentifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateLanguageInput2lybbriointernalentUpdateLanguageInput(ctx context.Context, v interface{}) (ent.UpdateLanguageInput, error) {
	res, err := ec.unmarshalInputUpdateLanguageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdatePublisherInput2lybbriointernalentUpdatePublisherInput(ctx context.Context, v interface{}) (ent.UpdatePublisherInput, error) {
	res, err := ec.unmarshalInputUpdatePublisherInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSeriesInput2lybbriointernalentUpdateSeriesInput(ctx context.Context, v interface{}) (ent.UpdateSeriesInput, error) {
	res, err := ec.unmarshalInputUpdateSeriesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateShelfInput2lybbriointernalentUpdateShelfInput(ctx context.Context, v interface{}) (ent.UpdateShelfInput, error) {
	res, err := ec.unmarshalInputUpdateShelfInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTagInput2lybbriointernalentUpdateTagInput(ctx context.Context, v interface{}) (ent.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUserInput2lybbriointernalentUpdateUserInput(ctx context.Context, v interface{}) (ent.UpdateUserInput, error) {
	res, err := ec.unmarshalInputUpdateUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2lybbriointernalentUser(ctx context.Context, sel ast.SelectionSet, v ent.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2lybbriointernalentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2lybbriointernalentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2lybbriointernalentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserOrderField2lybbriointernalentUserOrderField(ctx context.Context, v interface{}) (*ent.UserOrderField, error) {
	var res = new(ent.UserOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserOrderField2lybbriointernalentUserOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.UserOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNUserPermissions2lybbriointernalentUserPermissions(ctx context.Context, sel ast.SelectionSet, v *ent.UserPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx context.Context, v interface{}) (*ent.UserPermissionsWhereInput, error) {
	res, err := ec.unmarshalInputUserPermissionsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserWhereInput2lybbriointernalentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAuthor2lybbriointernalentAuthor(ctx context.Context, sel ast.SelectionSet, v []*ent.Author) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuthor2lybbriointernalentAuthor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOAuthor2lybbriointernalentAuthor(ctx context.Context, sel ast.SelectionSet, v *ent.Author) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Author(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthorEdge2lybbriointernalentAuthorEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.AuthorEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAuthorEdge2lybbriointernalentAuthorEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAuthorEdge2lybbriointernalentAuthorEdge(ctx context.Context, sel ast.SelectionSet, v *ent.AuthorEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthorEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthorOrder2lybbriointernalentAuthorOrder(ctx context.Context, v interface{}) ([]*ent.AuthorOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AuthorOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAuthorOrder2lybbriointernalentAuthorOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx context.Context, v interface{}) ([]*ent.AuthorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.AuthorWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOAuthorWhereInput2lybbriointernalentAuthorWhereInput(ctx context.Context, v interface{}) (*ent.AuthorWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthorWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBook2lybbriointernalentBook(ctx context.Context, sel ast.SelectionSet, v []*ent.Book) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBook2lybbriointernalentBook(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOBook2lybbriointernalentBook(ctx context.Context, sel ast.SelectionSet, v *ent.Book) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Book(ctx, sel, v)
}

func (ec *executionContext) marshalOBookEdge2lybbriointernalentBookEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.BookEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBookEdge2lybbriointernalentBookEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBookEdge2lybbriointernalentBookEdge(ctx context.Context, sel ast.SelectionSet, v *ent.BookEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BookEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, v interface{}) ([]bookfile.Format, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]bookfile.Format, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBookFileFormat2lybbriointernalentbookfileFormat(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, sel ast.SelectionSet, v []bookfile.Format) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBookFileFormat2lybbriointernalentbookfileFormat(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, v interface{}) (*bookfile.Format, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(bookfile.Format)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBookFileFormat2lybbriointernalentbookfileFormat(ctx context.Context, sel ast.SelectionSet, v *bookfile.Format) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx context.Context, v interface{}) ([]*ent.BookFileWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.BookFileWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBookFileWhereInput2lybbriointernalentBookFileWhereInput(ctx context.Context, v interface{}) (*ent.BookFileWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBookFileWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBookOrder2lybbriointernalentBookOrder(ctx context.Context, v interface{}) ([]*ent.BookOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.BookOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBookOrder2lybbriointernalentBookOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx context.Context, v interface{}) ([]*ent.BookWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.BookWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBookWhereInput2lybbriointernalentBookWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBookWhereInput2lybbriointernalentBookWhereInput(ctx context.Context, v interface{}) (*ent.BookWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBookWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, v interface{}) (*entgql.Cursor[ksuid.ID], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[ksuid.ID])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2entgoiocontribentgqlCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[ksuid.ID]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) ([]float64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]float64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFloat2float64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v []float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNFloat2float64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2lybbriointernalentschemaksuidID(ctx context.Context, v interface{}) (ksuid.ID, error) {
	var res ksuid.ID
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2lybbriointernalentschemaksuidID(ctx context.Context, sel ast.SelectionSet, v ksuid.ID) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOID2lybbriointernalentschemaksuidID(ctx context.Context, v interface{}) ([]ksuid.ID, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]ksuid.ID, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2lybbriointernalentschemaksuidID(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2lybbriointernalentschemaksuidID(ctx context.Context, sel ast.SelectionSet, v []ksuid.ID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2lybbriointernalentschemaksuidID(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOID2lybbriointernalentschemaksuidID(ctx context.Context, v interface{}) (*ksuid.ID, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ksuid.ID)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2lybbriointernalentschemaksuidID(ctx context.Context, sel ast.SelectionSet, v *ksuid.ID) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOIdentifier2lybbriointernalentIdentifier(ctx context.Context, sel ast.SelectionSet, v []*ent.Identifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIdentifier2lybbriointernalentIdentifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOIdentifier2lybbriointernalentIdentifier(ctx context.Context, sel ast.SelectionSet, v *ent.Identifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Identifier(ctx, sel, v)
}

func (ec *executionContext) marshalOIdentifierEdge2lybbriointernalentIdentifierEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.IdentifierEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIdentifierEdge2lybbriointernalentIdentifierEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOIdentifierEdge2lybbriointernalentIdentifierEdge(ctx context.Context, sel ast.SelectionSet, v *ent.IdentifierEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IdentifierEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOIdentifierOrder2lybbriointernalentIdentifierOrder(ctx context.Context, v interface{}) ([]*ent.IdentifierOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.IdentifierOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNIdentifierOrder2lybbriointernalentIdentifierOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx context.Context, v interface{}) ([]*ent.IdentifierWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.IdentifierWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOIdentifierWhereInput2lybbriointernalentIdentifierWhereInput(ctx context.Context, v interface{}) (*ent.IdentifierWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputIdentifierWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) ([]int64, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int64, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int64(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v []int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int64(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (*int64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt64(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v *int64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt64(*v)
	return res
}

func (ec *executionContext) marshalOLanguage2lybbriointernalentLanguage(ctx context.Context, sel ast.SelectionSet, v []*ent.Language) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLanguage2lybbriointernalentLanguage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLanguage2lybbriointernalentLanguage(ctx context.Context, sel ast.SelectionSet, v *ent.Language) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Language(ctx, sel, v)
}

func (ec *executionContext) marshalOLanguageEdge2lybbriointernalentLanguageEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.LanguageEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLanguageEdge2lybbriointernalentLanguageEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLanguageEdge2lybbriointernalentLanguageEdge(ctx context.Context, sel ast.SelectionSet, v *ent.LanguageEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LanguageEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLanguageOrder2lybbriointernalentLanguageOrder(ctx context.Context, v interface{}) ([]*ent.LanguageOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LanguageOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageOrder2lybbriointernalentLanguageOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx context.Context, v interface{}) ([]*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.LanguageWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOLanguageWhereInput2lybbriointernalentLanguageWhereInput(ctx context.Context, v interface{}) (*ent.LanguageWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLanguageWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2lybbriointernalentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOPublisher2lybbriointernalentPublisher(ctx context.Context, sel ast.SelectionSet, v []*ent.Publisher) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublisher2lybbriointernalentPublisher(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPublisher2lybbriointernalentPublisher(ctx context.Context, sel ast.SelectionSet, v *ent.Publisher) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Publisher(ctx, sel, v)
}

func (ec *executionContext) marshalOPublisherEdge2lybbriointernalentPublisherEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.PublisherEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPublisherEdge2lybbriointernalentPublisherEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPublisherEdge2lybbriointernalentPublisherEdge(ctx context.Context, sel ast.SelectionSet, v *ent.PublisherEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PublisherEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPublisherOrder2lybbriointernalentPublisherOrder(ctx context.Context, v interface{}) ([]*ent.PublisherOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PublisherOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPublisherOrder2lybbriointernalentPublisherOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx context.Context, v interface{}) ([]*ent.PublisherWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.PublisherWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPublisherWhereInput2lybbriointernalentPublisherWhereInput(ctx context.Context, v interface{}) (*ent.PublisherWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPublisherWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeries2lybbriointernalentSeries(ctx context.Context, sel ast.SelectionSet, v []*ent.Series) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSeries2lybbriointernalentSeries(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOSeries2lybbriointernalentSeries(ctx context.Context, sel ast.SelectionSet, v *ent.Series) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Series(ctx, sel, v)
}

func (ec *executionContext) marshalOSeriesEdge2lybbriointernalentSeriesEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SeriesEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSeriesEdge2lybbriointernalentSeriesEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSeriesEdge2lybbriointernalentSeriesEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SeriesEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SeriesEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSeriesOrder2lybbriointernalentSeriesOrder(ctx context.Context, v interface{}) ([]*ent.SeriesOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SeriesOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSeriesOrder2lybbriointernalentSeriesOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx context.Context, v interface{}) ([]*ent.SeriesWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SeriesWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSeriesWhereInput2lybbriointernalentSeriesWhereInput(ctx context.Context, v interface{}) (*ent.SeriesWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSeriesWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOShelf2lybbriointernalentShelf(ctx context.Context, sel ast.SelectionSet, v []*ent.Shelf) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNShelf2lybbriointernalentShelf(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOShelf2lybbriointernalentShelf(ctx context.Context, sel ast.SelectionSet, v *ent.Shelf) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Shelf(ctx, sel, v)
}

func (ec *executionContext) marshalOShelfEdge2lybbriointernalentShelfEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ShelfEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOShelfEdge2lybbriointernalentShelfEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOShelfEdge2lybbriointernalentShelfEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ShelfEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ShelfEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOShelfOrder2lybbriointernalentShelfOrder(ctx context.Context, v interface{}) ([]*ent.ShelfOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ShelfOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNShelfOrder2lybbriointernalentShelfOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx context.Context, v interface{}) ([]*ent.ShelfWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ShelfWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNShelfWhereInput2lybbriointernalentShelfWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOShelfWhereInput2lybbriointernalentShelfWhereInput(ctx context.Context, v interface{}) (*ent.ShelfWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputShelfWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2lybbriointernalentTag(ctx context.Context, sel ast.SelectionSet, v []*ent.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2lybbriointernalentTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTag2lybbriointernalentTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOTagEdge2lybbriointernalentTagEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TagEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTagEdge2lybbriointernalentTagEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTagEdge2lybbriointernalentTagEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TagEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TagEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTagOrder2lybbriointernalentTagOrder(ctx context.Context, v interface{}) ([]*ent.TagOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TagOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagOrder2lybbriointernalentTagOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx context.Context, v interface{}) ([]*ent.TagWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TagWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagWhereInput2lybbriointernalentTagWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTagWhereInput2lybbriointernalentTagWhereInput(ctx context.Context, v interface{}) (*ent.TagWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTask2lybbriointernalentTask(ctx context.Context, sel ast.SelectionSet, v *ent.Task) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskEdge2lybbriointernalentTaskEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.TaskEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTaskEdge2lybbriointernalentTaskEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTaskEdge2lybbriointernalentTaskEdge(ctx context.Context, sel ast.SelectionSet, v *ent.TaskEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskOrder2lybbriointernalentTaskOrder(ctx context.Context, v interface{}) ([]*ent.TaskOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TaskOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskOrder2lybbriointernalentTaskOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, v interface{}) ([]task_enums.Status, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]task_enums.Status, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, sel ast.SelectionSet, v []task_enums.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskStatus2lybbriointernalentschematask_enumsStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, v interface{}) (*task_enums.Status, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(task_enums.Status)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskStatus2lybbriointernalentschematask_enumsStatus(ctx context.Context, sel ast.SelectionSet, v *task_enums.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, v interface{}) ([]task_enums.TaskType, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]task_enums.TaskType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, sel ast.SelectionSet, v []task_enums.TaskType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, v interface{}) (*task_enums.TaskType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(task_enums.TaskType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskTaskType2lybbriointernalentschematask_enumsTaskType(ctx context.Context, sel ast.SelectionSet, v *task_enums.TaskType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx context.Context, v interface{}) ([]*ent.TaskWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.TaskWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskWhereInput2lybbriointernalentTaskWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTaskWhereInput2lybbriointernalentTaskWhereInput(ctx context.Context, v interface{}) (*ent.TaskWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOUser2lybbriointernalentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx context.Context, v interface{}) ([]*ent.UserPermissionsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserPermissionsWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserPermissionsWhereInput2lybbriointernalentUserPermissionsWhereInput(ctx context.Context, v interface{}) (*ent.UserPermissionsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserPermissionsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx context.Context, v interface{}) ([]*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.UserWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserWhereInput2lybbriointernalentUserWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOUserWhereInput2lybbriointernalentUserWhereInput(ctx context.Context, v interface{}) (*ent.UserWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
