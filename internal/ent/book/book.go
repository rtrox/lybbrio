// Code generated by ent, DO NOT EDIT.

package book

import (
	"lybbrio/internal/ent/schema/ksuid"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the book type in the database.
	Label = "book"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// FieldUpdateTime holds the string denoting the update_time field in the database.
	FieldUpdateTime = "update_time"
	// FieldCalibreID holds the string denoting the calibre_id field in the database.
	FieldCalibreID = "calibre_id"
	// FieldTitle holds the string denoting the title field in the database.
	FieldTitle = "title"
	// FieldSort holds the string denoting the sort field in the database.
	FieldSort = "sort"
	// FieldPublishedDate holds the string denoting the published_date field in the database.
	FieldPublishedDate = "published_date"
	// FieldPath holds the string denoting the path field in the database.
	FieldPath = "path"
	// FieldIsbn holds the string denoting the isbn field in the database.
	FieldIsbn = "isbn"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldSeriesIndex holds the string denoting the series_index field in the database.
	FieldSeriesIndex = "series_index"
	// EdgeAuthors holds the string denoting the authors edge name in mutations.
	EdgeAuthors = "authors"
	// EdgePublisher holds the string denoting the publisher edge name in mutations.
	EdgePublisher = "publisher"
	// EdgeSeries holds the string denoting the series edge name in mutations.
	EdgeSeries = "series"
	// EdgeIdentifiers holds the string denoting the identifiers edge name in mutations.
	EdgeIdentifiers = "identifiers"
	// EdgeTags holds the string denoting the tags edge name in mutations.
	EdgeTags = "tags"
	// EdgeLanguage holds the string denoting the language edge name in mutations.
	EdgeLanguage = "language"
	// EdgeShelf holds the string denoting the shelf edge name in mutations.
	EdgeShelf = "shelf"
	// EdgeFiles holds the string denoting the files edge name in mutations.
	EdgeFiles = "files"
	// Table holds the table name of the book in the database.
	Table = "books"
	// AuthorsTable is the table that holds the authors relation/edge. The primary key declared below.
	AuthorsTable = "author_books"
	// AuthorsInverseTable is the table name for the Author entity.
	// It exists in this package in order to avoid circular dependency with the "author" package.
	AuthorsInverseTable = "authors"
	// PublisherTable is the table that holds the publisher relation/edge. The primary key declared below.
	PublisherTable = "publisher_books"
	// PublisherInverseTable is the table name for the Publisher entity.
	// It exists in this package in order to avoid circular dependency with the "publisher" package.
	PublisherInverseTable = "publishers"
	// SeriesTable is the table that holds the series relation/edge. The primary key declared below.
	SeriesTable = "series_books"
	// SeriesInverseTable is the table name for the Series entity.
	// It exists in this package in order to avoid circular dependency with the "series" package.
	SeriesInverseTable = "series"
	// IdentifiersTable is the table that holds the identifiers relation/edge.
	IdentifiersTable = "identifiers"
	// IdentifiersInverseTable is the table name for the Identifier entity.
	// It exists in this package in order to avoid circular dependency with the "identifier" package.
	IdentifiersInverseTable = "identifiers"
	// IdentifiersColumn is the table column denoting the identifiers relation/edge.
	IdentifiersColumn = "identifier_book"
	// TagsTable is the table that holds the tags relation/edge. The primary key declared below.
	TagsTable = "tag_books"
	// TagsInverseTable is the table name for the Tag entity.
	// It exists in this package in order to avoid circular dependency with the "tag" package.
	TagsInverseTable = "tags"
	// LanguageTable is the table that holds the language relation/edge. The primary key declared below.
	LanguageTable = "language_books"
	// LanguageInverseTable is the table name for the Language entity.
	// It exists in this package in order to avoid circular dependency with the "language" package.
	LanguageInverseTable = "languages"
	// ShelfTable is the table that holds the shelf relation/edge. The primary key declared below.
	ShelfTable = "shelf_books"
	// ShelfInverseTable is the table name for the Shelf entity.
	// It exists in this package in order to avoid circular dependency with the "shelf" package.
	ShelfInverseTable = "shelves"
	// FilesTable is the table that holds the files relation/edge.
	FilesTable = "book_files"
	// FilesInverseTable is the table name for the BookFile entity.
	// It exists in this package in order to avoid circular dependency with the "bookfile" package.
	FilesInverseTable = "book_files"
	// FilesColumn is the table column denoting the files relation/edge.
	FilesColumn = "book_file_book"
)

// Columns holds all SQL columns for book fields.
var Columns = []string{
	FieldID,
	FieldCreateTime,
	FieldUpdateTime,
	FieldCalibreID,
	FieldTitle,
	FieldSort,
	FieldPublishedDate,
	FieldPath,
	FieldIsbn,
	FieldDescription,
	FieldSeriesIndex,
}

var (
	// AuthorsPrimaryKey and AuthorsColumn2 are the table columns denoting the
	// primary key for the authors relation (M2M).
	AuthorsPrimaryKey = []string{"author_id", "book_id"}
	// PublisherPrimaryKey and PublisherColumn2 are the table columns denoting the
	// primary key for the publisher relation (M2M).
	PublisherPrimaryKey = []string{"publisher_id", "book_id"}
	// SeriesPrimaryKey and SeriesColumn2 are the table columns denoting the
	// primary key for the series relation (M2M).
	SeriesPrimaryKey = []string{"series_id", "book_id"}
	// TagsPrimaryKey and TagsColumn2 are the table columns denoting the
	// primary key for the tags relation (M2M).
	TagsPrimaryKey = []string{"tag_id", "book_id"}
	// LanguagePrimaryKey and LanguageColumn2 are the table columns denoting the
	// primary key for the language relation (M2M).
	LanguagePrimaryKey = []string{"language_id", "book_id"}
	// ShelfPrimaryKey and ShelfColumn2 are the table columns denoting the
	// primary key for the shelf relation (M2M).
	ShelfPrimaryKey = []string{"shelf_id", "book_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "lybbrio/internal/ent/runtime"
var (
	Hooks  [1]ent.Hook
	Policy ent.Policy
	// DefaultCreateTime holds the default value on creation for the "create_time" field.
	DefaultCreateTime func() time.Time
	// DefaultUpdateTime holds the default value on creation for the "update_time" field.
	DefaultUpdateTime func() time.Time
	// UpdateDefaultUpdateTime holds the default value on update for the "update_time" field.
	UpdateDefaultUpdateTime func() time.Time
	// TitleValidator is a validator for the "title" field. It is called by the builders before save.
	TitleValidator func(string) error
	// PathValidator is a validator for the "path" field. It is called by the builders before save.
	PathValidator func(string) error
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() ksuid.ID
)

// OrderOption defines the ordering options for the Book queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreateTime orders the results by the create_time field.
func ByCreateTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreateTime, opts...).ToFunc()
}

// ByUpdateTime orders the results by the update_time field.
func ByUpdateTime(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdateTime, opts...).ToFunc()
}

// ByCalibreID orders the results by the calibre_id field.
func ByCalibreID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCalibreID, opts...).ToFunc()
}

// ByTitle orders the results by the title field.
func ByTitle(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTitle, opts...).ToFunc()
}

// BySort orders the results by the sort field.
func BySort(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSort, opts...).ToFunc()
}

// ByPublishedDate orders the results by the published_date field.
func ByPublishedDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPublishedDate, opts...).ToFunc()
}

// ByPath orders the results by the path field.
func ByPath(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPath, opts...).ToFunc()
}

// ByIsbn orders the results by the isbn field.
func ByIsbn(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIsbn, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// BySeriesIndex orders the results by the series_index field.
func BySeriesIndex(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSeriesIndex, opts...).ToFunc()
}

// ByAuthorsCount orders the results by authors count.
func ByAuthorsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAuthorsStep(), opts...)
	}
}

// ByAuthors orders the results by authors terms.
func ByAuthors(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAuthorsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPublisherCount orders the results by publisher count.
func ByPublisherCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPublisherStep(), opts...)
	}
}

// ByPublisher orders the results by publisher terms.
func ByPublisher(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPublisherStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySeriesCount orders the results by series count.
func BySeriesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSeriesStep(), opts...)
	}
}

// BySeries orders the results by series terms.
func BySeries(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSeriesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByIdentifiersCount orders the results by identifiers count.
func ByIdentifiersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newIdentifiersStep(), opts...)
	}
}

// ByIdentifiers orders the results by identifiers terms.
func ByIdentifiers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newIdentifiersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByTagsCount orders the results by tags count.
func ByTagsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newTagsStep(), opts...)
	}
}

// ByTags orders the results by tags terms.
func ByTags(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTagsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByLanguageCount orders the results by language count.
func ByLanguageCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newLanguageStep(), opts...)
	}
}

// ByLanguage orders the results by language terms.
func ByLanguage(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newLanguageStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByShelfCount orders the results by shelf count.
func ByShelfCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newShelfStep(), opts...)
	}
}

// ByShelf orders the results by shelf terms.
func ByShelf(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newShelfStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFilesCount orders the results by files count.
func ByFilesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newFilesStep(), opts...)
	}
}

// ByFiles orders the results by files terms.
func ByFiles(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFilesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newAuthorsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AuthorsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, AuthorsTable, AuthorsPrimaryKey...),
	)
}
func newPublisherStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PublisherInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, PublisherTable, PublisherPrimaryKey...),
	)
}
func newSeriesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SeriesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, SeriesTable, SeriesPrimaryKey...),
	)
}
func newIdentifiersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(IdentifiersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, IdentifiersTable, IdentifiersColumn),
	)
}
func newTagsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TagsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, TagsTable, TagsPrimaryKey...),
	)
}
func newLanguageStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(LanguageInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, LanguageTable, LanguagePrimaryKey...),
	)
}
func newShelfStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ShelfInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, ShelfTable, ShelfPrimaryKey...),
	)
}
func newFilesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FilesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, FilesTable, FilesColumn),
	)
}
