// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"lybbrio/internal/ent/author"
	"lybbrio/internal/ent/book"
	"lybbrio/internal/ent/bookfile"
	"lybbrio/internal/ent/identifier"
	"lybbrio/internal/ent/language"
	"lybbrio/internal/ent/publisher"
	"lybbrio/internal/ent/schema/ksuid"
	"lybbrio/internal/ent/series"
	"lybbrio/internal/ent/shelf"
	"lybbrio/internal/ent/tag"
	"lybbrio/internal/ent/task"
	"lybbrio/internal/ent/user"
	"lybbrio/internal/ent/userpermissions"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[ksuid.ID]
	PageInfo       = entgql.PageInfo[ksuid.ID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AuthorEdge is the edge representation of Author.
type AuthorEdge struct {
	Node   *Author `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// AuthorConnection is the connection containing edges to Author.
type AuthorConnection struct {
	Edges      []*AuthorEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *AuthorConnection) build(nodes []*Author, pager *authorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Author
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Author {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Author {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthorPaginateOption enables pagination customization.
type AuthorPaginateOption func(*authorPager) error

// WithAuthorOrder configures pagination ordering.
func WithAuthorOrder(order []*AuthorOrder) AuthorPaginateOption {
	return func(pager *authorPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithAuthorFilter configures pagination filter.
func WithAuthorFilter(filter func(*AuthorQuery) (*AuthorQuery, error)) AuthorPaginateOption {
	return func(pager *authorPager) error {
		if filter == nil {
			return errors.New("AuthorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authorPager struct {
	reverse bool
	order   []*AuthorOrder
	filter  func(*AuthorQuery) (*AuthorQuery, error)
}

func newAuthorPager(opts []AuthorPaginateOption, reverse bool) (*authorPager, error) {
	pager := &authorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *authorPager) applyFilter(query *AuthorQuery) (*AuthorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authorPager) toCursor(a *Author) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(a).Value)
	}
	return Cursor{ID: a.ID, Value: cs}
}

func (p *authorPager) applyCursors(query *AuthorQuery, after, before *Cursor) (*AuthorQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultAuthorOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *authorPager) applyOrder(query *AuthorQuery) *AuthorQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultAuthorOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case AuthorOrderFieldBooksCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultAuthorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *authorPager) orderExpr(query *AuthorQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case AuthorOrderFieldBooksCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultAuthorOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Author.
func (a *AuthorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthorPaginateOption,
) (*AuthorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AuthorConnection{Edges: []*AuthorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuthorOrderFieldSort orders Author by sort.
	AuthorOrderFieldSort = &AuthorOrderField{
		Value: func(a *Author) (ent.Value, error) {
			return a.Sort, nil
		},
		column: author.FieldSort,
		toTerm: author.BySort,
		toCursor: func(a *Author) Cursor {
			return Cursor{
				ID:    a.ID,
				Value: a.Sort,
			}
		},
	}
	// AuthorOrderFieldBooksCount orders by BOOKS_COUNT.
	AuthorOrderFieldBooksCount = &AuthorOrderField{
		Value: func(a *Author) (ent.Value, error) {
			return a.Value("books_count")
		},
		column: "books_count",
		toTerm: func(opts ...sql.OrderTermOption) author.OrderOption {
			return author.ByBooksCount(
				append(opts, sql.OrderSelectAs("books_count"))...,
			)
		},
		toCursor: func(a *Author) Cursor {
			cv, _ := a.Value("books_count")
			return Cursor{
				ID:    a.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuthorOrderField) String() string {
	var str string
	switch f.column {
	case AuthorOrderFieldSort.column:
		str = "NAME"
	case AuthorOrderFieldBooksCount.column:
		str = "BOOKS_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuthorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuthorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuthorOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *AuthorOrderFieldSort
	case "BOOKS_COUNT":
		*f = *AuthorOrderFieldBooksCount
	default:
		return fmt.Errorf("%s is not a valid AuthorOrderField", str)
	}
	return nil
}

// AuthorOrderField defines the ordering field of Author.
type AuthorOrderField struct {
	// Value extracts the ordering value from the given Author.
	Value    func(*Author) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) author.OrderOption
	toCursor func(*Author) Cursor
}

// AuthorOrder defines the ordering of Author.
type AuthorOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *AuthorOrderField `json:"field"`
}

// DefaultAuthorOrder is the default ordering of Author.
var DefaultAuthorOrder = &AuthorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuthorOrderField{
		Value: func(a *Author) (ent.Value, error) {
			return a.ID, nil
		},
		column: author.FieldID,
		toTerm: author.ByID,
		toCursor: func(a *Author) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Author into AuthorEdge.
func (a *Author) ToEdge(order *AuthorOrder) *AuthorEdge {
	if order == nil {
		order = DefaultAuthorOrder
	}
	return &AuthorEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// BookEdge is the edge representation of Book.
type BookEdge struct {
	Node   *Book  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BookConnection is the connection containing edges to Book.
type BookConnection struct {
	Edges      []*BookEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *BookConnection) build(nodes []*Book, pager *bookPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Book
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Book {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Book {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookPaginateOption enables pagination customization.
type BookPaginateOption func(*bookPager) error

// WithBookOrder configures pagination ordering.
func WithBookOrder(order []*BookOrder) BookPaginateOption {
	return func(pager *bookPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithBookFilter configures pagination filter.
func WithBookFilter(filter func(*BookQuery) (*BookQuery, error)) BookPaginateOption {
	return func(pager *bookPager) error {
		if filter == nil {
			return errors.New("BookQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookPager struct {
	reverse bool
	order   []*BookOrder
	filter  func(*BookQuery) (*BookQuery, error)
}

func newBookPager(opts []BookPaginateOption, reverse bool) (*bookPager, error) {
	pager := &bookPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *bookPager) applyFilter(query *BookQuery) (*BookQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookPager) toCursor(b *Book) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(b).Value)
	}
	return Cursor{ID: b.ID, Value: cs}
}

func (p *bookPager) applyCursors(query *BookQuery, after, before *Cursor) (*BookQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultBookOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookPager) applyOrder(query *BookQuery) *BookQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultBookOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case BookOrderFieldFilesCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultBookOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *bookPager) orderExpr(query *BookQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case BookOrderFieldFilesCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultBookOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Book.
func (b *BookQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BookPaginateOption,
) (*BookConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BookConnection{Edges: []*BookEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = b.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if b, err = pager.applyCursors(b, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	b = pager.applyOrder(b)
	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// BookOrderFieldTitle orders Book by title.
	BookOrderFieldTitle = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.Title, nil
		},
		column: book.FieldTitle,
		toTerm: book.ByTitle,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.Title,
			}
		},
	}
	// BookOrderFieldSort orders Book by sort.
	BookOrderFieldSort = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.Sort, nil
		},
		column: book.FieldSort,
		toTerm: book.BySort,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.Sort,
			}
		},
	}
	// BookOrderFieldPublishedDate orders Book by published_date.
	BookOrderFieldPublishedDate = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.PublishedDate, nil
		},
		column: book.FieldPublishedDate,
		toTerm: book.ByPublishedDate,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.PublishedDate,
			}
		},
	}
	// BookOrderFieldIsbn orders Book by isbn.
	BookOrderFieldIsbn = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.Isbn, nil
		},
		column: book.FieldIsbn,
		toTerm: book.ByIsbn,
		toCursor: func(b *Book) Cursor {
			return Cursor{
				ID:    b.ID,
				Value: b.Isbn,
			}
		},
	}
	// BookOrderFieldFilesCount orders by FILES_COUNT.
	BookOrderFieldFilesCount = &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.Value("files_count")
		},
		column: "files_count",
		toTerm: func(opts ...sql.OrderTermOption) book.OrderOption {
			return book.ByFilesCount(
				append(opts, sql.OrderSelectAs("files_count"))...,
			)
		},
		toCursor: func(b *Book) Cursor {
			cv, _ := b.Value("files_count")
			return Cursor{
				ID:    b.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f BookOrderField) String() string {
	var str string
	switch f.column {
	case BookOrderFieldTitle.column:
		str = "TITLE"
	case BookOrderFieldSort.column:
		str = "NAME"
	case BookOrderFieldPublishedDate.column:
		str = "PUB_DATE"
	case BookOrderFieldIsbn.column:
		str = "ISBN"
	case BookOrderFieldFilesCount.column:
		str = "FILES_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f BookOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *BookOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("BookOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *BookOrderFieldTitle
	case "NAME":
		*f = *BookOrderFieldSort
	case "PUB_DATE":
		*f = *BookOrderFieldPublishedDate
	case "ISBN":
		*f = *BookOrderFieldIsbn
	case "FILES_COUNT":
		*f = *BookOrderFieldFilesCount
	default:
		return fmt.Errorf("%s is not a valid BookOrderField", str)
	}
	return nil
}

// BookOrderField defines the ordering field of Book.
type BookOrderField struct {
	// Value extracts the ordering value from the given Book.
	Value    func(*Book) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) book.OrderOption
	toCursor func(*Book) Cursor
}

// BookOrder defines the ordering of Book.
type BookOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *BookOrderField `json:"field"`
}

// DefaultBookOrder is the default ordering of Book.
var DefaultBookOrder = &BookOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookOrderField{
		Value: func(b *Book) (ent.Value, error) {
			return b.ID, nil
		},
		column: book.FieldID,
		toTerm: book.ByID,
		toCursor: func(b *Book) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Book into BookEdge.
func (b *Book) ToEdge(order *BookOrder) *BookEdge {
	if order == nil {
		order = DefaultBookOrder
	}
	return &BookEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BookFileEdge is the edge representation of BookFile.
type BookFileEdge struct {
	Node   *BookFile `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// BookFileConnection is the connection containing edges to BookFile.
type BookFileConnection struct {
	Edges      []*BookFileEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *BookFileConnection) build(nodes []*BookFile, pager *bookfilePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BookFile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BookFile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BookFile {
			return nodes[i]
		}
	}
	c.Edges = make([]*BookFileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BookFileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BookFilePaginateOption enables pagination customization.
type BookFilePaginateOption func(*bookfilePager) error

// WithBookFileOrder configures pagination ordering.
func WithBookFileOrder(order *BookFileOrder) BookFilePaginateOption {
	if order == nil {
		order = DefaultBookFileOrder
	}
	o := *order
	return func(pager *bookfilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBookFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBookFileFilter configures pagination filter.
func WithBookFileFilter(filter func(*BookFileQuery) (*BookFileQuery, error)) BookFilePaginateOption {
	return func(pager *bookfilePager) error {
		if filter == nil {
			return errors.New("BookFileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bookfilePager struct {
	reverse bool
	order   *BookFileOrder
	filter  func(*BookFileQuery) (*BookFileQuery, error)
}

func newBookFilePager(opts []BookFilePaginateOption, reverse bool) (*bookfilePager, error) {
	pager := &bookfilePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBookFileOrder
	}
	return pager, nil
}

func (p *bookfilePager) applyFilter(query *BookFileQuery) (*BookFileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bookfilePager) toCursor(bf *BookFile) Cursor {
	return p.order.Field.toCursor(bf)
}

func (p *bookfilePager) applyCursors(query *BookFileQuery, after, before *Cursor) (*BookFileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBookFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bookfilePager) applyOrder(query *BookFileQuery) *BookFileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBookFileOrder.Field {
		query = query.Order(DefaultBookFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *bookfilePager) orderExpr(query *BookFileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBookFileOrder.Field {
			b.Comma().Ident(DefaultBookFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BookFile.
func (bf *BookFileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BookFilePaginateOption,
) (*BookFileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBookFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bf, err = pager.applyFilter(bf); err != nil {
		return nil, err
	}
	conn := &BookFileConnection{Edges: []*BookFileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bf.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bf, err = pager.applyCursors(bf, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bf.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bf.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bf = pager.applyOrder(bf)
	nodes, err := bf.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BookFileOrderField defines the ordering field of BookFile.
type BookFileOrderField struct {
	// Value extracts the ordering value from the given BookFile.
	Value    func(*BookFile) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bookfile.OrderOption
	toCursor func(*BookFile) Cursor
}

// BookFileOrder defines the ordering of BookFile.
type BookFileOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *BookFileOrderField `json:"field"`
}

// DefaultBookFileOrder is the default ordering of BookFile.
var DefaultBookFileOrder = &BookFileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BookFileOrderField{
		Value: func(bf *BookFile) (ent.Value, error) {
			return bf.ID, nil
		},
		column: bookfile.FieldID,
		toTerm: bookfile.ByID,
		toCursor: func(bf *BookFile) Cursor {
			return Cursor{ID: bf.ID}
		},
	},
}

// ToEdge converts BookFile into BookFileEdge.
func (bf *BookFile) ToEdge(order *BookFileOrder) *BookFileEdge {
	if order == nil {
		order = DefaultBookFileOrder
	}
	return &BookFileEdge{
		Node:   bf,
		Cursor: order.Field.toCursor(bf),
	}
}

// IdentifierEdge is the edge representation of Identifier.
type IdentifierEdge struct {
	Node   *Identifier `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// IdentifierConnection is the connection containing edges to Identifier.
type IdentifierConnection struct {
	Edges      []*IdentifierEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *IdentifierConnection) build(nodes []*Identifier, pager *identifierPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Identifier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Identifier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Identifier {
			return nodes[i]
		}
	}
	c.Edges = make([]*IdentifierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IdentifierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IdentifierPaginateOption enables pagination customization.
type IdentifierPaginateOption func(*identifierPager) error

// WithIdentifierOrder configures pagination ordering.
func WithIdentifierOrder(order []*IdentifierOrder) IdentifierPaginateOption {
	return func(pager *identifierPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithIdentifierFilter configures pagination filter.
func WithIdentifierFilter(filter func(*IdentifierQuery) (*IdentifierQuery, error)) IdentifierPaginateOption {
	return func(pager *identifierPager) error {
		if filter == nil {
			return errors.New("IdentifierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identifierPager struct {
	reverse bool
	order   []*IdentifierOrder
	filter  func(*IdentifierQuery) (*IdentifierQuery, error)
}

func newIdentifierPager(opts []IdentifierPaginateOption, reverse bool) (*identifierPager, error) {
	pager := &identifierPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *identifierPager) applyFilter(query *IdentifierQuery) (*IdentifierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identifierPager) toCursor(i *Identifier) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(i).Value)
	}
	return Cursor{ID: i.ID, Value: cs}
}

func (p *identifierPager) applyCursors(query *IdentifierQuery, after, before *Cursor) (*IdentifierQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultIdentifierOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *identifierPager) applyOrder(query *IdentifierQuery) *IdentifierQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultIdentifierOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultIdentifierOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *identifierPager) orderExpr(query *IdentifierQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultIdentifierOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Identifier.
func (i *IdentifierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentifierPaginateOption,
) (*IdentifierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentifierPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IdentifierConnection{Edges: []*IdentifierEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// IdentifierOrderFieldType orders Identifier by type.
	IdentifierOrderFieldType = &IdentifierOrderField{
		Value: func(i *Identifier) (ent.Value, error) {
			return i.Type, nil
		},
		column: identifier.FieldType,
		toTerm: identifier.ByType,
		toCursor: func(i *Identifier) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Type,
			}
		},
	}
	// IdentifierOrderFieldValue orders Identifier by value.
	IdentifierOrderFieldValue = &IdentifierOrderField{
		Value: func(i *Identifier) (ent.Value, error) {
			return i.Value, nil
		},
		column: identifier.FieldValue,
		toTerm: identifier.ByValue,
		toCursor: func(i *Identifier) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Value,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f IdentifierOrderField) String() string {
	var str string
	switch f.column {
	case IdentifierOrderFieldType.column:
		str = "TYPE"
	case IdentifierOrderFieldValue.column:
		str = "VALUE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f IdentifierOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *IdentifierOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("IdentifierOrderField %T must be a string", v)
	}
	switch str {
	case "TYPE":
		*f = *IdentifierOrderFieldType
	case "VALUE":
		*f = *IdentifierOrderFieldValue
	default:
		return fmt.Errorf("%s is not a valid IdentifierOrderField", str)
	}
	return nil
}

// IdentifierOrderField defines the ordering field of Identifier.
type IdentifierOrderField struct {
	// Value extracts the ordering value from the given Identifier.
	Value    func(*Identifier) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) identifier.OrderOption
	toCursor func(*Identifier) Cursor
}

// IdentifierOrder defines the ordering of Identifier.
type IdentifierOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *IdentifierOrderField `json:"field"`
}

// DefaultIdentifierOrder is the default ordering of Identifier.
var DefaultIdentifierOrder = &IdentifierOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IdentifierOrderField{
		Value: func(i *Identifier) (ent.Value, error) {
			return i.ID, nil
		},
		column: identifier.FieldID,
		toTerm: identifier.ByID,
		toCursor: func(i *Identifier) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Identifier into IdentifierEdge.
func (i *Identifier) ToEdge(order *IdentifierOrder) *IdentifierEdge {
	if order == nil {
		order = DefaultIdentifierOrder
	}
	return &IdentifierEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// LanguageEdge is the edge representation of Language.
type LanguageEdge struct {
	Node   *Language `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LanguageConnection is the connection containing edges to Language.
type LanguageConnection struct {
	Edges      []*LanguageEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LanguageConnection) build(nodes []*Language, pager *languagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Language
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Language {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Language {
			return nodes[i]
		}
	}
	c.Edges = make([]*LanguageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LanguageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LanguagePaginateOption enables pagination customization.
type LanguagePaginateOption func(*languagePager) error

// WithLanguageOrder configures pagination ordering.
func WithLanguageOrder(order []*LanguageOrder) LanguagePaginateOption {
	return func(pager *languagePager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithLanguageFilter configures pagination filter.
func WithLanguageFilter(filter func(*LanguageQuery) (*LanguageQuery, error)) LanguagePaginateOption {
	return func(pager *languagePager) error {
		if filter == nil {
			return errors.New("LanguageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type languagePager struct {
	reverse bool
	order   []*LanguageOrder
	filter  func(*LanguageQuery) (*LanguageQuery, error)
}

func newLanguagePager(opts []LanguagePaginateOption, reverse bool) (*languagePager, error) {
	pager := &languagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *languagePager) applyFilter(query *LanguageQuery) (*LanguageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *languagePager) toCursor(l *Language) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(l).Value)
	}
	return Cursor{ID: l.ID, Value: cs}
}

func (p *languagePager) applyCursors(query *LanguageQuery, after, before *Cursor) (*LanguageQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultLanguageOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *languagePager) applyOrder(query *LanguageQuery) *LanguageQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultLanguageOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case LanguageOrderFieldBooksCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultLanguageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *languagePager) orderExpr(query *LanguageQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case LanguageOrderFieldBooksCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultLanguageOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Language.
func (l *LanguageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LanguagePaginateOption,
) (*LanguageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLanguagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LanguageConnection{Edges: []*LanguageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = l.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LanguageOrderFieldBooksCount orders by BOOKS_COUNT.
	LanguageOrderFieldBooksCount = &LanguageOrderField{
		Value: func(l *Language) (ent.Value, error) {
			return l.Value("books_count")
		},
		column: "books_count",
		toTerm: func(opts ...sql.OrderTermOption) language.OrderOption {
			return language.ByBooksCount(
				append(opts, sql.OrderSelectAs("books_count"))...,
			)
		},
		toCursor: func(l *Language) Cursor {
			cv, _ := l.Value("books_count")
			return Cursor{
				ID:    l.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LanguageOrderField) String() string {
	var str string
	switch f.column {
	case LanguageOrderFieldBooksCount.column:
		str = "BOOKS_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LanguageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LanguageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LanguageOrderField %T must be a string", v)
	}
	switch str {
	case "BOOKS_COUNT":
		*f = *LanguageOrderFieldBooksCount
	default:
		return fmt.Errorf("%s is not a valid LanguageOrderField", str)
	}
	return nil
}

// LanguageOrderField defines the ordering field of Language.
type LanguageOrderField struct {
	// Value extracts the ordering value from the given Language.
	Value    func(*Language) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) language.OrderOption
	toCursor func(*Language) Cursor
}

// LanguageOrder defines the ordering of Language.
type LanguageOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LanguageOrderField `json:"field"`
}

// DefaultLanguageOrder is the default ordering of Language.
var DefaultLanguageOrder = &LanguageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LanguageOrderField{
		Value: func(l *Language) (ent.Value, error) {
			return l.ID, nil
		},
		column: language.FieldID,
		toTerm: language.ByID,
		toCursor: func(l *Language) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Language into LanguageEdge.
func (l *Language) ToEdge(order *LanguageOrder) *LanguageEdge {
	if order == nil {
		order = DefaultLanguageOrder
	}
	return &LanguageEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// PublisherEdge is the edge representation of Publisher.
type PublisherEdge struct {
	Node   *Publisher `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PublisherConnection is the connection containing edges to Publisher.
type PublisherConnection struct {
	Edges      []*PublisherEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PublisherConnection) build(nodes []*Publisher, pager *publisherPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Publisher
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Publisher {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Publisher {
			return nodes[i]
		}
	}
	c.Edges = make([]*PublisherEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PublisherEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PublisherPaginateOption enables pagination customization.
type PublisherPaginateOption func(*publisherPager) error

// WithPublisherOrder configures pagination ordering.
func WithPublisherOrder(order []*PublisherOrder) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithPublisherFilter configures pagination filter.
func WithPublisherFilter(filter func(*PublisherQuery) (*PublisherQuery, error)) PublisherPaginateOption {
	return func(pager *publisherPager) error {
		if filter == nil {
			return errors.New("PublisherQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type publisherPager struct {
	reverse bool
	order   []*PublisherOrder
	filter  func(*PublisherQuery) (*PublisherQuery, error)
}

func newPublisherPager(opts []PublisherPaginateOption, reverse bool) (*publisherPager, error) {
	pager := &publisherPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *publisherPager) applyFilter(query *PublisherQuery) (*PublisherQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *publisherPager) toCursor(pu *Publisher) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(pu).Value)
	}
	return Cursor{ID: pu.ID, Value: cs}
}

func (p *publisherPager) applyCursors(query *PublisherQuery, after, before *Cursor) (*PublisherQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultPublisherOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *publisherPager) applyOrder(query *PublisherQuery) *PublisherQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultPublisherOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case PublisherOrderFieldBooksCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultPublisherOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *publisherPager) orderExpr(query *PublisherQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case PublisherOrderFieldBooksCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultPublisherOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Publisher.
func (pu *PublisherQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PublisherPaginateOption,
) (*PublisherConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPublisherPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PublisherConnection{Edges: []*PublisherEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pu.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PublisherOrderFieldName orders Publisher by name.
	PublisherOrderFieldName = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.Name, nil
		},
		column: publisher.FieldName,
		toTerm: publisher.ByName,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{
				ID:    pu.ID,
				Value: pu.Name,
			}
		},
	}
	// PublisherOrderFieldBooksCount orders by BOOKS_COUNT.
	PublisherOrderFieldBooksCount = &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.Value("books_count")
		},
		column: "books_count",
		toTerm: func(opts ...sql.OrderTermOption) publisher.OrderOption {
			return publisher.ByBooksCount(
				append(opts, sql.OrderSelectAs("books_count"))...,
			)
		},
		toCursor: func(pu *Publisher) Cursor {
			cv, _ := pu.Value("books_count")
			return Cursor{
				ID:    pu.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PublisherOrderField) String() string {
	var str string
	switch f.column {
	case PublisherOrderFieldName.column:
		str = "NAME"
	case PublisherOrderFieldBooksCount.column:
		str = "BOOKS_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PublisherOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PublisherOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PublisherOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *PublisherOrderFieldName
	case "BOOKS_COUNT":
		*f = *PublisherOrderFieldBooksCount
	default:
		return fmt.Errorf("%s is not a valid PublisherOrderField", str)
	}
	return nil
}

// PublisherOrderField defines the ordering field of Publisher.
type PublisherOrderField struct {
	// Value extracts the ordering value from the given Publisher.
	Value    func(*Publisher) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) publisher.OrderOption
	toCursor func(*Publisher) Cursor
}

// PublisherOrder defines the ordering of Publisher.
type PublisherOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PublisherOrderField `json:"field"`
}

// DefaultPublisherOrder is the default ordering of Publisher.
var DefaultPublisherOrder = &PublisherOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PublisherOrderField{
		Value: func(pu *Publisher) (ent.Value, error) {
			return pu.ID, nil
		},
		column: publisher.FieldID,
		toTerm: publisher.ByID,
		toCursor: func(pu *Publisher) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts Publisher into PublisherEdge.
func (pu *Publisher) ToEdge(order *PublisherOrder) *PublisherEdge {
	if order == nil {
		order = DefaultPublisherOrder
	}
	return &PublisherEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// SeriesEdge is the edge representation of Series.
type SeriesEdge struct {
	Node   *Series `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SeriesConnection is the connection containing edges to Series.
type SeriesConnection struct {
	Edges      []*SeriesEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SeriesConnection) build(nodes []*Series, pager *seriesPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Series
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Series {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Series {
			return nodes[i]
		}
	}
	c.Edges = make([]*SeriesEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SeriesEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SeriesPaginateOption enables pagination customization.
type SeriesPaginateOption func(*seriesPager) error

// WithSeriesOrder configures pagination ordering.
func WithSeriesOrder(order []*SeriesOrder) SeriesPaginateOption {
	return func(pager *seriesPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithSeriesFilter configures pagination filter.
func WithSeriesFilter(filter func(*SeriesQuery) (*SeriesQuery, error)) SeriesPaginateOption {
	return func(pager *seriesPager) error {
		if filter == nil {
			return errors.New("SeriesQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type seriesPager struct {
	reverse bool
	order   []*SeriesOrder
	filter  func(*SeriesQuery) (*SeriesQuery, error)
}

func newSeriesPager(opts []SeriesPaginateOption, reverse bool) (*seriesPager, error) {
	pager := &seriesPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *seriesPager) applyFilter(query *SeriesQuery) (*SeriesQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *seriesPager) toCursor(s *Series) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *seriesPager) applyCursors(query *SeriesQuery, after, before *Cursor) (*SeriesQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultSeriesOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *seriesPager) applyOrder(query *SeriesQuery) *SeriesQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultSeriesOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultSeriesOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *seriesPager) orderExpr(query *SeriesQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultSeriesOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Series.
func (s *SeriesQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SeriesPaginateOption,
) (*SeriesConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSeriesPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SeriesConnection{Edges: []*SeriesEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SeriesOrderFieldSort orders Series by sort.
	SeriesOrderFieldSort = &SeriesOrderField{
		Value: func(s *Series) (ent.Value, error) {
			return s.Sort, nil
		},
		column: series.FieldSort,
		toTerm: series.BySort,
		toCursor: func(s *Series) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Sort,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SeriesOrderField) String() string {
	var str string
	switch f.column {
	case SeriesOrderFieldSort.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SeriesOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SeriesOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SeriesOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *SeriesOrderFieldSort
	default:
		return fmt.Errorf("%s is not a valid SeriesOrderField", str)
	}
	return nil
}

// SeriesOrderField defines the ordering field of Series.
type SeriesOrderField struct {
	// Value extracts the ordering value from the given Series.
	Value    func(*Series) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) series.OrderOption
	toCursor func(*Series) Cursor
}

// SeriesOrder defines the ordering of Series.
type SeriesOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SeriesOrderField `json:"field"`
}

// DefaultSeriesOrder is the default ordering of Series.
var DefaultSeriesOrder = &SeriesOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SeriesOrderField{
		Value: func(s *Series) (ent.Value, error) {
			return s.ID, nil
		},
		column: series.FieldID,
		toTerm: series.ByID,
		toCursor: func(s *Series) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Series into SeriesEdge.
func (s *Series) ToEdge(order *SeriesOrder) *SeriesEdge {
	if order == nil {
		order = DefaultSeriesOrder
	}
	return &SeriesEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ShelfEdge is the edge representation of Shelf.
type ShelfEdge struct {
	Node   *Shelf `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ShelfConnection is the connection containing edges to Shelf.
type ShelfConnection struct {
	Edges      []*ShelfEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ShelfConnection) build(nodes []*Shelf, pager *shelfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Shelf
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Shelf {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Shelf {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShelfEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShelfEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShelfPaginateOption enables pagination customization.
type ShelfPaginateOption func(*shelfPager) error

// WithShelfOrder configures pagination ordering.
func WithShelfOrder(order []*ShelfOrder) ShelfPaginateOption {
	return func(pager *shelfPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithShelfFilter configures pagination filter.
func WithShelfFilter(filter func(*ShelfQuery) (*ShelfQuery, error)) ShelfPaginateOption {
	return func(pager *shelfPager) error {
		if filter == nil {
			return errors.New("ShelfQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shelfPager struct {
	reverse bool
	order   []*ShelfOrder
	filter  func(*ShelfQuery) (*ShelfQuery, error)
}

func newShelfPager(opts []ShelfPaginateOption, reverse bool) (*shelfPager, error) {
	pager := &shelfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *shelfPager) applyFilter(query *ShelfQuery) (*ShelfQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shelfPager) toCursor(s *Shelf) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(s).Value)
	}
	return Cursor{ID: s.ID, Value: cs}
}

func (p *shelfPager) applyCursors(query *ShelfQuery, after, before *Cursor) (*ShelfQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultShelfOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shelfPager) applyOrder(query *ShelfQuery) *ShelfQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultShelfOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case ShelfOrderFieldBooksCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultShelfOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *shelfPager) orderExpr(query *ShelfQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case ShelfOrderFieldBooksCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultShelfOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Shelf.
func (s *ShelfQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShelfPaginateOption,
) (*ShelfConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShelfPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &ShelfConnection{Edges: []*ShelfEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ShelfOrderFieldName orders Shelf by name.
	ShelfOrderFieldName = &ShelfOrderField{
		Value: func(s *Shelf) (ent.Value, error) {
			return s.Name, nil
		},
		column: shelf.FieldName,
		toTerm: shelf.ByName,
		toCursor: func(s *Shelf) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
	// ShelfOrderFieldBooksCount orders by BOOKS_COUNT.
	ShelfOrderFieldBooksCount = &ShelfOrderField{
		Value: func(s *Shelf) (ent.Value, error) {
			return s.Value("books_count")
		},
		column: "books_count",
		toTerm: func(opts ...sql.OrderTermOption) shelf.OrderOption {
			return shelf.ByBooksCount(
				append(opts, sql.OrderSelectAs("books_count"))...,
			)
		},
		toCursor: func(s *Shelf) Cursor {
			cv, _ := s.Value("books_count")
			return Cursor{
				ID:    s.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShelfOrderField) String() string {
	var str string
	switch f.column {
	case ShelfOrderFieldName.column:
		str = "NAME"
	case ShelfOrderFieldBooksCount.column:
		str = "BOOKS_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShelfOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShelfOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShelfOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *ShelfOrderFieldName
	case "BOOKS_COUNT":
		*f = *ShelfOrderFieldBooksCount
	default:
		return fmt.Errorf("%s is not a valid ShelfOrderField", str)
	}
	return nil
}

// ShelfOrderField defines the ordering field of Shelf.
type ShelfOrderField struct {
	// Value extracts the ordering value from the given Shelf.
	Value    func(*Shelf) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shelf.OrderOption
	toCursor func(*Shelf) Cursor
}

// ShelfOrder defines the ordering of Shelf.
type ShelfOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ShelfOrderField `json:"field"`
}

// DefaultShelfOrder is the default ordering of Shelf.
var DefaultShelfOrder = &ShelfOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShelfOrderField{
		Value: func(s *Shelf) (ent.Value, error) {
			return s.ID, nil
		},
		column: shelf.FieldID,
		toTerm: shelf.ByID,
		toCursor: func(s *Shelf) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Shelf into ShelfEdge.
func (s *Shelf) ToEdge(order *ShelfOrder) *ShelfEdge {
	if order == nil {
		order = DefaultShelfOrder
	}
	return &ShelfEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *TagConnection) build(nodes []*Tag, pager *tagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order []*TagOrder) TagPaginateOption {
	return func(pager *tagPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	reverse bool
	order   []*TagOrder
	filter  func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption, reverse bool) (*tagPager, error) {
	pager := &tagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) (*TagQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTagOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tagPager) applyOrder(query *TagQuery) *TagQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTagOrder.Field.column {
			defaultOrdered = true
		}
		switch o.Field.column {
		case TagOrderFieldBooksCount.column:
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *tagPager) orderExpr(query *TagQuery) sql.Querier {
	for _, o := range p.order {
		switch o.Field.column {
		case TagOrderFieldBooksCount.column:
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		default:
			if len(query.ctx.Fields) > 0 {
				query.ctx.AppendFieldOnce(o.Field.column)
			}
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTagOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TagConnection{Edges: []*TagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TagOrderFieldName orders Tag by name.
	TagOrderFieldName = &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.Name, nil
		},
		column: tag.FieldName,
		toTerm: tag.ByName,
		toCursor: func(t *Tag) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Name,
			}
		},
	}
	// TagOrderFieldBooksCount orders by BOOKS_COUNT.
	TagOrderFieldBooksCount = &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.Value("books_count")
		},
		column: "books_count",
		toTerm: func(opts ...sql.OrderTermOption) tag.OrderOption {
			return tag.ByBooksCount(
				append(opts, sql.OrderSelectAs("books_count"))...,
			)
		},
		toCursor: func(t *Tag) Cursor {
			cv, _ := t.Value("books_count")
			return Cursor{
				ID:    t.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TagOrderField) String() string {
	var str string
	switch f.column {
	case TagOrderFieldName.column:
		str = "NAME"
	case TagOrderFieldBooksCount.column:
		str = "BOOKS_COUNT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TagOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TagOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TagOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *TagOrderFieldName
	case "BOOKS_COUNT":
		*f = *TagOrderFieldBooksCount
	default:
		return fmt.Errorf("%s is not a valid TagOrderField", str)
	}
	return nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	// Value extracts the ordering value from the given Tag.
	Value    func(*Tag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tag.OrderOption
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.ID, nil
		},
		column: tag.FieldID,
		toTerm: tag.ByID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order []*TaskOrder) TaskPaginateOption {
	return func(pager *taskPager) error {
		for _, o := range order {
			if err := o.Direction.Validate(); err != nil {
				return err
			}
		}
		pager.order = append(pager.order, order...)
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   []*TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	for i, o := range pager.order {
		if i > 0 && o.Field == pager.order[i-1].Field {
			return nil, fmt.Errorf("duplicate order direction %q", o.Direction)
		}
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	cs := make([]any, 0, len(p.order))
	for _, o := range p.order {
		cs = append(cs, o.Field.toCursor(t).Value)
	}
	return Cursor{ID: t.ID, Value: cs}
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	idDirection := entgql.OrderDirectionAsc
	if p.reverse {
		idDirection = entgql.OrderDirectionDesc
	}
	fields, directions := make([]string, 0, len(p.order)), make([]OrderDirection, 0, len(p.order))
	for _, o := range p.order {
		fields = append(fields, o.Field.column)
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		directions = append(directions, direction)
	}
	predicates, err := entgql.MultiCursorsPredicate(after, before, &entgql.MultiCursorsOptions{
		FieldID:     DefaultTaskOrder.Field.column,
		DirectionID: idDirection,
		Fields:      fields,
		Directions:  directions,
	})
	if err != nil {
		return nil, err
	}
	for _, predicate := range predicates {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	var defaultOrdered bool
	for _, o := range p.order {
		direction := o.Direction
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(o.Field.toTerm(direction.OrderTermOption()))
		if o.Field.column == DefaultTaskOrder.Field.column {
			defaultOrdered = true
		}
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	if !defaultOrdered {
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	if len(query.ctx.Fields) > 0 {
		for _, o := range p.order {
			query.ctx.AppendFieldOnce(o.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		for _, o := range p.order {
			direction := o.Direction
			if p.reverse {
				direction = direction.Reverse()
			}
			b.Ident(o.Field.column).Pad().WriteString(string(direction))
			b.Comma()
		}
		direction := entgql.OrderDirectionAsc
		if p.reverse {
			direction = direction.Reverse()
		}
		b.Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TaskOrderFieldType orders Task by type.
	TaskOrderFieldType = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Type, nil
		},
		column: task.FieldType,
		toTerm: task.ByType,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Type,
			}
		},
	}
	// TaskOrderFieldStatus orders Task by status.
	TaskOrderFieldStatus = &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.Status, nil
		},
		column: task.FieldStatus,
		toTerm: task.ByStatus,
		toCursor: func(t *Task) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.Status,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TaskOrderField) String() string {
	var str string
	switch f.column {
	case TaskOrderFieldType.column:
		str = "TYPE"
	case TaskOrderFieldStatus.column:
		str = "STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TaskOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TaskOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TaskOrderField %T must be a string", v)
	}
	switch str {
	case "TYPE":
		*f = *TaskOrderFieldType
	case "STATUS":
		*f = *TaskOrderFieldStatus
	default:
		return fmt.Errorf("%s is not a valid TaskOrderField", str)
	}
	return nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldUsername orders User by username.
	UserOrderFieldUsername = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Username, nil
		},
		column: user.FieldUsername,
		toTerm: user.ByUsername,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Username,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldUsername.column:
		str = "USERNAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "USERNAME":
		*f = *UserOrderFieldUsername
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserPermissionsEdge is the edge representation of UserPermissions.
type UserPermissionsEdge struct {
	Node   *UserPermissions `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// UserPermissionsConnection is the connection containing edges to UserPermissions.
type UserPermissionsConnection struct {
	Edges      []*UserPermissionsEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *UserPermissionsConnection) build(nodes []*UserPermissions, pager *userpermissionsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserPermissions
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserPermissions {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserPermissions {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserPermissionsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserPermissionsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPermissionsPaginateOption enables pagination customization.
type UserPermissionsPaginateOption func(*userpermissionsPager) error

// WithUserPermissionsOrder configures pagination ordering.
func WithUserPermissionsOrder(order *UserPermissionsOrder) UserPermissionsPaginateOption {
	if order == nil {
		order = DefaultUserPermissionsOrder
	}
	o := *order
	return func(pager *userpermissionsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserPermissionsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserPermissionsFilter configures pagination filter.
func WithUserPermissionsFilter(filter func(*UserPermissionsQuery) (*UserPermissionsQuery, error)) UserPermissionsPaginateOption {
	return func(pager *userpermissionsPager) error {
		if filter == nil {
			return errors.New("UserPermissionsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userpermissionsPager struct {
	reverse bool
	order   *UserPermissionsOrder
	filter  func(*UserPermissionsQuery) (*UserPermissionsQuery, error)
}

func newUserPermissionsPager(opts []UserPermissionsPaginateOption, reverse bool) (*userpermissionsPager, error) {
	pager := &userpermissionsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserPermissionsOrder
	}
	return pager, nil
}

func (p *userpermissionsPager) applyFilter(query *UserPermissionsQuery) (*UserPermissionsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userpermissionsPager) toCursor(up *UserPermissions) Cursor {
	return p.order.Field.toCursor(up)
}

func (p *userpermissionsPager) applyCursors(query *UserPermissionsQuery, after, before *Cursor) (*UserPermissionsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserPermissionsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userpermissionsPager) applyOrder(query *UserPermissionsQuery) *UserPermissionsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserPermissionsOrder.Field {
		query = query.Order(DefaultUserPermissionsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userpermissionsPager) orderExpr(query *UserPermissionsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserPermissionsOrder.Field {
			b.Comma().Ident(DefaultUserPermissionsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserPermissions.
func (up *UserPermissionsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPermissionsPaginateOption,
) (*UserPermissionsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPermissionsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if up, err = pager.applyFilter(up); err != nil {
		return nil, err
	}
	conn := &UserPermissionsConnection{Edges: []*UserPermissionsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = up.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if up, err = pager.applyCursors(up, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		up.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := up.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	up = pager.applyOrder(up)
	nodes, err := up.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserPermissionsOrderField defines the ordering field of UserPermissions.
type UserPermissionsOrderField struct {
	// Value extracts the ordering value from the given UserPermissions.
	Value    func(*UserPermissions) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userpermissions.OrderOption
	toCursor func(*UserPermissions) Cursor
}

// UserPermissionsOrder defines the ordering of UserPermissions.
type UserPermissionsOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *UserPermissionsOrderField `json:"field"`
}

// DefaultUserPermissionsOrder is the default ordering of UserPermissions.
var DefaultUserPermissionsOrder = &UserPermissionsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserPermissionsOrderField{
		Value: func(up *UserPermissions) (ent.Value, error) {
			return up.ID, nil
		},
		column: userpermissions.FieldID,
		toTerm: userpermissions.ByID,
		toCursor: func(up *UserPermissions) Cursor {
			return Cursor{ID: up.ID}
		},
	},
}

// ToEdge converts UserPermissions into UserPermissionsEdge.
func (up *UserPermissions) ToEdge(order *UserPermissionsOrder) *UserPermissionsEdge {
	if order == nil {
		order = DefaultUserPermissionsOrder
	}
	return &UserPermissionsEdge{
		Node:   up,
		Cursor: order.Field.toCursor(up),
	}
}
