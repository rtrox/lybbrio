// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"lybbrio/internal/ent/author"
	"lybbrio/internal/ent/book"
	"lybbrio/internal/ent/bookfile"
	"lybbrio/internal/ent/identifier"
	"lybbrio/internal/ent/language"
	"lybbrio/internal/ent/predicate"
	"lybbrio/internal/ent/publisher"
	"lybbrio/internal/ent/schema/ksuid"
	"lybbrio/internal/ent/schema/task_enums"
	"lybbrio/internal/ent/series"
	"lybbrio/internal/ent/shelf"
	"lybbrio/internal/ent/tag"
	"lybbrio/internal/ent/task"
	"lybbrio/internal/ent/user"
	"lybbrio/internal/ent/userpermissions"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthor          = "Author"
	TypeBook            = "Book"
	TypeBookFile        = "BookFile"
	TypeIdentifier      = "Identifier"
	TypeLanguage        = "Language"
	TypePublisher       = "Publisher"
	TypeSeries          = "Series"
	TypeShelf           = "Shelf"
	TypeTag             = "Tag"
	TypeTask            = "Task"
	TypeUser            = "User"
	TypeUserPermissions = "UserPermissions"
)

// AuthorMutation represents an operation that mutates the Author nodes in the graph.
type AuthorMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	calibre_id    *int64
	addcalibre_id *int64
	name          *string
	sort          *string
	link          *string
	clearedFields map[string]struct{}
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Author, error)
	predicates    []predicate.Author
}

var _ ent.Mutation = (*AuthorMutation)(nil)

// authorOption allows management of the mutation configuration using functional options.
type authorOption func(*AuthorMutation)

// newAuthorMutation creates new mutation for the Author entity.
func newAuthorMutation(c config, op Op, opts ...authorOption) *AuthorMutation {
	m := &AuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorID sets the ID field of the mutation.
func withAuthorID(id ksuid.ID) authorOption {
	return func(m *AuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *Author
		)
		m.oldValue = func(ctx context.Context) (*Author, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Author.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthor sets the old Author of the mutation.
func withAuthor(node *Author) authorOption {
	return func(m *AuthorMutation) {
		m.oldValue = func(context.Context) (*Author, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Author entities.
func (m *AuthorMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Author.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuthorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuthorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuthorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AuthorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuthorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuthorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *AuthorMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *AuthorMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *AuthorMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *AuthorMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *AuthorMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[author.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *AuthorMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[author.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *AuthorMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, author.FieldCalibreID)
}

// SetName sets the "name" field.
func (m *AuthorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthorMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *AuthorMutation) SetSort(s string) {
	m.sort = &s
}

// Sort returns the value of the "sort" field in the mutation.
func (m *AuthorMutation) Sort() (r string, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *AuthorMutation) ResetSort() {
	m.sort = nil
}

// SetLink sets the "link" field.
func (m *AuthorMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *AuthorMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Author entity.
// If the Author object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *AuthorMutation) ClearLink() {
	m.link = nil
	m.clearedFields[author.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *AuthorMutation) LinkCleared() bool {
	_, ok := m.clearedFields[author.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *AuthorMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, author.FieldLink)
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *AuthorMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *AuthorMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *AuthorMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *AuthorMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *AuthorMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *AuthorMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *AuthorMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the AuthorMutation builder.
func (m *AuthorMutation) Where(ps ...predicate.Author) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Author, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Author).
func (m *AuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, author.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, author.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, author.FieldCalibreID)
	}
	if m.name != nil {
		fields = append(fields, author.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, author.FieldSort)
	}
	if m.link != nil {
		fields = append(fields, author.FieldLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case author.FieldCreateTime:
		return m.CreateTime()
	case author.FieldUpdateTime:
		return m.UpdateTime()
	case author.FieldCalibreID:
		return m.CalibreID()
	case author.FieldName:
		return m.Name()
	case author.FieldSort:
		return m.Sort()
	case author.FieldLink:
		return m.Link()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case author.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case author.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case author.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case author.FieldName:
		return m.OldName(ctx)
	case author.FieldSort:
		return m.OldSort(ctx)
	case author.FieldLink:
		return m.OldLink(ctx)
	}
	return nil, fmt.Errorf("unknown Author field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case author.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case author.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case author.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case author.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case author.FieldSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case author.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, author.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case author.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case author.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Author numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(author.FieldCalibreID) {
		fields = append(fields, author.FieldCalibreID)
	}
	if m.FieldCleared(author.FieldLink) {
		fields = append(fields, author.FieldLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorMutation) ClearField(name string) error {
	switch name {
	case author.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	case author.FieldLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Author nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorMutation) ResetField(name string) error {
	switch name {
	case author.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case author.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case author.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case author.FieldName:
		m.ResetName()
		return nil
	case author.FieldSort:
		m.ResetSort()
		return nil
	case author.FieldLink:
		m.ResetLink()
		return nil
	}
	return fmt.Errorf("unknown Author field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, author.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, author.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case author.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, author.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorMutation) EdgeCleared(name string) bool {
	switch name {
	case author.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Author unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorMutation) ResetEdge(name string) error {
	switch name {
	case author.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Author edge %s", name)
}

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op                 Op
	typ                string
	id                 *ksuid.ID
	create_time        *time.Time
	update_time        *time.Time
	calibre_id         *int64
	addcalibre_id      *int64
	title              *string
	sort               *string
	published_date     *time.Time
	_path              *string
	isbn               *string
	description        *string
	series_index       *float64
	addseries_index    *float64
	clearedFields      map[string]struct{}
	authors            map[ksuid.ID]struct{}
	removedauthors     map[ksuid.ID]struct{}
	clearedauthors     bool
	publisher          map[ksuid.ID]struct{}
	removedpublisher   map[ksuid.ID]struct{}
	clearedpublisher   bool
	series             map[ksuid.ID]struct{}
	removedseries      map[ksuid.ID]struct{}
	clearedseries      bool
	identifiers        map[ksuid.ID]struct{}
	removedidentifiers map[ksuid.ID]struct{}
	clearedidentifiers bool
	tags               map[ksuid.ID]struct{}
	removedtags        map[ksuid.ID]struct{}
	clearedtags        bool
	language           map[ksuid.ID]struct{}
	removedlanguage    map[ksuid.ID]struct{}
	clearedlanguage    bool
	shelf              map[ksuid.ID]struct{}
	removedshelf       map[ksuid.ID]struct{}
	clearedshelf       bool
	files              map[ksuid.ID]struct{}
	removedfiles       map[ksuid.ID]struct{}
	clearedfiles       bool
	done               bool
	oldValue           func(context.Context) (*Book, error)
	predicates         []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id ksuid.ID) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Book entities.
func (m *BookMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BookMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BookMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BookMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BookMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BookMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BookMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *BookMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *BookMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *BookMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *BookMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *BookMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[book.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *BookMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[book.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *BookMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, book.FieldCalibreID)
}

// SetTitle sets the "title" field.
func (m *BookMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BookMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BookMutation) ResetTitle() {
	m.title = nil
}

// SetSort sets the "sort" field.
func (m *BookMutation) SetSort(s string) {
	m.sort = &s
}

// Sort returns the value of the "sort" field in the mutation.
func (m *BookMutation) Sort() (r string, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *BookMutation) ResetSort() {
	m.sort = nil
}

// SetPublishedDate sets the "published_date" field.
func (m *BookMutation) SetPublishedDate(t time.Time) {
	m.published_date = &t
}

// PublishedDate returns the value of the "published_date" field in the mutation.
func (m *BookMutation) PublishedDate() (r time.Time, exists bool) {
	v := m.published_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedDate returns the old "published_date" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPublishedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedDate: %w", err)
	}
	return oldValue.PublishedDate, nil
}

// ClearPublishedDate clears the value of the "published_date" field.
func (m *BookMutation) ClearPublishedDate() {
	m.published_date = nil
	m.clearedFields[book.FieldPublishedDate] = struct{}{}
}

// PublishedDateCleared returns if the "published_date" field was cleared in this mutation.
func (m *BookMutation) PublishedDateCleared() bool {
	_, ok := m.clearedFields[book.FieldPublishedDate]
	return ok
}

// ResetPublishedDate resets all changes to the "published_date" field.
func (m *BookMutation) ResetPublishedDate() {
	m.published_date = nil
	delete(m.clearedFields, book.FieldPublishedDate)
}

// SetPath sets the "path" field.
func (m *BookMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *BookMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *BookMutation) ResetPath() {
	m._path = nil
}

// SetIsbn sets the "isbn" field.
func (m *BookMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *BookMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ClearIsbn clears the value of the "isbn" field.
func (m *BookMutation) ClearIsbn() {
	m.isbn = nil
	m.clearedFields[book.FieldIsbn] = struct{}{}
}

// IsbnCleared returns if the "isbn" field was cleared in this mutation.
func (m *BookMutation) IsbnCleared() bool {
	_, ok := m.clearedFields[book.FieldIsbn]
	return ok
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *BookMutation) ResetIsbn() {
	m.isbn = nil
	delete(m.clearedFields, book.FieldIsbn)
}

// SetDescription sets the "description" field.
func (m *BookMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BookMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BookMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[book.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BookMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[book.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BookMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, book.FieldDescription)
}

// SetSeriesIndex sets the "series_index" field.
func (m *BookMutation) SetSeriesIndex(f float64) {
	m.series_index = &f
	m.addseries_index = nil
}

// SeriesIndex returns the value of the "series_index" field in the mutation.
func (m *BookMutation) SeriesIndex() (r float64, exists bool) {
	v := m.series_index
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesIndex returns the old "series_index" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldSeriesIndex(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesIndex: %w", err)
	}
	return oldValue.SeriesIndex, nil
}

// AddSeriesIndex adds f to the "series_index" field.
func (m *BookMutation) AddSeriesIndex(f float64) {
	if m.addseries_index != nil {
		*m.addseries_index += f
	} else {
		m.addseries_index = &f
	}
}

// AddedSeriesIndex returns the value that was added to the "series_index" field in this mutation.
func (m *BookMutation) AddedSeriesIndex() (r float64, exists bool) {
	v := m.addseries_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeriesIndex clears the value of the "series_index" field.
func (m *BookMutation) ClearSeriesIndex() {
	m.series_index = nil
	m.addseries_index = nil
	m.clearedFields[book.FieldSeriesIndex] = struct{}{}
}

// SeriesIndexCleared returns if the "series_index" field was cleared in this mutation.
func (m *BookMutation) SeriesIndexCleared() bool {
	_, ok := m.clearedFields[book.FieldSeriesIndex]
	return ok
}

// ResetSeriesIndex resets all changes to the "series_index" field.
func (m *BookMutation) ResetSeriesIndex() {
	m.series_index = nil
	m.addseries_index = nil
	delete(m.clearedFields, book.FieldSeriesIndex)
}

// AddAuthorIDs adds the "authors" edge to the Author entity by ids.
func (m *BookMutation) AddAuthorIDs(ids ...ksuid.ID) {
	if m.authors == nil {
		m.authors = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the Author entity.
func (m *BookMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the Author entity was cleared.
func (m *BookMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the Author entity by IDs.
func (m *BookMutation) RemoveAuthorIDs(ids ...ksuid.ID) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the Author entity.
func (m *BookMutation) RemovedAuthorsIDs() (ids []ksuid.ID) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *BookMutation) AuthorsIDs() (ids []ksuid.ID) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *BookMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// AddPublisherIDs adds the "publisher" edge to the Publisher entity by ids.
func (m *BookMutation) AddPublisherIDs(ids ...ksuid.ID) {
	if m.publisher == nil {
		m.publisher = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.publisher[ids[i]] = struct{}{}
	}
}

// ClearPublisher clears the "publisher" edge to the Publisher entity.
func (m *BookMutation) ClearPublisher() {
	m.clearedpublisher = true
}

// PublisherCleared reports if the "publisher" edge to the Publisher entity was cleared.
func (m *BookMutation) PublisherCleared() bool {
	return m.clearedpublisher
}

// RemovePublisherIDs removes the "publisher" edge to the Publisher entity by IDs.
func (m *BookMutation) RemovePublisherIDs(ids ...ksuid.ID) {
	if m.removedpublisher == nil {
		m.removedpublisher = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.publisher, ids[i])
		m.removedpublisher[ids[i]] = struct{}{}
	}
}

// RemovedPublisher returns the removed IDs of the "publisher" edge to the Publisher entity.
func (m *BookMutation) RemovedPublisherIDs() (ids []ksuid.ID) {
	for id := range m.removedpublisher {
		ids = append(ids, id)
	}
	return
}

// PublisherIDs returns the "publisher" edge IDs in the mutation.
func (m *BookMutation) PublisherIDs() (ids []ksuid.ID) {
	for id := range m.publisher {
		ids = append(ids, id)
	}
	return
}

// ResetPublisher resets all changes to the "publisher" edge.
func (m *BookMutation) ResetPublisher() {
	m.publisher = nil
	m.clearedpublisher = false
	m.removedpublisher = nil
}

// AddSeriesIDs adds the "series" edge to the Series entity by ids.
func (m *BookMutation) AddSeriesIDs(ids ...ksuid.ID) {
	if m.series == nil {
		m.series = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.series[ids[i]] = struct{}{}
	}
}

// ClearSeries clears the "series" edge to the Series entity.
func (m *BookMutation) ClearSeries() {
	m.clearedseries = true
}

// SeriesCleared reports if the "series" edge to the Series entity was cleared.
func (m *BookMutation) SeriesCleared() bool {
	return m.clearedseries
}

// RemoveSeriesIDs removes the "series" edge to the Series entity by IDs.
func (m *BookMutation) RemoveSeriesIDs(ids ...ksuid.ID) {
	if m.removedseries == nil {
		m.removedseries = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.series, ids[i])
		m.removedseries[ids[i]] = struct{}{}
	}
}

// RemovedSeries returns the removed IDs of the "series" edge to the Series entity.
func (m *BookMutation) RemovedSeriesIDs() (ids []ksuid.ID) {
	for id := range m.removedseries {
		ids = append(ids, id)
	}
	return
}

// SeriesIDs returns the "series" edge IDs in the mutation.
func (m *BookMutation) SeriesIDs() (ids []ksuid.ID) {
	for id := range m.series {
		ids = append(ids, id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *BookMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
	m.removedseries = nil
}

// AddIdentifierIDs adds the "identifiers" edge to the Identifier entity by ids.
func (m *BookMutation) AddIdentifierIDs(ids ...ksuid.ID) {
	if m.identifiers == nil {
		m.identifiers = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.identifiers[ids[i]] = struct{}{}
	}
}

// ClearIdentifiers clears the "identifiers" edge to the Identifier entity.
func (m *BookMutation) ClearIdentifiers() {
	m.clearedidentifiers = true
}

// IdentifiersCleared reports if the "identifiers" edge to the Identifier entity was cleared.
func (m *BookMutation) IdentifiersCleared() bool {
	return m.clearedidentifiers
}

// RemoveIdentifierIDs removes the "identifiers" edge to the Identifier entity by IDs.
func (m *BookMutation) RemoveIdentifierIDs(ids ...ksuid.ID) {
	if m.removedidentifiers == nil {
		m.removedidentifiers = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.identifiers, ids[i])
		m.removedidentifiers[ids[i]] = struct{}{}
	}
}

// RemovedIdentifiers returns the removed IDs of the "identifiers" edge to the Identifier entity.
func (m *BookMutation) RemovedIdentifiersIDs() (ids []ksuid.ID) {
	for id := range m.removedidentifiers {
		ids = append(ids, id)
	}
	return
}

// IdentifiersIDs returns the "identifiers" edge IDs in the mutation.
func (m *BookMutation) IdentifiersIDs() (ids []ksuid.ID) {
	for id := range m.identifiers {
		ids = append(ids, id)
	}
	return
}

// ResetIdentifiers resets all changes to the "identifiers" edge.
func (m *BookMutation) ResetIdentifiers() {
	m.identifiers = nil
	m.clearedidentifiers = false
	m.removedidentifiers = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *BookMutation) AddTagIDs(ids ...ksuid.ID) {
	if m.tags == nil {
		m.tags = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *BookMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *BookMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *BookMutation) RemoveTagIDs(ids ...ksuid.ID) {
	if m.removedtags == nil {
		m.removedtags = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *BookMutation) RemovedTagsIDs() (ids []ksuid.ID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *BookMutation) TagsIDs() (ids []ksuid.ID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *BookMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLanguageIDs adds the "language" edge to the Language entity by ids.
func (m *BookMutation) AddLanguageIDs(ids ...ksuid.ID) {
	if m.language == nil {
		m.language = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.language[ids[i]] = struct{}{}
	}
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *BookMutation) ClearLanguage() {
	m.clearedlanguage = true
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *BookMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// RemoveLanguageIDs removes the "language" edge to the Language entity by IDs.
func (m *BookMutation) RemoveLanguageIDs(ids ...ksuid.ID) {
	if m.removedlanguage == nil {
		m.removedlanguage = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.language, ids[i])
		m.removedlanguage[ids[i]] = struct{}{}
	}
}

// RemovedLanguage returns the removed IDs of the "language" edge to the Language entity.
func (m *BookMutation) RemovedLanguageIDs() (ids []ksuid.ID) {
	for id := range m.removedlanguage {
		ids = append(ids, id)
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
func (m *BookMutation) LanguageIDs() (ids []ksuid.ID) {
	for id := range m.language {
		ids = append(ids, id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *BookMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
	m.removedlanguage = nil
}

// AddShelfIDs adds the "shelf" edge to the Shelf entity by ids.
func (m *BookMutation) AddShelfIDs(ids ...ksuid.ID) {
	if m.shelf == nil {
		m.shelf = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.shelf[ids[i]] = struct{}{}
	}
}

// ClearShelf clears the "shelf" edge to the Shelf entity.
func (m *BookMutation) ClearShelf() {
	m.clearedshelf = true
}

// ShelfCleared reports if the "shelf" edge to the Shelf entity was cleared.
func (m *BookMutation) ShelfCleared() bool {
	return m.clearedshelf
}

// RemoveShelfIDs removes the "shelf" edge to the Shelf entity by IDs.
func (m *BookMutation) RemoveShelfIDs(ids ...ksuid.ID) {
	if m.removedshelf == nil {
		m.removedshelf = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.shelf, ids[i])
		m.removedshelf[ids[i]] = struct{}{}
	}
}

// RemovedShelf returns the removed IDs of the "shelf" edge to the Shelf entity.
func (m *BookMutation) RemovedShelfIDs() (ids []ksuid.ID) {
	for id := range m.removedshelf {
		ids = append(ids, id)
	}
	return
}

// ShelfIDs returns the "shelf" edge IDs in the mutation.
func (m *BookMutation) ShelfIDs() (ids []ksuid.ID) {
	for id := range m.shelf {
		ids = append(ids, id)
	}
	return
}

// ResetShelf resets all changes to the "shelf" edge.
func (m *BookMutation) ResetShelf() {
	m.shelf = nil
	m.clearedshelf = false
	m.removedshelf = nil
}

// AddFileIDs adds the "files" edge to the BookFile entity by ids.
func (m *BookMutation) AddFileIDs(ids ...ksuid.ID) {
	if m.files == nil {
		m.files = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the BookFile entity.
func (m *BookMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the BookFile entity was cleared.
func (m *BookMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the BookFile entity by IDs.
func (m *BookMutation) RemoveFileIDs(ids ...ksuid.ID) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the BookFile entity.
func (m *BookMutation) RemovedFilesIDs() (ids []ksuid.ID) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *BookMutation) FilesIDs() (ids []ksuid.ID) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *BookMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, book.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, book.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, book.FieldCalibreID)
	}
	if m.title != nil {
		fields = append(fields, book.FieldTitle)
	}
	if m.sort != nil {
		fields = append(fields, book.FieldSort)
	}
	if m.published_date != nil {
		fields = append(fields, book.FieldPublishedDate)
	}
	if m._path != nil {
		fields = append(fields, book.FieldPath)
	}
	if m.isbn != nil {
		fields = append(fields, book.FieldIsbn)
	}
	if m.description != nil {
		fields = append(fields, book.FieldDescription)
	}
	if m.series_index != nil {
		fields = append(fields, book.FieldSeriesIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldCreateTime:
		return m.CreateTime()
	case book.FieldUpdateTime:
		return m.UpdateTime()
	case book.FieldCalibreID:
		return m.CalibreID()
	case book.FieldTitle:
		return m.Title()
	case book.FieldSort:
		return m.Sort()
	case book.FieldPublishedDate:
		return m.PublishedDate()
	case book.FieldPath:
		return m.Path()
	case book.FieldIsbn:
		return m.Isbn()
	case book.FieldDescription:
		return m.Description()
	case book.FieldSeriesIndex:
		return m.SeriesIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case book.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case book.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case book.FieldTitle:
		return m.OldTitle(ctx)
	case book.FieldSort:
		return m.OldSort(ctx)
	case book.FieldPublishedDate:
		return m.OldPublishedDate(ctx)
	case book.FieldPath:
		return m.OldPath(ctx)
	case book.FieldIsbn:
		return m.OldIsbn(ctx)
	case book.FieldDescription:
		return m.OldDescription(ctx)
	case book.FieldSeriesIndex:
		return m.OldSeriesIndex(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case book.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case book.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case book.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case book.FieldSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case book.FieldPublishedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedDate(v)
		return nil
	case book.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case book.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case book.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case book.FieldSeriesIndex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, book.FieldCalibreID)
	}
	if m.addseries_index != nil {
		fields = append(fields, book.FieldSeriesIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case book.FieldCalibreID:
		return m.AddedCalibreID()
	case book.FieldSeriesIndex:
		return m.AddedSeriesIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case book.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	case book.FieldSeriesIndex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeriesIndex(v)
		return nil
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(book.FieldCalibreID) {
		fields = append(fields, book.FieldCalibreID)
	}
	if m.FieldCleared(book.FieldPublishedDate) {
		fields = append(fields, book.FieldPublishedDate)
	}
	if m.FieldCleared(book.FieldIsbn) {
		fields = append(fields, book.FieldIsbn)
	}
	if m.FieldCleared(book.FieldDescription) {
		fields = append(fields, book.FieldDescription)
	}
	if m.FieldCleared(book.FieldSeriesIndex) {
		fields = append(fields, book.FieldSeriesIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	switch name {
	case book.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	case book.FieldPublishedDate:
		m.ClearPublishedDate()
		return nil
	case book.FieldIsbn:
		m.ClearIsbn()
		return nil
	case book.FieldDescription:
		m.ClearDescription()
		return nil
	case book.FieldSeriesIndex:
		m.ClearSeriesIndex()
		return nil
	}
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case book.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case book.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case book.FieldTitle:
		m.ResetTitle()
		return nil
	case book.FieldSort:
		m.ResetSort()
		return nil
	case book.FieldPublishedDate:
		m.ResetPublishedDate()
		return nil
	case book.FieldPath:
		m.ResetPath()
		return nil
	case book.FieldIsbn:
		m.ResetIsbn()
		return nil
	case book.FieldDescription:
		m.ResetDescription()
		return nil
	case book.FieldSeriesIndex:
		m.ResetSeriesIndex()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.authors != nil {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.publisher != nil {
		edges = append(edges, book.EdgePublisher)
	}
	if m.series != nil {
		edges = append(edges, book.EdgeSeries)
	}
	if m.identifiers != nil {
		edges = append(edges, book.EdgeIdentifiers)
	}
	if m.tags != nil {
		edges = append(edges, book.EdgeTags)
	}
	if m.language != nil {
		edges = append(edges, book.EdgeLanguage)
	}
	if m.shelf != nil {
		edges = append(edges, book.EdgeShelf)
	}
	if m.files != nil {
		edges = append(edges, book.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	case book.EdgePublisher:
		ids := make([]ent.Value, 0, len(m.publisher))
		for id := range m.publisher {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeSeries:
		ids := make([]ent.Value, 0, len(m.series))
		for id := range m.series {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.identifiers))
		for id := range m.identifiers {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeLanguage:
		ids := make([]ent.Value, 0, len(m.language))
		for id := range m.language {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeShelf:
		ids := make([]ent.Value, 0, len(m.shelf))
		for id := range m.shelf {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedauthors != nil {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.removedpublisher != nil {
		edges = append(edges, book.EdgePublisher)
	}
	if m.removedseries != nil {
		edges = append(edges, book.EdgeSeries)
	}
	if m.removedidentifiers != nil {
		edges = append(edges, book.EdgeIdentifiers)
	}
	if m.removedtags != nil {
		edges = append(edges, book.EdgeTags)
	}
	if m.removedlanguage != nil {
		edges = append(edges, book.EdgeLanguage)
	}
	if m.removedshelf != nil {
		edges = append(edges, book.EdgeShelf)
	}
	if m.removedfiles != nil {
		edges = append(edges, book.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	case book.EdgePublisher:
		ids := make([]ent.Value, 0, len(m.removedpublisher))
		for id := range m.removedpublisher {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeSeries:
		ids := make([]ent.Value, 0, len(m.removedseries))
		for id := range m.removedseries {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeIdentifiers:
		ids := make([]ent.Value, 0, len(m.removedidentifiers))
		for id := range m.removedidentifiers {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeLanguage:
		ids := make([]ent.Value, 0, len(m.removedlanguage))
		for id := range m.removedlanguage {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeShelf:
		ids := make([]ent.Value, 0, len(m.removedshelf))
		for id := range m.removedshelf {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedauthors {
		edges = append(edges, book.EdgeAuthors)
	}
	if m.clearedpublisher {
		edges = append(edges, book.EdgePublisher)
	}
	if m.clearedseries {
		edges = append(edges, book.EdgeSeries)
	}
	if m.clearedidentifiers {
		edges = append(edges, book.EdgeIdentifiers)
	}
	if m.clearedtags {
		edges = append(edges, book.EdgeTags)
	}
	if m.clearedlanguage {
		edges = append(edges, book.EdgeLanguage)
	}
	if m.clearedshelf {
		edges = append(edges, book.EdgeShelf)
	}
	if m.clearedfiles {
		edges = append(edges, book.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	case book.EdgeAuthors:
		return m.clearedauthors
	case book.EdgePublisher:
		return m.clearedpublisher
	case book.EdgeSeries:
		return m.clearedseries
	case book.EdgeIdentifiers:
		return m.clearedidentifiers
	case book.EdgeTags:
		return m.clearedtags
	case book.EdgeLanguage:
		return m.clearedlanguage
	case book.EdgeShelf:
		return m.clearedshelf
	case book.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgeAuthors:
		m.ResetAuthors()
		return nil
	case book.EdgePublisher:
		m.ResetPublisher()
		return nil
	case book.EdgeSeries:
		m.ResetSeries()
		return nil
	case book.EdgeIdentifiers:
		m.ResetIdentifiers()
		return nil
	case book.EdgeTags:
		m.ResetTags()
		return nil
	case book.EdgeLanguage:
		m.ResetLanguage()
		return nil
	case book.EdgeShelf:
		m.ResetShelf()
		return nil
	case book.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookFileMutation represents an operation that mutates the BookFile nodes in the graph.
type BookFileMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	_path         *string
	size          *int64
	addsize       *int64
	format        *bookfile.Format
	clearedFields map[string]struct{}
	book          *ksuid.ID
	clearedbook   bool
	done          bool
	oldValue      func(context.Context) (*BookFile, error)
	predicates    []predicate.BookFile
}

var _ ent.Mutation = (*BookFileMutation)(nil)

// bookfileOption allows management of the mutation configuration using functional options.
type bookfileOption func(*BookFileMutation)

// newBookFileMutation creates new mutation for the BookFile entity.
func newBookFileMutation(c config, op Op, opts ...bookfileOption) *BookFileMutation {
	m := &BookFileMutation{
		config:        c,
		op:            op,
		typ:           TypeBookFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookFileID sets the ID field of the mutation.
func withBookFileID(id ksuid.ID) bookfileOption {
	return func(m *BookFileMutation) {
		var (
			err   error
			once  sync.Once
			value *BookFile
		)
		m.oldValue = func(ctx context.Context) (*BookFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BookFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookFile sets the old BookFile of the mutation.
func withBookFile(node *BookFile) bookfileOption {
	return func(m *BookFileMutation) {
		m.oldValue = func(context.Context) (*BookFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BookFile entities.
func (m *BookFileMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookFileMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookFileMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BookFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BookFileMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BookFileMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BookFileMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BookFileMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BookFileMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BookFileMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *BookFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BookFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BookFileMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *BookFileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *BookFileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *BookFileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *BookFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *BookFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *BookFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *BookFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *BookFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetFormat sets the "format" field.
func (m *BookFileMutation) SetFormat(b bookfile.Format) {
	m.format = &b
}

// Format returns the value of the "format" field in the mutation.
func (m *BookFileMutation) Format() (r bookfile.Format, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the BookFile entity.
// If the BookFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookFileMutation) OldFormat(ctx context.Context) (v bookfile.Format, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *BookFileMutation) ResetFormat() {
	m.format = nil
}

// SetBookID sets the "book" edge to the Book entity by id.
func (m *BookFileMutation) SetBookID(id ksuid.ID) {
	m.book = &id
}

// ClearBook clears the "book" edge to the Book entity.
func (m *BookFileMutation) ClearBook() {
	m.clearedbook = true
}

// BookCleared reports if the "book" edge to the Book entity was cleared.
func (m *BookFileMutation) BookCleared() bool {
	return m.clearedbook
}

// BookID returns the "book" edge ID in the mutation.
func (m *BookFileMutation) BookID() (id ksuid.ID, exists bool) {
	if m.book != nil {
		return *m.book, true
	}
	return
}

// BookIDs returns the "book" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookID instead. It exists only for internal usage by the builders.
func (m *BookFileMutation) BookIDs() (ids []ksuid.ID) {
	if id := m.book; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBook resets all changes to the "book" edge.
func (m *BookFileMutation) ResetBook() {
	m.book = nil
	m.clearedbook = false
}

// Where appends a list predicates to the BookFileMutation builder.
func (m *BookFileMutation) Where(ps ...predicate.BookFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BookFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BookFile).
func (m *BookFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookFileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, bookfile.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, bookfile.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, bookfile.FieldName)
	}
	if m._path != nil {
		fields = append(fields, bookfile.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, bookfile.FieldSize)
	}
	if m.format != nil {
		fields = append(fields, bookfile.FieldFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookfile.FieldCreateTime:
		return m.CreateTime()
	case bookfile.FieldUpdateTime:
		return m.UpdateTime()
	case bookfile.FieldName:
		return m.Name()
	case bookfile.FieldPath:
		return m.Path()
	case bookfile.FieldSize:
		return m.Size()
	case bookfile.FieldFormat:
		return m.Format()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookfile.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case bookfile.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case bookfile.FieldName:
		return m.OldName(ctx)
	case bookfile.FieldPath:
		return m.OldPath(ctx)
	case bookfile.FieldSize:
		return m.OldSize(ctx)
	case bookfile.FieldFormat:
		return m.OldFormat(ctx)
	}
	return nil, fmt.Errorf("unknown BookFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookfile.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case bookfile.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case bookfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case bookfile.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case bookfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case bookfile.FieldFormat:
		v, ok := value.(bookfile.Format)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	}
	return fmt.Errorf("unknown BookFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, bookfile.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bookfile.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bookfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown BookFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BookFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookFileMutation) ResetField(name string) error {
	switch name {
	case bookfile.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case bookfile.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case bookfile.FieldName:
		m.ResetName()
		return nil
	case bookfile.FieldPath:
		m.ResetPath()
		return nil
	case bookfile.FieldSize:
		m.ResetSize()
		return nil
	case bookfile.FieldFormat:
		m.ResetFormat()
		return nil
	}
	return fmt.Errorf("unknown BookFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.book != nil {
		edges = append(edges, bookfile.EdgeBook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookfile.EdgeBook:
		if id := m.book; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbook {
		edges = append(edges, bookfile.EdgeBook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookFileMutation) EdgeCleared(name string) bool {
	switch name {
	case bookfile.EdgeBook:
		return m.clearedbook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookFileMutation) ClearEdge(name string) error {
	switch name {
	case bookfile.EdgeBook:
		m.ClearBook()
		return nil
	}
	return fmt.Errorf("unknown BookFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookFileMutation) ResetEdge(name string) error {
	switch name {
	case bookfile.EdgeBook:
		m.ResetBook()
		return nil
	}
	return fmt.Errorf("unknown BookFile edge %s", name)
}

// IdentifierMutation represents an operation that mutates the Identifier nodes in the graph.
type IdentifierMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	calibre_id    *int64
	addcalibre_id *int64
	_type         *string
	value         *string
	clearedFields map[string]struct{}
	book          *ksuid.ID
	clearedbook   bool
	done          bool
	oldValue      func(context.Context) (*Identifier, error)
	predicates    []predicate.Identifier
}

var _ ent.Mutation = (*IdentifierMutation)(nil)

// identifierOption allows management of the mutation configuration using functional options.
type identifierOption func(*IdentifierMutation)

// newIdentifierMutation creates new mutation for the Identifier entity.
func newIdentifierMutation(c config, op Op, opts ...identifierOption) *IdentifierMutation {
	m := &IdentifierMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentifier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentifierID sets the ID field of the mutation.
func withIdentifierID(id ksuid.ID) identifierOption {
	return func(m *IdentifierMutation) {
		var (
			err   error
			once  sync.Once
			value *Identifier
		)
		m.oldValue = func(ctx context.Context) (*Identifier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Identifier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentifier sets the old Identifier of the mutation.
func withIdentifier(node *Identifier) identifierOption {
	return func(m *IdentifierMutation) {
		m.oldValue = func(context.Context) (*Identifier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentifierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentifierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Identifier entities.
func (m *IdentifierMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentifierMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentifierMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Identifier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *IdentifierMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *IdentifierMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Identifier entity.
// If the Identifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifierMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *IdentifierMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *IdentifierMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *IdentifierMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Identifier entity.
// If the Identifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifierMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *IdentifierMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *IdentifierMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *IdentifierMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Identifier entity.
// If the Identifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifierMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *IdentifierMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *IdentifierMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *IdentifierMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[identifier.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *IdentifierMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[identifier.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *IdentifierMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, identifier.FieldCalibreID)
}

// SetType sets the "type" field.
func (m *IdentifierMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *IdentifierMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Identifier entity.
// If the Identifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifierMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *IdentifierMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *IdentifierMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *IdentifierMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Identifier entity.
// If the Identifier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentifierMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *IdentifierMutation) ResetValue() {
	m.value = nil
}

// SetBookID sets the "book" edge to the Book entity by id.
func (m *IdentifierMutation) SetBookID(id ksuid.ID) {
	m.book = &id
}

// ClearBook clears the "book" edge to the Book entity.
func (m *IdentifierMutation) ClearBook() {
	m.clearedbook = true
}

// BookCleared reports if the "book" edge to the Book entity was cleared.
func (m *IdentifierMutation) BookCleared() bool {
	return m.clearedbook
}

// BookID returns the "book" edge ID in the mutation.
func (m *IdentifierMutation) BookID() (id ksuid.ID, exists bool) {
	if m.book != nil {
		return *m.book, true
	}
	return
}

// BookIDs returns the "book" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookID instead. It exists only for internal usage by the builders.
func (m *IdentifierMutation) BookIDs() (ids []ksuid.ID) {
	if id := m.book; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBook resets all changes to the "book" edge.
func (m *IdentifierMutation) ResetBook() {
	m.book = nil
	m.clearedbook = false
}

// Where appends a list predicates to the IdentifierMutation builder.
func (m *IdentifierMutation) Where(ps ...predicate.Identifier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentifierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentifierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Identifier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentifierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentifierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Identifier).
func (m *IdentifierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentifierMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, identifier.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, identifier.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, identifier.FieldCalibreID)
	}
	if m._type != nil {
		fields = append(fields, identifier.FieldType)
	}
	if m.value != nil {
		fields = append(fields, identifier.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentifierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identifier.FieldCreateTime:
		return m.CreateTime()
	case identifier.FieldUpdateTime:
		return m.UpdateTime()
	case identifier.FieldCalibreID:
		return m.CalibreID()
	case identifier.FieldType:
		return m.GetType()
	case identifier.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentifierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identifier.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case identifier.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case identifier.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case identifier.FieldType:
		return m.OldType(ctx)
	case identifier.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Identifier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentifierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identifier.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case identifier.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case identifier.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case identifier.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case identifier.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Identifier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentifierMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, identifier.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentifierMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case identifier.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentifierMutation) AddField(name string, value ent.Value) error {
	switch name {
	case identifier.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Identifier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentifierMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(identifier.FieldCalibreID) {
		fields = append(fields, identifier.FieldCalibreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentifierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentifierMutation) ClearField(name string) error {
	switch name {
	case identifier.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	}
	return fmt.Errorf("unknown Identifier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentifierMutation) ResetField(name string) error {
	switch name {
	case identifier.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case identifier.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case identifier.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case identifier.FieldType:
		m.ResetType()
		return nil
	case identifier.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Identifier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentifierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.book != nil {
		edges = append(edges, identifier.EdgeBook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentifierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identifier.EdgeBook:
		if id := m.book; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentifierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentifierMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentifierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbook {
		edges = append(edges, identifier.EdgeBook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentifierMutation) EdgeCleared(name string) bool {
	switch name {
	case identifier.EdgeBook:
		return m.clearedbook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentifierMutation) ClearEdge(name string) error {
	switch name {
	case identifier.EdgeBook:
		m.ClearBook()
		return nil
	}
	return fmt.Errorf("unknown Identifier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentifierMutation) ResetEdge(name string) error {
	switch name {
	case identifier.EdgeBook:
		m.ResetBook()
		return nil
	}
	return fmt.Errorf("unknown Identifier edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	calibre_id    *int64
	addcalibre_id *int64
	code          *string
	clearedFields map[string]struct{}
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id ksuid.ID) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *LanguageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LanguageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LanguageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *LanguageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LanguageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LanguageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *LanguageMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *LanguageMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *LanguageMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *LanguageMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *LanguageMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[language.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *LanguageMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[language.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *LanguageMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, language.FieldCalibreID)
}

// SetCode sets the "code" field.
func (m *LanguageMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LanguageMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *LanguageMutation) ResetCode() {
	m.code = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *LanguageMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *LanguageMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *LanguageMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *LanguageMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *LanguageMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *LanguageMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *LanguageMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, language.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, language.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, language.FieldCalibreID)
	}
	if m.code != nil {
		fields = append(fields, language.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldCreateTime:
		return m.CreateTime()
	case language.FieldUpdateTime:
		return m.UpdateTime()
	case language.FieldCalibreID:
		return m.CalibreID()
	case language.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case language.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case language.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case language.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case language.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case language.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case language.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, language.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case language.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case language.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(language.FieldCalibreID) {
		fields = append(fields, language.FieldCalibreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	switch name {
	case language.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	}
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case language.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case language.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case language.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, language.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, language.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, language.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// PublisherMutation represents an operation that mutates the Publisher nodes in the graph.
type PublisherMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	calibre_id    *int64
	addcalibre_id *int64
	name          *string
	clearedFields map[string]struct{}
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Publisher, error)
	predicates    []predicate.Publisher
}

var _ ent.Mutation = (*PublisherMutation)(nil)

// publisherOption allows management of the mutation configuration using functional options.
type publisherOption func(*PublisherMutation)

// newPublisherMutation creates new mutation for the Publisher entity.
func newPublisherMutation(c config, op Op, opts ...publisherOption) *PublisherMutation {
	m := &PublisherMutation{
		config:        c,
		op:            op,
		typ:           TypePublisher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublisherID sets the ID field of the mutation.
func withPublisherID(id ksuid.ID) publisherOption {
	return func(m *PublisherMutation) {
		var (
			err   error
			once  sync.Once
			value *Publisher
		)
		m.oldValue = func(ctx context.Context) (*Publisher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publisher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublisher sets the old Publisher of the mutation.
func withPublisher(node *Publisher) publisherOption {
	return func(m *PublisherMutation) {
		m.oldValue = func(context.Context) (*Publisher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublisherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublisherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Publisher entities.
func (m *PublisherMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublisherMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublisherMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publisher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PublisherMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PublisherMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PublisherMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PublisherMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PublisherMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PublisherMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *PublisherMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *PublisherMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *PublisherMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *PublisherMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *PublisherMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[publisher.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *PublisherMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[publisher.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *PublisherMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, publisher.FieldCalibreID)
}

// SetName sets the "name" field.
func (m *PublisherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PublisherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Publisher entity.
// If the Publisher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublisherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PublisherMutation) ResetName() {
	m.name = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *PublisherMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *PublisherMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *PublisherMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *PublisherMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *PublisherMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *PublisherMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *PublisherMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the PublisherMutation builder.
func (m *PublisherMutation) Where(ps ...predicate.Publisher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublisherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublisherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publisher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublisherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublisherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publisher).
func (m *PublisherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublisherMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, publisher.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, publisher.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, publisher.FieldCalibreID)
	}
	if m.name != nil {
		fields = append(fields, publisher.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublisherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publisher.FieldCreateTime:
		return m.CreateTime()
	case publisher.FieldUpdateTime:
		return m.UpdateTime()
	case publisher.FieldCalibreID:
		return m.CalibreID()
	case publisher.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublisherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publisher.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case publisher.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case publisher.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case publisher.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Publisher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publisher.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case publisher.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case publisher.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case publisher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublisherMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, publisher.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublisherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publisher.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublisherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publisher.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Publisher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublisherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publisher.FieldCalibreID) {
		fields = append(fields, publisher.FieldCalibreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublisherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublisherMutation) ClearField(name string) error {
	switch name {
	case publisher.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	}
	return fmt.Errorf("unknown Publisher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublisherMutation) ResetField(name string) error {
	switch name {
	case publisher.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case publisher.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case publisher.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case publisher.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Publisher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublisherMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublisherMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublisherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublisherMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publisher.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublisherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, publisher.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublisherMutation) EdgeCleared(name string) bool {
	switch name {
	case publisher.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublisherMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Publisher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublisherMutation) ResetEdge(name string) error {
	switch name {
	case publisher.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Publisher edge %s", name)
}

// SeriesMutation represents an operation that mutates the Series nodes in the graph.
type SeriesMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	calibre_id    *int64
	addcalibre_id *int64
	name          *string
	sort          *string
	clearedFields map[string]struct{}
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Series, error)
	predicates    []predicate.Series
}

var _ ent.Mutation = (*SeriesMutation)(nil)

// seriesOption allows management of the mutation configuration using functional options.
type seriesOption func(*SeriesMutation)

// newSeriesMutation creates new mutation for the Series entity.
func newSeriesMutation(c config, op Op, opts ...seriesOption) *SeriesMutation {
	m := &SeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriesID sets the ID field of the mutation.
func withSeriesID(id ksuid.ID) seriesOption {
	return func(m *SeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *Series
		)
		m.oldValue = func(ctx context.Context) (*Series, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Series.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeries sets the old Series of the mutation.
func withSeries(node *Series) seriesOption {
	return func(m *SeriesMutation) {
		m.oldValue = func(context.Context) (*Series, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Series entities.
func (m *SeriesMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriesMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriesMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Series.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SeriesMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SeriesMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SeriesMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SeriesMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SeriesMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SeriesMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetCalibreID sets the "calibre_id" field.
func (m *SeriesMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *SeriesMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *SeriesMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *SeriesMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *SeriesMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[series.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *SeriesMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[series.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *SeriesMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, series.FieldCalibreID)
}

// SetName sets the "name" field.
func (m *SeriesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SeriesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SeriesMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *SeriesMutation) SetSort(s string) {
	m.sort = &s
}

// Sort returns the value of the "sort" field in the mutation.
func (m *SeriesMutation) Sort() (r string, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Series entity.
// If the Series object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriesMutation) OldSort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// ResetSort resets all changes to the "sort" field.
func (m *SeriesMutation) ResetSort() {
	m.sort = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *SeriesMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *SeriesMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *SeriesMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *SeriesMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *SeriesMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *SeriesMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *SeriesMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the SeriesMutation builder.
func (m *SeriesMutation) Where(ps ...predicate.Series) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Series, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Series).
func (m *SeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, series.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, series.FieldUpdateTime)
	}
	if m.calibre_id != nil {
		fields = append(fields, series.FieldCalibreID)
	}
	if m.name != nil {
		fields = append(fields, series.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, series.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case series.FieldCreateTime:
		return m.CreateTime()
	case series.FieldUpdateTime:
		return m.UpdateTime()
	case series.FieldCalibreID:
		return m.CalibreID()
	case series.FieldName:
		return m.Name()
	case series.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case series.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case series.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case series.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case series.FieldName:
		return m.OldName(ctx)
	case series.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown Series field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case series.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case series.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case series.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case series.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case series.FieldSort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriesMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, series.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case series.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case series.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Series numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(series.FieldCalibreID) {
		fields = append(fields, series.FieldCalibreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriesMutation) ClearField(name string) error {
	switch name {
	case series.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	}
	return fmt.Errorf("unknown Series nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriesMutation) ResetField(name string) error {
	switch name {
	case series.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case series.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case series.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case series.FieldName:
		m.ResetName()
		return nil
	case series.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown Series field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, series.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, series.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case series.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, series.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case series.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Series unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriesMutation) ResetEdge(name string) error {
	switch name {
	case series.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Series edge %s", name)
}

// ShelfMutation represents an operation that mutates the Shelf nodes in the graph.
type ShelfMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	create_time   *time.Time
	update_time   *time.Time
	public        *bool
	name          *string
	description   *string
	clearedFields map[string]struct{}
	user          *ksuid.ID
	cleareduser   bool
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Shelf, error)
	predicates    []predicate.Shelf
}

var _ ent.Mutation = (*ShelfMutation)(nil)

// shelfOption allows management of the mutation configuration using functional options.
type shelfOption func(*ShelfMutation)

// newShelfMutation creates new mutation for the Shelf entity.
func newShelfMutation(c config, op Op, opts ...shelfOption) *ShelfMutation {
	m := &ShelfMutation{
		config:        c,
		op:            op,
		typ:           TypeShelf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShelfID sets the ID field of the mutation.
func withShelfID(id ksuid.ID) shelfOption {
	return func(m *ShelfMutation) {
		var (
			err   error
			once  sync.Once
			value *Shelf
		)
		m.oldValue = func(ctx context.Context) (*Shelf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shelf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShelf sets the old Shelf of the mutation.
func withShelf(node *Shelf) shelfOption {
	return func(m *ShelfMutation) {
		m.oldValue = func(context.Context) (*Shelf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShelfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShelfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shelf entities.
func (m *ShelfMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShelfMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShelfMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shelf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ShelfMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShelfMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShelfMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShelfMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShelfMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShelfMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPublic sets the "public" field.
func (m *ShelfMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *ShelfMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *ShelfMutation) ResetPublic() {
	m.public = nil
}

// SetUserID sets the "user_id" field.
func (m *ShelfMutation) SetUserID(k ksuid.ID) {
	m.user = &k
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ShelfMutation) UserID() (r ksuid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldUserID(ctx context.Context) (v ksuid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ShelfMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *ShelfMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ShelfMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ShelfMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ShelfMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShelfMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Shelf entity.
// If the Shelf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShelfMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShelfMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shelf.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShelfMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shelf.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShelfMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shelf.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ShelfMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[shelf.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ShelfMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ShelfMutation) UserIDs() (ids []ksuid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ShelfMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *ShelfMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *ShelfMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *ShelfMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *ShelfMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *ShelfMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *ShelfMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *ShelfMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the ShelfMutation builder.
func (m *ShelfMutation) Where(ps ...predicate.Shelf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShelfMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShelfMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shelf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShelfMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShelfMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shelf).
func (m *ShelfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShelfMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, shelf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shelf.FieldUpdateTime)
	}
	if m.public != nil {
		fields = append(fields, shelf.FieldPublic)
	}
	if m.user != nil {
		fields = append(fields, shelf.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, shelf.FieldName)
	}
	if m.description != nil {
		fields = append(fields, shelf.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShelfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shelf.FieldCreateTime:
		return m.CreateTime()
	case shelf.FieldUpdateTime:
		return m.UpdateTime()
	case shelf.FieldPublic:
		return m.Public()
	case shelf.FieldUserID:
		return m.UserID()
	case shelf.FieldName:
		return m.Name()
	case shelf.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShelfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shelf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shelf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shelf.FieldPublic:
		return m.OldPublic(ctx)
	case shelf.FieldUserID:
		return m.OldUserID(ctx)
	case shelf.FieldName:
		return m.OldName(ctx)
	case shelf.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Shelf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShelfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shelf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shelf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shelf.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case shelf.FieldUserID:
		v, ok := value.(ksuid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case shelf.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shelf.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Shelf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShelfMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShelfMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShelfMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shelf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShelfMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shelf.FieldDescription) {
		fields = append(fields, shelf.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShelfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShelfMutation) ClearField(name string) error {
	switch name {
	case shelf.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Shelf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShelfMutation) ResetField(name string) error {
	switch name {
	case shelf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shelf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shelf.FieldPublic:
		m.ResetPublic()
		return nil
	case shelf.FieldUserID:
		m.ResetUserID()
		return nil
	case shelf.FieldName:
		m.ResetName()
		return nil
	case shelf.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Shelf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShelfMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, shelf.EdgeUser)
	}
	if m.books != nil {
		edges = append(edges, shelf.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShelfMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shelf.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case shelf.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShelfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbooks != nil {
		edges = append(edges, shelf.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShelfMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shelf.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShelfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, shelf.EdgeUser)
	}
	if m.clearedbooks {
		edges = append(edges, shelf.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShelfMutation) EdgeCleared(name string) bool {
	switch name {
	case shelf.EdgeUser:
		return m.cleareduser
	case shelf.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShelfMutation) ClearEdge(name string) error {
	switch name {
	case shelf.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Shelf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShelfMutation) ResetEdge(name string) error {
	switch name {
	case shelf.EdgeUser:
		m.ResetUser()
		return nil
	case shelf.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Shelf edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *ksuid.ID
	calibre_id    *int64
	addcalibre_id *int64
	name          *string
	clearedFields map[string]struct{}
	books         map[ksuid.ID]struct{}
	removedbooks  map[ksuid.ID]struct{}
	clearedbooks  bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id ksuid.ID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCalibreID sets the "calibre_id" field.
func (m *TagMutation) SetCalibreID(i int64) {
	m.calibre_id = &i
	m.addcalibre_id = nil
}

// CalibreID returns the value of the "calibre_id" field in the mutation.
func (m *TagMutation) CalibreID() (r int64, exists bool) {
	v := m.calibre_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalibreID returns the old "calibre_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCalibreID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalibreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalibreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalibreID: %w", err)
	}
	return oldValue.CalibreID, nil
}

// AddCalibreID adds i to the "calibre_id" field.
func (m *TagMutation) AddCalibreID(i int64) {
	if m.addcalibre_id != nil {
		*m.addcalibre_id += i
	} else {
		m.addcalibre_id = &i
	}
}

// AddedCalibreID returns the value that was added to the "calibre_id" field in this mutation.
func (m *TagMutation) AddedCalibreID() (r int64, exists bool) {
	v := m.addcalibre_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalibreID clears the value of the "calibre_id" field.
func (m *TagMutation) ClearCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	m.clearedFields[tag.FieldCalibreID] = struct{}{}
}

// CalibreIDCleared returns if the "calibre_id" field was cleared in this mutation.
func (m *TagMutation) CalibreIDCleared() bool {
	_, ok := m.clearedFields[tag.FieldCalibreID]
	return ok
}

// ResetCalibreID resets all changes to the "calibre_id" field.
func (m *TagMutation) ResetCalibreID() {
	m.calibre_id = nil
	m.addcalibre_id = nil
	delete(m.clearedFields, tag.FieldCalibreID)
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *TagMutation) AddBookIDs(ids ...ksuid.ID) {
	if m.books == nil {
		m.books = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *TagMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *TagMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *TagMutation) RemoveBookIDs(ids ...ksuid.ID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *TagMutation) RemovedBooksIDs() (ids []ksuid.ID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *TagMutation) BooksIDs() (ids []ksuid.ID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *TagMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.calibre_id != nil {
		fields = append(fields, tag.FieldCalibreID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCalibreID:
		return m.CalibreID()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCalibreID:
		return m.OldCalibreID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalibreID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addcalibre_id != nil {
		fields = append(fields, tag.FieldCalibreID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCalibreID:
		return m.AddedCalibreID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCalibreID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalibreID(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldCalibreID) {
		fields = append(fields, tag.FieldCalibreID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldCalibreID:
		m.ClearCalibreID()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCalibreID:
		m.ResetCalibreID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.books != nil {
		edges = append(edges, tag.EdgeBooks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbooks != nil {
		edges = append(edges, tag.EdgeBooks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbooks {
		edges = append(edges, tag.EdgeBooks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBooks:
		return m.clearedbooks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBooks:
		m.ResetBooks()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op             Op
	typ            string
	id             *ksuid.ID
	create_time    *time.Time
	update_time    *time.Time
	_type          *task_enums.TaskType
	status         *task_enums.Status
	progress       *float64
	addprogress    *float64
	message        *string
	error          *string
	is_system_task *bool
	clearedFields  map[string]struct{}
	user           *ksuid.ID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Task, error)
	predicates     []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id ksuid.ID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(tet task_enums.TaskType) {
	m._type = &tet
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r task_enums.TaskType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v task_enums.TaskType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(te task_enums.Status) {
	m.status = &te
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task_enums.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task_enums.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *TaskMutation) SetProgress(f float64) {
	m.progress = &f
	m.addprogress = nil
}

// Progress returns the value of the "progress" field in the mutation.
func (m *TaskMutation) Progress() (r float64, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProgress(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// AddProgress adds f to the "progress" field.
func (m *TaskMutation) AddProgress(f float64) {
	if m.addprogress != nil {
		*m.addprogress += f
	} else {
		m.addprogress = &f
	}
}

// AddedProgress returns the value that was added to the "progress" field in this mutation.
func (m *TaskMutation) AddedProgress() (r float64, exists bool) {
	v := m.addprogress
	if v == nil {
		return
	}
	return *v, true
}

// ResetProgress resets all changes to the "progress" field.
func (m *TaskMutation) ResetProgress() {
	m.progress = nil
	m.addprogress = nil
}

// SetMessage sets the "message" field.
func (m *TaskMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *TaskMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *TaskMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[task.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *TaskMutation) MessageCleared() bool {
	_, ok := m.clearedFields[task.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *TaskMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, task.FieldMessage)
}

// SetError sets the "error" field.
func (m *TaskMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *TaskMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *TaskMutation) ClearError() {
	m.error = nil
	m.clearedFields[task.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *TaskMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[task.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *TaskMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, task.FieldError)
}

// SetUserID sets the "user_id" field.
func (m *TaskMutation) SetUserID(k ksuid.ID) {
	m.user = &k
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TaskMutation) UserID() (r ksuid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUserID(ctx context.Context) (v ksuid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TaskMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[task.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TaskMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[task.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TaskMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, task.FieldUserID)
}

// SetIsSystemTask sets the "is_system_task" field.
func (m *TaskMutation) SetIsSystemTask(b bool) {
	m.is_system_task = &b
}

// IsSystemTask returns the value of the "is_system_task" field in the mutation.
func (m *TaskMutation) IsSystemTask() (r bool, exists bool) {
	v := m.is_system_task
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystemTask returns the old "is_system_task" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsSystemTask(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSystemTask is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSystemTask requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystemTask: %w", err)
	}
	return oldValue.IsSystemTask, nil
}

// ResetIsSystemTask resets all changes to the "is_system_task" field.
func (m *TaskMutation) ResetIsSystemTask() {
	m.is_system_task = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TaskMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[task.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TaskMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) UserIDs() (ids []ksuid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TaskMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, task.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, task.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, task.FieldProgress)
	}
	if m.message != nil {
		fields = append(fields, task.FieldMessage)
	}
	if m.error != nil {
		fields = append(fields, task.FieldError)
	}
	if m.user != nil {
		fields = append(fields, task.FieldUserID)
	}
	if m.is_system_task != nil {
		fields = append(fields, task.FieldIsSystemTask)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreateTime:
		return m.CreateTime()
	case task.FieldUpdateTime:
		return m.UpdateTime()
	case task.FieldType:
		return m.GetType()
	case task.FieldStatus:
		return m.Status()
	case task.FieldProgress:
		return m.Progress()
	case task.FieldMessage:
		return m.Message()
	case task.FieldError:
		return m.Error()
	case task.FieldUserID:
		return m.UserID()
	case task.FieldIsSystemTask:
		return m.IsSystemTask()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case task.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldProgress:
		return m.OldProgress(ctx)
	case task.FieldMessage:
		return m.OldMessage(ctx)
	case task.FieldError:
		return m.OldError(ctx)
	case task.FieldUserID:
		return m.OldUserID(ctx)
	case task.FieldIsSystemTask:
		return m.OldIsSystemTask(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case task.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case task.FieldType:
		v, ok := value.(task_enums.TaskType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task_enums.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case task.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case task.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case task.FieldUserID:
		v, ok := value.(ksuid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case task.FieldIsSystemTask:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystemTask(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addprogress != nil {
		fields = append(fields, task.FieldProgress)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldProgress:
		return m.AddedProgress()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldProgress:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProgress(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldMessage) {
		fields = append(fields, task.FieldMessage)
	}
	if m.FieldCleared(task.FieldError) {
		fields = append(fields, task.FieldError)
	}
	if m.FieldCleared(task.FieldUserID) {
		fields = append(fields, task.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldMessage:
		m.ClearMessage()
		return nil
	case task.FieldError:
		m.ClearError()
		return nil
	case task.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case task.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldProgress:
		m.ResetProgress()
		return nil
	case task.FieldMessage:
		m.ResetMessage()
		return nil
	case task.FieldError:
		m.ResetError()
		return nil
	case task.FieldUserID:
		m.ResetUserID()
		return nil
	case task.FieldIsSystemTask:
		m.ResetIsSystemTask()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, task.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, task.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *ksuid.ID
	create_time             *time.Time
	update_time             *time.Time
	username                *string
	password_hash           *string
	email                   *string
	clearedFields           map[string]struct{}
	shelves                 map[ksuid.ID]struct{}
	removedshelves          map[ksuid.ID]struct{}
	clearedshelves          bool
	user_permissions        *ksuid.ID
	cleareduser_permissions bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id ksuid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddShelfIDs adds the "shelves" edge to the Shelf entity by ids.
func (m *UserMutation) AddShelfIDs(ids ...ksuid.ID) {
	if m.shelves == nil {
		m.shelves = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		m.shelves[ids[i]] = struct{}{}
	}
}

// ClearShelves clears the "shelves" edge to the Shelf entity.
func (m *UserMutation) ClearShelves() {
	m.clearedshelves = true
}

// ShelvesCleared reports if the "shelves" edge to the Shelf entity was cleared.
func (m *UserMutation) ShelvesCleared() bool {
	return m.clearedshelves
}

// RemoveShelfIDs removes the "shelves" edge to the Shelf entity by IDs.
func (m *UserMutation) RemoveShelfIDs(ids ...ksuid.ID) {
	if m.removedshelves == nil {
		m.removedshelves = make(map[ksuid.ID]struct{})
	}
	for i := range ids {
		delete(m.shelves, ids[i])
		m.removedshelves[ids[i]] = struct{}{}
	}
}

// RemovedShelves returns the removed IDs of the "shelves" edge to the Shelf entity.
func (m *UserMutation) RemovedShelvesIDs() (ids []ksuid.ID) {
	for id := range m.removedshelves {
		ids = append(ids, id)
	}
	return
}

// ShelvesIDs returns the "shelves" edge IDs in the mutation.
func (m *UserMutation) ShelvesIDs() (ids []ksuid.ID) {
	for id := range m.shelves {
		ids = append(ids, id)
	}
	return
}

// ResetShelves resets all changes to the "shelves" edge.
func (m *UserMutation) ResetShelves() {
	m.shelves = nil
	m.clearedshelves = false
	m.removedshelves = nil
}

// SetUserPermissionsID sets the "user_permissions" edge to the UserPermissions entity by id.
func (m *UserMutation) SetUserPermissionsID(id ksuid.ID) {
	m.user_permissions = &id
}

// ClearUserPermissions clears the "user_permissions" edge to the UserPermissions entity.
func (m *UserMutation) ClearUserPermissions() {
	m.cleareduser_permissions = true
}

// UserPermissionsCleared reports if the "user_permissions" edge to the UserPermissions entity was cleared.
func (m *UserMutation) UserPermissionsCleared() bool {
	return m.cleareduser_permissions
}

// UserPermissionsID returns the "user_permissions" edge ID in the mutation.
func (m *UserMutation) UserPermissionsID() (id ksuid.ID, exists bool) {
	if m.user_permissions != nil {
		return *m.user_permissions, true
	}
	return
}

// UserPermissionsIDs returns the "user_permissions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserPermissionsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserPermissionsIDs() (ids []ksuid.ID) {
	if id := m.user_permissions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserPermissions resets all changes to the "user_permissions" edge.
func (m *UserMutation) ResetUserPermissions() {
	m.user_permissions = nil
	m.cleareduser_permissions = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.shelves != nil {
		edges = append(edges, user.EdgeShelves)
	}
	if m.user_permissions != nil {
		edges = append(edges, user.EdgeUserPermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeShelves:
		ids := make([]ent.Value, 0, len(m.shelves))
		for id := range m.shelves {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPermissions:
		if id := m.user_permissions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedshelves != nil {
		edges = append(edges, user.EdgeShelves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeShelves:
		ids := make([]ent.Value, 0, len(m.removedshelves))
		for id := range m.removedshelves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedshelves {
		edges = append(edges, user.EdgeShelves)
	}
	if m.cleareduser_permissions {
		edges = append(edges, user.EdgeUserPermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeShelves:
		return m.clearedshelves
	case user.EdgeUserPermissions:
		return m.cleareduser_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserPermissions:
		m.ClearUserPermissions()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeShelves:
		m.ResetShelves()
		return nil
	case user.EdgeUserPermissions:
		m.ResetUserPermissions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPermissionsMutation represents an operation that mutates the UserPermissions nodes in the graph.
type UserPermissionsMutation struct {
	config
	op               Op
	typ              string
	id               *ksuid.ID
	create_time      *time.Time
	update_time      *time.Time
	_Admin           *bool
	_CanCreatePublic *bool
	_CanEdit         *bool
	clearedFields    map[string]struct{}
	user             *ksuid.ID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*UserPermissions, error)
	predicates       []predicate.UserPermissions
}

var _ ent.Mutation = (*UserPermissionsMutation)(nil)

// userpermissionsOption allows management of the mutation configuration using functional options.
type userpermissionsOption func(*UserPermissionsMutation)

// newUserPermissionsMutation creates new mutation for the UserPermissions entity.
func newUserPermissionsMutation(c config, op Op, opts ...userpermissionsOption) *UserPermissionsMutation {
	m := &UserPermissionsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPermissions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPermissionsID sets the ID field of the mutation.
func withUserPermissionsID(id ksuid.ID) userpermissionsOption {
	return func(m *UserPermissionsMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPermissions
		)
		m.oldValue = func(ctx context.Context) (*UserPermissions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPermissions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPermissions sets the old UserPermissions of the mutation.
func withUserPermissions(node *UserPermissions) userpermissionsOption {
	return func(m *UserPermissionsMutation) {
		m.oldValue = func(context.Context) (*UserPermissions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPermissionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPermissionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPermissions entities.
func (m *UserPermissionsMutation) SetID(id ksuid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPermissionsMutation) ID() (id ksuid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPermissionsMutation) IDs(ctx context.Context) ([]ksuid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []ksuid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPermissions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserPermissionsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserPermissionsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserPermissionsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserPermissionsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserPermissionsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserPermissionsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserID sets the "user_id" field.
func (m *UserPermissionsMutation) SetUserID(k ksuid.ID) {
	m.user = &k
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPermissionsMutation) UserID() (r ksuid.ID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldUserID(ctx context.Context) (v ksuid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserPermissionsMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userpermissions.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserPermissionsMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userpermissions.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPermissionsMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userpermissions.FieldUserID)
}

// SetAdmin sets the "Admin" field.
func (m *UserPermissionsMutation) SetAdmin(b bool) {
	m._Admin = &b
}

// Admin returns the value of the "Admin" field in the mutation.
func (m *UserPermissionsMutation) Admin() (r bool, exists bool) {
	v := m._Admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "Admin" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "Admin" field.
func (m *UserPermissionsMutation) ResetAdmin() {
	m._Admin = nil
}

// SetCanCreatePublic sets the "CanCreatePublic" field.
func (m *UserPermissionsMutation) SetCanCreatePublic(b bool) {
	m._CanCreatePublic = &b
}

// CanCreatePublic returns the value of the "CanCreatePublic" field in the mutation.
func (m *UserPermissionsMutation) CanCreatePublic() (r bool, exists bool) {
	v := m._CanCreatePublic
	if v == nil {
		return
	}
	return *v, true
}

// OldCanCreatePublic returns the old "CanCreatePublic" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldCanCreatePublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanCreatePublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanCreatePublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanCreatePublic: %w", err)
	}
	return oldValue.CanCreatePublic, nil
}

// ResetCanCreatePublic resets all changes to the "CanCreatePublic" field.
func (m *UserPermissionsMutation) ResetCanCreatePublic() {
	m._CanCreatePublic = nil
}

// SetCanEdit sets the "CanEdit" field.
func (m *UserPermissionsMutation) SetCanEdit(b bool) {
	m._CanEdit = &b
}

// CanEdit returns the value of the "CanEdit" field in the mutation.
func (m *UserPermissionsMutation) CanEdit() (r bool, exists bool) {
	v := m._CanEdit
	if v == nil {
		return
	}
	return *v, true
}

// OldCanEdit returns the old "CanEdit" field's value of the UserPermissions entity.
// If the UserPermissions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPermissionsMutation) OldCanEdit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanEdit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanEdit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanEdit: %w", err)
	}
	return oldValue.CanEdit, nil
}

// ResetCanEdit resets all changes to the "CanEdit" field.
func (m *UserPermissionsMutation) ResetCanEdit() {
	m._CanEdit = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPermissionsMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userpermissions.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPermissionsMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPermissionsMutation) UserIDs() (ids []ksuid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPermissionsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPermissionsMutation builder.
func (m *UserPermissionsMutation) Where(ps ...predicate.UserPermissions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPermissionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPermissionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPermissions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPermissionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPermissionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPermissions).
func (m *UserPermissionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPermissionsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, userpermissions.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userpermissions.FieldUpdateTime)
	}
	if m.user != nil {
		fields = append(fields, userpermissions.FieldUserID)
	}
	if m._Admin != nil {
		fields = append(fields, userpermissions.FieldAdmin)
	}
	if m._CanCreatePublic != nil {
		fields = append(fields, userpermissions.FieldCanCreatePublic)
	}
	if m._CanEdit != nil {
		fields = append(fields, userpermissions.FieldCanEdit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPermissionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpermissions.FieldCreateTime:
		return m.CreateTime()
	case userpermissions.FieldUpdateTime:
		return m.UpdateTime()
	case userpermissions.FieldUserID:
		return m.UserID()
	case userpermissions.FieldAdmin:
		return m.Admin()
	case userpermissions.FieldCanCreatePublic:
		return m.CanCreatePublic()
	case userpermissions.FieldCanEdit:
		return m.CanEdit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPermissionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpermissions.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userpermissions.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userpermissions.FieldUserID:
		return m.OldUserID(ctx)
	case userpermissions.FieldAdmin:
		return m.OldAdmin(ctx)
	case userpermissions.FieldCanCreatePublic:
		return m.OldCanCreatePublic(ctx)
	case userpermissions.FieldCanEdit:
		return m.OldCanEdit(ctx)
	}
	return nil, fmt.Errorf("unknown UserPermissions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPermissionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpermissions.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userpermissions.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userpermissions.FieldUserID:
		v, ok := value.(ksuid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpermissions.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case userpermissions.FieldCanCreatePublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanCreatePublic(v)
		return nil
	case userpermissions.FieldCanEdit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanEdit(v)
		return nil
	}
	return fmt.Errorf("unknown UserPermissions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPermissionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPermissionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPermissionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserPermissions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPermissionsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpermissions.FieldUserID) {
		fields = append(fields, userpermissions.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPermissionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPermissionsMutation) ClearField(name string) error {
	switch name {
	case userpermissions.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown UserPermissions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPermissionsMutation) ResetField(name string) error {
	switch name {
	case userpermissions.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userpermissions.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userpermissions.FieldUserID:
		m.ResetUserID()
		return nil
	case userpermissions.FieldAdmin:
		m.ResetAdmin()
		return nil
	case userpermissions.FieldCanCreatePublic:
		m.ResetCanCreatePublic()
		return nil
	case userpermissions.FieldCanEdit:
		m.ResetCanEdit()
		return nil
	}
	return fmt.Errorf("unknown UserPermissions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPermissionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpermissions.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPermissionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpermissions.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPermissionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPermissionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPermissionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpermissions.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPermissionsMutation) EdgeCleared(name string) bool {
	switch name {
	case userpermissions.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPermissionsMutation) ClearEdge(name string) error {
	switch name {
	case userpermissions.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPermissions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPermissionsMutation) ResetEdge(name string) error {
	switch name {
	case userpermissions.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPermissions edge %s", name)
}
