// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"
	"lybbrio/internal/ent/author"
	"lybbrio/internal/ent/book"
	"lybbrio/internal/ent/identifier"
	"lybbrio/internal/ent/language"
	"lybbrio/internal/ent/publisher"
	"lybbrio/internal/ent/schema/ksuid"
	"lybbrio/internal/ent/series"
	"lybbrio/internal/ent/shelf"
	"lybbrio/internal/ent/tag"
	"lybbrio/internal/ent/task"
	"lybbrio/internal/ent/user"
	"lybbrio/internal/ent/userpermissions"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AuthorQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuthorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AuthorQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(author.Columns))
		selectedFields = []string{author.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: a.config}).Query()
			)
			args := newBookPaginateArgs(fieldArgs(ctx, new(BookWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBookPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					a.loadTotal = append(a.loadTotal, func(ctx context.Context, nodes []*Author) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID ksuid.ID `sql:"author_id"`
							Count  int      `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							joinT := sql.Table(author.BooksTable)
							s.Join(joinT).On(s.C(book.FieldID), joinT.C(author.BooksPrimaryKey[1]))
							s.Where(sql.InValues(joinT.C(author.BooksPrimaryKey[0]), ids...))
							s.Select(joinT.C(author.BooksPrimaryKey[0]), sql.Count("*"))
							s.GroupBy(joinT.C(author.BooksPrimaryKey[0]))
						})
						if err := query.Select().Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[ksuid.ID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					a.loadTotal = append(a.loadTotal, func(_ context.Context, nodes []*Author) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Books)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, opCtx, *field, path, mayAddCondition(satisfies, "Book")...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				modify := limitRows(author.BooksPrimaryKey[0], limit, pager.orderExpr(query))
				query.modifiers = append(query.modifiers, modify)
			} else {
				query = pager.applyOrder(query)
			}
			a.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[author.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, author.FieldCalibreID)
				fieldSeen[author.FieldCalibreID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[author.FieldName]; !ok {
				selectedFields = append(selectedFields, author.FieldName)
				fieldSeen[author.FieldName] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[author.FieldSort]; !ok {
				selectedFields = append(selectedFields, author.FieldSort)
				fieldSeen[author.FieldSort] = struct{}{}
			}
		case "link":
			if _, ok := fieldSeen[author.FieldLink]; !ok {
				selectedFields = append(selectedFields, author.FieldLink)
				fieldSeen[author.FieldLink] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type authorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuthorPaginateOption
}

func newAuthorPaginateArgs(rv map[string]any) *authorPaginateArgs {
	args := &authorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*AuthorOrder:
			args.opts = append(args.opts, WithAuthorOrder(v))
		case []any:
			var orders []*AuthorOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &AuthorOrder{Field: &AuthorOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithAuthorOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*AuthorWhereInput); ok {
		args.opts = append(args.opts, WithAuthorFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BookQuery) CollectFields(ctx context.Context, satisfies ...string) (*BookQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BookQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(book.Columns))
		selectedFields = []string{book.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthorClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedAuthors(alias, func(wq *AuthorQuery) {
				*wq = *query
			})
		case "publisher":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PublisherClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedPublisher(alias, func(wq *PublisherQuery) {
				*wq = *query
			})
		case "series":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeriesClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedSeries(alias, func(wq *SeriesQuery) {
				*wq = *query
			})
		case "identifiers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IdentifierClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedIdentifiers(alias, func(wq *IdentifierQuery) {
				*wq = *query
			})
		case "tags":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedTags(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "language":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LanguageClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedLanguage(alias, func(wq *LanguageQuery) {
				*wq = *query
			})
		case "shelf":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShelfClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedShelf(alias, func(wq *ShelfQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[book.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, book.FieldCalibreID)
				fieldSeen[book.FieldCalibreID] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[book.FieldTitle]; !ok {
				selectedFields = append(selectedFields, book.FieldTitle)
				fieldSeen[book.FieldTitle] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[book.FieldSort]; !ok {
				selectedFields = append(selectedFields, book.FieldSort)
				fieldSeen[book.FieldSort] = struct{}{}
			}
		case "publishedDate":
			if _, ok := fieldSeen[book.FieldPublishedDate]; !ok {
				selectedFields = append(selectedFields, book.FieldPublishedDate)
				fieldSeen[book.FieldPublishedDate] = struct{}{}
			}
		case "path":
			if _, ok := fieldSeen[book.FieldPath]; !ok {
				selectedFields = append(selectedFields, book.FieldPath)
				fieldSeen[book.FieldPath] = struct{}{}
			}
		case "isbn":
			if _, ok := fieldSeen[book.FieldIsbn]; !ok {
				selectedFields = append(selectedFields, book.FieldIsbn)
				fieldSeen[book.FieldIsbn] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[book.FieldDescription]; !ok {
				selectedFields = append(selectedFields, book.FieldDescription)
				fieldSeen[book.FieldDescription] = struct{}{}
			}
		case "seriesIndex":
			if _, ok := fieldSeen[book.FieldSeriesIndex]; !ok {
				selectedFields = append(selectedFields, book.FieldSeriesIndex)
				fieldSeen[book.FieldSeriesIndex] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type bookPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BookPaginateOption
}

func newBookPaginateArgs(rv map[string]any) *bookPaginateArgs {
	args := &bookPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*BookOrder:
			args.opts = append(args.opts, WithBookOrder(v))
		case []any:
			var orders []*BookOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &BookOrder{Field: &BookOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithBookOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*BookWhereInput); ok {
		args.opts = append(args.opts, WithBookFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *IdentifierQuery) CollectFields(ctx context.Context, satisfies ...string) (*IdentifierQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *IdentifierQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(identifier.Columns))
		selectedFields = []string{identifier.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "book":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			i.withBook = query
		case "calibreID":
			if _, ok := fieldSeen[identifier.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, identifier.FieldCalibreID)
				fieldSeen[identifier.FieldCalibreID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[identifier.FieldType]; !ok {
				selectedFields = append(selectedFields, identifier.FieldType)
				fieldSeen[identifier.FieldType] = struct{}{}
			}
		case "value":
			if _, ok := fieldSeen[identifier.FieldValue]; !ok {
				selectedFields = append(selectedFields, identifier.FieldValue)
				fieldSeen[identifier.FieldValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type identifierPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IdentifierPaginateOption
}

func newIdentifierPaginateArgs(rv map[string]any) *identifierPaginateArgs {
	args := &identifierPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*IdentifierOrder:
			args.opts = append(args.opts, WithIdentifierOrder(v))
		case []any:
			var orders []*IdentifierOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &IdentifierOrder{Field: &IdentifierOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithIdentifierOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*IdentifierWhereInput); ok {
		args.opts = append(args.opts, WithIdentifierFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LanguageQuery) CollectFields(ctx context.Context, satisfies ...string) (*LanguageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LanguageQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(language.Columns))
		selectedFields = []string{language.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: l.config}).Query()
			)
			args := newBookPaginateArgs(fieldArgs(ctx, new(BookWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBookPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					l.loadTotal = append(l.loadTotal, func(ctx context.Context, nodes []*Language) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID ksuid.ID `sql:"language_id"`
							Count  int      `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							joinT := sql.Table(language.BooksTable)
							s.Join(joinT).On(s.C(book.FieldID), joinT.C(language.BooksPrimaryKey[1]))
							s.Where(sql.InValues(joinT.C(language.BooksPrimaryKey[0]), ids...))
							s.Select(joinT.C(language.BooksPrimaryKey[0]), sql.Count("*"))
							s.GroupBy(joinT.C(language.BooksPrimaryKey[0]))
						})
						if err := query.Select().Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[ksuid.ID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					l.loadTotal = append(l.loadTotal, func(_ context.Context, nodes []*Language) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Books)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, opCtx, *field, path, mayAddCondition(satisfies, "Book")...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				modify := limitRows(language.BooksPrimaryKey[0], limit, pager.orderExpr(query))
				query.modifiers = append(query.modifiers, modify)
			} else {
				query = pager.applyOrder(query)
			}
			l.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[language.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, language.FieldCalibreID)
				fieldSeen[language.FieldCalibreID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[language.FieldName]; !ok {
				selectedFields = append(selectedFields, language.FieldName)
				fieldSeen[language.FieldName] = struct{}{}
			}
		case "code":
			if _, ok := fieldSeen[language.FieldCode]; !ok {
				selectedFields = append(selectedFields, language.FieldCode)
				fieldSeen[language.FieldCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type languagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LanguagePaginateOption
}

func newLanguagePaginateArgs(rv map[string]any) *languagePaginateArgs {
	args := &languagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*LanguageOrder:
			args.opts = append(args.opts, WithLanguageOrder(v))
		case []any:
			var orders []*LanguageOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &LanguageOrder{Field: &LanguageOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithLanguageOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*LanguageWhereInput); ok {
		args.opts = append(args.opts, WithLanguageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PublisherQuery) CollectFields(ctx context.Context, satisfies ...string) (*PublisherQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PublisherQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(publisher.Columns))
		selectedFields = []string{publisher.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: pu.config}).Query()
			)
			args := newBookPaginateArgs(fieldArgs(ctx, new(BookWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBookPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					pu.loadTotal = append(pu.loadTotal, func(ctx context.Context, nodes []*Publisher) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID ksuid.ID `sql:"publisher_id"`
							Count  int      `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							joinT := sql.Table(publisher.BooksTable)
							s.Join(joinT).On(s.C(book.FieldID), joinT.C(publisher.BooksPrimaryKey[1]))
							s.Where(sql.InValues(joinT.C(publisher.BooksPrimaryKey[0]), ids...))
							s.Select(joinT.C(publisher.BooksPrimaryKey[0]), sql.Count("*"))
							s.GroupBy(joinT.C(publisher.BooksPrimaryKey[0]))
						})
						if err := query.Select().Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[ksuid.ID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					pu.loadTotal = append(pu.loadTotal, func(_ context.Context, nodes []*Publisher) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Books)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, opCtx, *field, path, mayAddCondition(satisfies, "Book")...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				modify := limitRows(publisher.BooksPrimaryKey[0], limit, pager.orderExpr(query))
				query.modifiers = append(query.modifiers, modify)
			} else {
				query = pager.applyOrder(query)
			}
			pu.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[publisher.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, publisher.FieldCalibreID)
				fieldSeen[publisher.FieldCalibreID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[publisher.FieldName]; !ok {
				selectedFields = append(selectedFields, publisher.FieldName)
				fieldSeen[publisher.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type publisherPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PublisherPaginateOption
}

func newPublisherPaginateArgs(rv map[string]any) *publisherPaginateArgs {
	args := &publisherPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*PublisherOrder:
			args.opts = append(args.opts, WithPublisherOrder(v))
		case []any:
			var orders []*PublisherOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &PublisherOrder{Field: &PublisherOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithPublisherOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*PublisherWhereInput); ok {
		args.opts = append(args.opts, WithPublisherFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SeriesQuery) CollectFields(ctx context.Context, satisfies ...string) (*SeriesQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SeriesQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(series.Columns))
		selectedFields = []string{series.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[series.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, series.FieldCalibreID)
				fieldSeen[series.FieldCalibreID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[series.FieldName]; !ok {
				selectedFields = append(selectedFields, series.FieldName)
				fieldSeen[series.FieldName] = struct{}{}
			}
		case "sort":
			if _, ok := fieldSeen[series.FieldSort]; !ok {
				selectedFields = append(selectedFields, series.FieldSort)
				fieldSeen[series.FieldSort] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type seriesPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SeriesPaginateOption
}

func newSeriesPaginateArgs(rv map[string]any) *seriesPaginateArgs {
	args := &seriesPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*SeriesOrder:
			args.opts = append(args.opts, WithSeriesOrder(v))
		case []any:
			var orders []*SeriesOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &SeriesOrder{Field: &SeriesOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithSeriesOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*SeriesWhereInput); ok {
		args.opts = append(args.opts, WithSeriesFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *ShelfQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShelfQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ShelfQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shelf.Columns))
		selectedFields = []string{shelf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withUser = query
			if _, ok := fieldSeen[shelf.FieldUserID]; !ok {
				selectedFields = append(selectedFields, shelf.FieldUserID)
				fieldSeen[shelf.FieldUserID] = struct{}{}
			}
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: s.config}).Query()
			)
			args := newBookPaginateArgs(fieldArgs(ctx, new(BookWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBookPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					s.loadTotal = append(s.loadTotal, func(ctx context.Context, nodes []*Shelf) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID ksuid.ID `sql:"shelf_id"`
							Count  int      `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							joinT := sql.Table(shelf.BooksTable)
							s.Join(joinT).On(s.C(book.FieldID), joinT.C(shelf.BooksPrimaryKey[1]))
							s.Where(sql.InValues(joinT.C(shelf.BooksPrimaryKey[0]), ids...))
							s.Select(joinT.C(shelf.BooksPrimaryKey[0]), sql.Count("*"))
							s.GroupBy(joinT.C(shelf.BooksPrimaryKey[0]))
						})
						if err := query.Select().Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[ksuid.ID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				} else {
					s.loadTotal = append(s.loadTotal, func(_ context.Context, nodes []*Shelf) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Books)
							if nodes[i].Edges.totalCount[1] == nil {
								nodes[i].Edges.totalCount[1] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[1][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, opCtx, *field, path, mayAddCondition(satisfies, "Book")...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				modify := limitRows(shelf.BooksPrimaryKey[0], limit, pager.orderExpr(query))
				query.modifiers = append(query.modifiers, modify)
			} else {
				query = pager.applyOrder(query)
			}
			s.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "public":
			if _, ok := fieldSeen[shelf.FieldPublic]; !ok {
				selectedFields = append(selectedFields, shelf.FieldPublic)
				fieldSeen[shelf.FieldPublic] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[shelf.FieldUserID]; !ok {
				selectedFields = append(selectedFields, shelf.FieldUserID)
				fieldSeen[shelf.FieldUserID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[shelf.FieldName]; !ok {
				selectedFields = append(selectedFields, shelf.FieldName)
				fieldSeen[shelf.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[shelf.FieldDescription]; !ok {
				selectedFields = append(selectedFields, shelf.FieldDescription)
				fieldSeen[shelf.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type shelfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShelfPaginateOption
}

func newShelfPaginateArgs(rv map[string]any) *shelfPaginateArgs {
	args := &shelfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*ShelfOrder:
			args.opts = append(args.opts, WithShelfOrder(v))
		case []any:
			var orders []*ShelfOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &ShelfOrder{Field: &ShelfOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithShelfOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*ShelfWhereInput); ok {
		args.opts = append(args.opts, WithShelfFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TagQuery) CollectFields(ctx context.Context, satisfies ...string) (*TagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TagQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tag.Columns))
		selectedFields = []string{tag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "books":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BookClient{config: t.config}).Query()
			)
			args := newBookPaginateArgs(fieldArgs(ctx, new(BookWhereInput), path...))
			if err := validateFirstLast(args.first, args.last); err != nil {
				return fmt.Errorf("validate first and last in path %q: %w", path, err)
			}
			pager, err := newBookPager(args.opts, args.last != nil)
			if err != nil {
				return fmt.Errorf("create new pager in path %q: %w", path, err)
			}
			if query, err = pager.applyFilter(query); err != nil {
				return err
			}
			ignoredEdges := !hasCollectedField(ctx, append(path, edgesField)...)
			if hasCollectedField(ctx, append(path, totalCountField)...) || hasCollectedField(ctx, append(path, pageInfoField)...) {
				hasPagination := args.after != nil || args.first != nil || args.before != nil || args.last != nil
				if hasPagination || ignoredEdges {
					query := query.Clone()
					t.loadTotal = append(t.loadTotal, func(ctx context.Context, nodes []*Tag) error {
						ids := make([]driver.Value, len(nodes))
						for i := range nodes {
							ids[i] = nodes[i].ID
						}
						var v []struct {
							NodeID ksuid.ID `sql:"tag_id"`
							Count  int      `sql:"count"`
						}
						query.Where(func(s *sql.Selector) {
							joinT := sql.Table(tag.BooksTable)
							s.Join(joinT).On(s.C(book.FieldID), joinT.C(tag.BooksPrimaryKey[1]))
							s.Where(sql.InValues(joinT.C(tag.BooksPrimaryKey[0]), ids...))
							s.Select(joinT.C(tag.BooksPrimaryKey[0]), sql.Count("*"))
							s.GroupBy(joinT.C(tag.BooksPrimaryKey[0]))
						})
						if err := query.Select().Scan(ctx, &v); err != nil {
							return err
						}
						m := make(map[ksuid.ID]int, len(v))
						for i := range v {
							m[v[i].NodeID] = v[i].Count
						}
						for i := range nodes {
							n := m[nodes[i].ID]
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				} else {
					t.loadTotal = append(t.loadTotal, func(_ context.Context, nodes []*Tag) error {
						for i := range nodes {
							n := len(nodes[i].Edges.Books)
							if nodes[i].Edges.totalCount[0] == nil {
								nodes[i].Edges.totalCount[0] = make(map[string]int)
							}
							nodes[i].Edges.totalCount[0][alias] = n
						}
						return nil
					})
				}
			}
			if ignoredEdges || (args.first != nil && *args.first == 0) || (args.last != nil && *args.last == 0) {
				continue
			}
			if query, err = pager.applyCursors(query, args.after, args.before); err != nil {
				return err
			}
			path = append(path, edgesField, nodeField)
			if field := collectedField(ctx, path...); field != nil {
				if err := query.collectField(ctx, opCtx, *field, path, mayAddCondition(satisfies, "Book")...); err != nil {
					return err
				}
			}
			if limit := paginateLimit(args.first, args.last); limit > 0 {
				modify := limitRows(tag.BooksPrimaryKey[0], limit, pager.orderExpr(query))
				query.modifiers = append(query.modifiers, modify)
			} else {
				query = pager.applyOrder(query)
			}
			t.WithNamedBooks(alias, func(wq *BookQuery) {
				*wq = *query
			})
		case "calibreID":
			if _, ok := fieldSeen[tag.FieldCalibreID]; !ok {
				selectedFields = append(selectedFields, tag.FieldCalibreID)
				fieldSeen[tag.FieldCalibreID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tag.FieldName]; !ok {
				selectedFields = append(selectedFields, tag.FieldName)
				fieldSeen[tag.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TagPaginateOption
}

func newTagPaginateArgs(rv map[string]any) *tagPaginateArgs {
	args := &tagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TagOrder:
			args.opts = append(args.opts, WithTagOrder(v))
		case []any:
			var orders []*TagOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TagOrder{Field: &TagOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTagOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*TagWhereInput); ok {
		args.opts = append(args.opts, WithTagFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*TaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TaskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(task.Columns))
		selectedFields = []string{task.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withCreator = query
			if _, ok := fieldSeen[task.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedBy)
				fieldSeen[task.FieldCreatedBy] = struct{}{}
			}
		case "createTime":
			if _, ok := fieldSeen[task.FieldCreateTime]; !ok {
				selectedFields = append(selectedFields, task.FieldCreateTime)
				fieldSeen[task.FieldCreateTime] = struct{}{}
			}
		case "updateTime":
			if _, ok := fieldSeen[task.FieldUpdateTime]; !ok {
				selectedFields = append(selectedFields, task.FieldUpdateTime)
				fieldSeen[task.FieldUpdateTime] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[task.FieldType]; !ok {
				selectedFields = append(selectedFields, task.FieldType)
				fieldSeen[task.FieldType] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[task.FieldStatus]; !ok {
				selectedFields = append(selectedFields, task.FieldStatus)
				fieldSeen[task.FieldStatus] = struct{}{}
			}
		case "progress":
			if _, ok := fieldSeen[task.FieldProgress]; !ok {
				selectedFields = append(selectedFields, task.FieldProgress)
				fieldSeen[task.FieldProgress] = struct{}{}
			}
		case "message":
			if _, ok := fieldSeen[task.FieldMessage]; !ok {
				selectedFields = append(selectedFields, task.FieldMessage)
				fieldSeen[task.FieldMessage] = struct{}{}
			}
		case "error":
			if _, ok := fieldSeen[task.FieldError]; !ok {
				selectedFields = append(selectedFields, task.FieldError)
				fieldSeen[task.FieldError] = struct{}{}
			}
		case "createdby":
			if _, ok := fieldSeen[task.FieldCreatedBy]; !ok {
				selectedFields = append(selectedFields, task.FieldCreatedBy)
				fieldSeen[task.FieldCreatedBy] = struct{}{}
			}
		case "issystemtask":
			if _, ok := fieldSeen[task.FieldIsSystemTask]; !ok {
				selectedFields = append(selectedFields, task.FieldIsSystemTask)
				fieldSeen[task.FieldIsSystemTask] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type taskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TaskPaginateOption
}

func newTaskPaginateArgs(rv map[string]any) *taskPaginateArgs {
	args := &taskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case []*TaskOrder:
			args.opts = append(args.opts, WithTaskOrder(v))
		case []any:
			var orders []*TaskOrder
			for i := range v {
				mv, ok := v[i].(map[string]any)
				if !ok {
					continue
				}
				var (
					err1, err2 error
					order      = &TaskOrder{Field: &TaskOrderField{}, Direction: entgql.OrderDirectionAsc}
				)
				if d, ok := mv[directionField]; ok {
					err1 = order.Direction.UnmarshalGQL(d)
				}
				if f, ok := mv[fieldField]; ok {
					err2 = order.Field.UnmarshalGQL(f)
				}
				if err1 == nil && err2 == nil {
					orders = append(orders, order)
				}
			}
			args.opts = append(args.opts, WithTaskOrder(orders))
		}
	}
	if v, ok := rv[whereField].(*TaskWhereInput); ok {
		args.opts = append(args.opts, WithTaskFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "shelves":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShelfClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedShelves(alias, func(wq *ShelfQuery) {
				*wq = *query
			})
		case "userpermissions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserPermissionsClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.withUserPermissions = query
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (up *UserPermissionsQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserPermissionsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return up, nil
	}
	if err := up.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return up, nil
}

func (up *UserPermissionsQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userpermissions.Columns))
		selectedFields = []string{userpermissions.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: up.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			up.withUser = query
			if _, ok := fieldSeen[userpermissions.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userpermissions.FieldUserID)
				fieldSeen[userpermissions.FieldUserID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[userpermissions.FieldUserID]; !ok {
				selectedFields = append(selectedFields, userpermissions.FieldUserID)
				fieldSeen[userpermissions.FieldUserID] = struct{}{}
			}
		case "admin":
			if _, ok := fieldSeen[userpermissions.FieldAdmin]; !ok {
				selectedFields = append(selectedFields, userpermissions.FieldAdmin)
				fieldSeen[userpermissions.FieldAdmin] = struct{}{}
			}
		case "cancreatepublic":
			if _, ok := fieldSeen[userpermissions.FieldCanCreatePublic]; !ok {
				selectedFields = append(selectedFields, userpermissions.FieldCanCreatePublic)
				fieldSeen[userpermissions.FieldCanCreatePublic] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		up.Select(selectedFields...)
	}
	return nil
}

type userpermissionsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPermissionsPaginateOption
}

func newUserPermissionsPaginateArgs(rv map[string]any) *userpermissionsPaginateArgs {
	args := &userpermissionsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserPermissionsWhereInput); ok {
		args.opts = append(args.opts, WithUserPermissionsFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
