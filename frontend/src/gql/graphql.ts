/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
  /** The builtin Time type */
  Time: { input: any; output: any; }
};

export type Author = Node & {
  __typename?: 'Author';
  books: BookConnection;
  calibreID?: Maybe<Scalars['Int']['output']>;
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  link?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  sort: Scalars['String']['output'];
  updateTime: Scalars['Time']['output'];
};


export type AuthorBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};

/** A connection to a list of items. */
export type AuthorConnection = {
  __typename?: 'AuthorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuthorEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AuthorEdge = {
  __typename?: 'AuthorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Author>;
};

/** Ordering options for Author connections */
export type AuthorOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Authors. */
  field: AuthorOrderField;
};

/** Properties by which Author connections can be ordered. */
export enum AuthorOrderField {
  BooksCount = 'BOOKS_COUNT',
  Name = 'NAME'
}

/**
 * AuthorWhereInput is used for filtering Author objects.
 * Input was generated by ent.
 */
export type AuthorWhereInput = {
  and?: InputMaybe<Array<AuthorWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** link field predicates */
  link?: InputMaybe<Scalars['String']['input']>;
  linkContains?: InputMaybe<Scalars['String']['input']>;
  linkContainsFold?: InputMaybe<Scalars['String']['input']>;
  linkEqualFold?: InputMaybe<Scalars['String']['input']>;
  linkGT?: InputMaybe<Scalars['String']['input']>;
  linkGTE?: InputMaybe<Scalars['String']['input']>;
  linkHasPrefix?: InputMaybe<Scalars['String']['input']>;
  linkHasSuffix?: InputMaybe<Scalars['String']['input']>;
  linkIn?: InputMaybe<Array<Scalars['String']['input']>>;
  linkIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  linkLT?: InputMaybe<Scalars['String']['input']>;
  linkLTE?: InputMaybe<Scalars['String']['input']>;
  linkNEQ?: InputMaybe<Scalars['String']['input']>;
  linkNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  linkNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AuthorWhereInput>;
  or?: InputMaybe<Array<AuthorWhereInput>>;
  /** sort field predicates */
  sort?: InputMaybe<Scalars['String']['input']>;
  sortContains?: InputMaybe<Scalars['String']['input']>;
  sortContainsFold?: InputMaybe<Scalars['String']['input']>;
  sortEqualFold?: InputMaybe<Scalars['String']['input']>;
  sortGT?: InputMaybe<Scalars['String']['input']>;
  sortGTE?: InputMaybe<Scalars['String']['input']>;
  sortHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sortHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sortIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sortLT?: InputMaybe<Scalars['String']['input']>;
  sortLTE?: InputMaybe<Scalars['String']['input']>;
  sortNEQ?: InputMaybe<Scalars['String']['input']>;
  sortNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Book = Node & {
  __typename?: 'Book';
  authors?: Maybe<Array<Author>>;
  calibreID?: Maybe<Scalars['Int']['output']>;
  createTime: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  files?: Maybe<Array<BookFile>>;
  id: Scalars['ID']['output'];
  identifiers?: Maybe<Array<Identifier>>;
  isbn?: Maybe<Scalars['String']['output']>;
  language?: Maybe<Array<Language>>;
  path: Scalars['String']['output'];
  publishedDate?: Maybe<Scalars['Time']['output']>;
  publisher?: Maybe<Array<Publisher>>;
  series?: Maybe<Array<Series>>;
  seriesIndex?: Maybe<Scalars['Float']['output']>;
  shelf?: Maybe<Array<Shelf>>;
  sort: Scalars['String']['output'];
  tags?: Maybe<Array<Tag>>;
  title: Scalars['String']['output'];
  updateTime: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type BookConnection = {
  __typename?: 'BookConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BookEdge = {
  __typename?: 'BookEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Book>;
};

export type BookFile = Node & {
  __typename?: 'BookFile';
  book: Book;
  createTime: Scalars['Time']['output'];
  format: BookFileFormat;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  path: Scalars['String']['output'];
  /** Size in bytes */
  size: Scalars['Int']['output'];
  updateTime: Scalars['Time']['output'];
};

/** BookFileFormat is enum for the field format */
export enum BookFileFormat {
  Epub = 'EPUB',
  Kepub = 'KEPUB'
}

/**
 * BookFileWhereInput is used for filtering BookFile objects.
 * Input was generated by ent.
 */
export type BookFileWhereInput = {
  and?: InputMaybe<Array<BookFileWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** format field predicates */
  format?: InputMaybe<BookFileFormat>;
  formatIn?: InputMaybe<Array<BookFileFormat>>;
  formatNEQ?: InputMaybe<BookFileFormat>;
  formatNotIn?: InputMaybe<Array<BookFileFormat>>;
  /** book edge predicates */
  hasBook?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BookFileWhereInput>;
  or?: InputMaybe<Array<BookFileWhereInput>>;
  /** path field predicates */
  path?: InputMaybe<Scalars['String']['input']>;
  pathContains?: InputMaybe<Scalars['String']['input']>;
  pathContainsFold?: InputMaybe<Scalars['String']['input']>;
  pathEqualFold?: InputMaybe<Scalars['String']['input']>;
  pathGT?: InputMaybe<Scalars['String']['input']>;
  pathGTE?: InputMaybe<Scalars['String']['input']>;
  pathHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pathHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pathIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pathLT?: InputMaybe<Scalars['String']['input']>;
  pathLTE?: InputMaybe<Scalars['String']['input']>;
  pathNEQ?: InputMaybe<Scalars['String']['input']>;
  pathNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** size field predicates */
  size?: InputMaybe<Scalars['Int']['input']>;
  sizeGT?: InputMaybe<Scalars['Int']['input']>;
  sizeGTE?: InputMaybe<Scalars['Int']['input']>;
  sizeIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sizeLT?: InputMaybe<Scalars['Int']['input']>;
  sizeLTE?: InputMaybe<Scalars['Int']['input']>;
  sizeNEQ?: InputMaybe<Scalars['Int']['input']>;
  sizeNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** Ordering options for Book connections */
export type BookOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Books. */
  field: BookOrderField;
};

/** Properties by which Book connections can be ordered. */
export enum BookOrderField {
  FilesCount = 'FILES_COUNT',
  Isbn = 'ISBN',
  Name = 'NAME',
  PubDate = 'PUB_DATE',
  Title = 'TITLE'
}

/**
 * BookWhereInput is used for filtering Book objects.
 * Input was generated by ent.
 */
export type BookWhereInput = {
  and?: InputMaybe<Array<BookWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** authors edge predicates */
  hasAuthors?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorsWith?: InputMaybe<Array<AuthorWhereInput>>;
  /** files edge predicates */
  hasFiles?: InputMaybe<Scalars['Boolean']['input']>;
  hasFilesWith?: InputMaybe<Array<BookFileWhereInput>>;
  /** identifiers edge predicates */
  hasIdentifiers?: InputMaybe<Scalars['Boolean']['input']>;
  hasIdentifiersWith?: InputMaybe<Array<IdentifierWhereInput>>;
  /** language edge predicates */
  hasLanguage?: InputMaybe<Scalars['Boolean']['input']>;
  hasLanguageWith?: InputMaybe<Array<LanguageWhereInput>>;
  /** publisher edge predicates */
  hasPublisher?: InputMaybe<Scalars['Boolean']['input']>;
  hasPublisherWith?: InputMaybe<Array<PublisherWhereInput>>;
  /** series edge predicates */
  hasSeries?: InputMaybe<Scalars['Boolean']['input']>;
  hasSeriesWith?: InputMaybe<Array<SeriesWhereInput>>;
  /** shelf edge predicates */
  hasShelf?: InputMaybe<Scalars['Boolean']['input']>;
  hasShelfWith?: InputMaybe<Array<ShelfWhereInput>>;
  /** tags edge predicates */
  hasTags?: InputMaybe<Scalars['Boolean']['input']>;
  hasTagsWith?: InputMaybe<Array<TagWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** isbn field predicates */
  isbn?: InputMaybe<Scalars['String']['input']>;
  isbnContains?: InputMaybe<Scalars['String']['input']>;
  isbnContainsFold?: InputMaybe<Scalars['String']['input']>;
  isbnEqualFold?: InputMaybe<Scalars['String']['input']>;
  isbnGT?: InputMaybe<Scalars['String']['input']>;
  isbnGTE?: InputMaybe<Scalars['String']['input']>;
  isbnHasPrefix?: InputMaybe<Scalars['String']['input']>;
  isbnHasSuffix?: InputMaybe<Scalars['String']['input']>;
  isbnIn?: InputMaybe<Array<Scalars['String']['input']>>;
  isbnIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  isbnLT?: InputMaybe<Scalars['String']['input']>;
  isbnLTE?: InputMaybe<Scalars['String']['input']>;
  isbnNEQ?: InputMaybe<Scalars['String']['input']>;
  isbnNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  isbnNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<BookWhereInput>;
  or?: InputMaybe<Array<BookWhereInput>>;
  /** path field predicates */
  path?: InputMaybe<Scalars['String']['input']>;
  pathContains?: InputMaybe<Scalars['String']['input']>;
  pathContainsFold?: InputMaybe<Scalars['String']['input']>;
  pathEqualFold?: InputMaybe<Scalars['String']['input']>;
  pathGT?: InputMaybe<Scalars['String']['input']>;
  pathGTE?: InputMaybe<Scalars['String']['input']>;
  pathHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pathHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pathIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pathLT?: InputMaybe<Scalars['String']['input']>;
  pathLTE?: InputMaybe<Scalars['String']['input']>;
  pathNEQ?: InputMaybe<Scalars['String']['input']>;
  pathNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** published_date field predicates */
  publishedDate?: InputMaybe<Scalars['Time']['input']>;
  publishedDateGT?: InputMaybe<Scalars['Time']['input']>;
  publishedDateGTE?: InputMaybe<Scalars['Time']['input']>;
  publishedDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  publishedDateLT?: InputMaybe<Scalars['Time']['input']>;
  publishedDateLTE?: InputMaybe<Scalars['Time']['input']>;
  publishedDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  publishedDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** series_index field predicates */
  seriesIndex?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexGT?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexGTE?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  seriesIndexIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  seriesIndexLT?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexLTE?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexNEQ?: InputMaybe<Scalars['Float']['input']>;
  seriesIndexNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  seriesIndexNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** sort field predicates */
  sort?: InputMaybe<Scalars['String']['input']>;
  sortContains?: InputMaybe<Scalars['String']['input']>;
  sortContainsFold?: InputMaybe<Scalars['String']['input']>;
  sortEqualFold?: InputMaybe<Scalars['String']['input']>;
  sortGT?: InputMaybe<Scalars['String']['input']>;
  sortGTE?: InputMaybe<Scalars['String']['input']>;
  sortHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sortHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sortIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sortLT?: InputMaybe<Scalars['String']['input']>;
  sortLTE?: InputMaybe<Scalars['String']['input']>;
  sortNEQ?: InputMaybe<Scalars['String']['input']>;
  sortNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * CreateAuthorInput is used for create Author object.
 * Input was generated by ent.
 */
export type CreateAuthorInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  link?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  sort: Scalars['String']['input'];
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBookInput is used for create Book object.
 * Input was generated by ent.
 */
export type CreateBookInput = {
  authorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fileIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  identifierIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  isbn?: InputMaybe<Scalars['String']['input']>;
  languageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  path: Scalars['String']['input'];
  publishedDate?: InputMaybe<Scalars['Time']['input']>;
  publisherIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  seriesIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  seriesIndex?: InputMaybe<Scalars['Float']['input']>;
  shelfIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort: Scalars['String']['input'];
  tagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  title: Scalars['String']['input'];
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateIdentifierInput is used for create Identifier object.
 * Input was generated by ent.
 */
export type CreateIdentifierInput = {
  bookID: Scalars['ID']['input'];
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  type: Scalars['String']['input'];
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  value: Scalars['String']['input'];
};

/**
 * CreateLanguageInput is used for create Language object.
 * Input was generated by ent.
 */
export type CreateLanguageInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  code: Scalars['String']['input'];
  createTime?: InputMaybe<Scalars['Time']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreatePublisherInput is used for create Publisher object.
 * Input was generated by ent.
 */
export type CreatePublisherInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  name: Scalars['String']['input'];
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateSeriesInput is used for create Series object.
 * Input was generated by ent.
 */
export type CreateSeriesInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  name: Scalars['String']['input'];
  sort: Scalars['String']['input'];
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

export type CreateShelfInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  public?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * CreateTagInput is used for create Tag object.
 * Input was generated by ent.
 */
export type CreateTagInput = {
  bookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
};

/**
 * CreateTaskInput is used for create Task object.
 * Input was generated by ent.
 */
export type CreateTaskInput = {
  type: TaskTaskType;
};

/** CreateUserInput is used for create User object. */
export type CreateUserInput = {
  email: Scalars['String']['input'];
  password?: InputMaybe<Scalars['String']['input']>;
  userPermissions: CreateUserPermissionsInput;
  username: Scalars['String']['input'];
};

/**
 * CreateUserPermissionsInput is used for create UserPermissions object.
 * Input was generated by ent.
 */
export type CreateUserPermissionsInput = {
  admin?: InputMaybe<Scalars['Boolean']['input']>;
  cancreatepublic?: InputMaybe<Scalars['Boolean']['input']>;
  canedit?: InputMaybe<Scalars['Boolean']['input']>;
  createTime?: InputMaybe<Scalars['Time']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type Identifier = Node & {
  __typename?: 'Identifier';
  book: Book;
  calibreID?: Maybe<Scalars['Int']['output']>;
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  type: Scalars['String']['output'];
  updateTime: Scalars['Time']['output'];
  value: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type IdentifierConnection = {
  __typename?: 'IdentifierConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IdentifierEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type IdentifierEdge = {
  __typename?: 'IdentifierEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Identifier>;
};

/** Ordering options for Identifier connections */
export type IdentifierOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Identifiers. */
  field: IdentifierOrderField;
};

/** Properties by which Identifier connections can be ordered. */
export enum IdentifierOrderField {
  Type = 'TYPE',
  Value = 'VALUE'
}

/**
 * IdentifierWhereInput is used for filtering Identifier objects.
 * Input was generated by ent.
 */
export type IdentifierWhereInput = {
  and?: InputMaybe<Array<IdentifierWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** book edge predicates */
  hasBook?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<IdentifierWhereInput>;
  or?: InputMaybe<Array<IdentifierWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<Scalars['String']['input']>;
  typeContains?: InputMaybe<Scalars['String']['input']>;
  typeContainsFold?: InputMaybe<Scalars['String']['input']>;
  typeEqualFold?: InputMaybe<Scalars['String']['input']>;
  typeGT?: InputMaybe<Scalars['String']['input']>;
  typeGTE?: InputMaybe<Scalars['String']['input']>;
  typeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  typeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  typeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  typeLT?: InputMaybe<Scalars['String']['input']>;
  typeLTE?: InputMaybe<Scalars['String']['input']>;
  typeNEQ?: InputMaybe<Scalars['String']['input']>;
  typeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Language = Node & {
  __typename?: 'Language';
  books: BookConnection;
  calibreID?: Maybe<Scalars['Int']['output']>;
  code: Scalars['String']['output'];
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updateTime: Scalars['Time']['output'];
};


export type LanguageBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};

/** A connection to a list of items. */
export type LanguageConnection = {
  __typename?: 'LanguageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LanguageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LanguageEdge = {
  __typename?: 'LanguageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Language>;
};

/** Ordering options for Language connections */
export type LanguageOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Languages. */
  field: LanguageOrderField;
};

/** Properties by which Language connections can be ordered. */
export enum LanguageOrderField {
  BooksCount = 'BOOKS_COUNT'
}

/**
 * LanguageWhereInput is used for filtering Language objects.
 * Input was generated by ent.
 */
export type LanguageWhereInput = {
  and?: InputMaybe<Array<LanguageWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<LanguageWhereInput>;
  or?: InputMaybe<Array<LanguageWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createAuthor?: Maybe<Author>;
  createBook?: Maybe<Book>;
  createIdentifier?: Maybe<Identifier>;
  createLanguage?: Maybe<Language>;
  createPublisher?: Maybe<Publisher>;
  createSeries?: Maybe<Series>;
  createShelf?: Maybe<Shelf>;
  createTag?: Maybe<Tag>;
  createTask?: Maybe<Task>;
  createUser?: Maybe<User>;
  updateAuthor?: Maybe<Author>;
  updateBook?: Maybe<Book>;
  updateIdentifier?: Maybe<Identifier>;
  updateLanguage?: Maybe<Language>;
  updatePublisher?: Maybe<Publisher>;
  updateSeries?: Maybe<Series>;
  updateShelf?: Maybe<Shelf>;
  updateTag?: Maybe<Tag>;
  updateUser?: Maybe<User>;
};


export type MutationCreateAuthorArgs = {
  input: CreateAuthorInput;
};


export type MutationCreateBookArgs = {
  input: CreateBookInput;
};


export type MutationCreateIdentifierArgs = {
  input: CreateIdentifierInput;
};


export type MutationCreateLanguageArgs = {
  input: CreateLanguageInput;
};


export type MutationCreatePublisherArgs = {
  input: CreatePublisherInput;
};


export type MutationCreateSeriesArgs = {
  input: CreateSeriesInput;
};


export type MutationCreateShelfArgs = {
  input: CreateShelfInput;
};


export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


export type MutationCreateTaskArgs = {
  input: CreateTaskInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationUpdateAuthorArgs = {
  id: Scalars['ID']['input'];
  input: UpdateAuthorInput;
};


export type MutationUpdateBookArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBookInput;
};


export type MutationUpdateIdentifierArgs = {
  id: Scalars['ID']['input'];
  input: UpdateIdentifierInput;
};


export type MutationUpdateLanguageArgs = {
  id: Scalars['ID']['input'];
  input: UpdateLanguageInput;
};


export type MutationUpdatePublisherArgs = {
  id: Scalars['ID']['input'];
  input: UpdatePublisherInput;
};


export type MutationUpdateSeriesArgs = {
  id: Scalars['ID']['input'];
  input: UpdateSeriesInput;
};


export type MutationUpdateShelfArgs = {
  id: Scalars['ID']['input'];
  input: UpdateShelfInput;
};


export type MutationUpdateTagArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTagInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUserInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Publisher = Node & {
  __typename?: 'Publisher';
  books: BookConnection;
  calibreID?: Maybe<Scalars['Int']['output']>;
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updateTime: Scalars['Time']['output'];
};


export type PublisherBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};

/** A connection to a list of items. */
export type PublisherConnection = {
  __typename?: 'PublisherConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublisherEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PublisherEdge = {
  __typename?: 'PublisherEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Publisher>;
};

/** Ordering options for Publisher connections */
export type PublisherOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Publishers. */
  field: PublisherOrderField;
};

/** Properties by which Publisher connections can be ordered. */
export enum PublisherOrderField {
  BooksCount = 'BOOKS_COUNT',
  Name = 'NAME'
}

/**
 * PublisherWhereInput is used for filtering Publisher objects.
 * Input was generated by ent.
 */
export type PublisherWhereInput = {
  and?: InputMaybe<Array<PublisherWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<PublisherWhereInput>;
  or?: InputMaybe<Array<PublisherWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Query = {
  __typename?: 'Query';
  authors: AuthorConnection;
  bookFiles: Array<BookFile>;
  books: BookConnection;
  identifiers: IdentifierConnection;
  languages: LanguageConnection;
  /** Returns the currently logged in user */
  me: User;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  publishers: PublisherConnection;
  seriesSlice: SeriesConnection;
  shelves: ShelfConnection;
  tags: TagConnection;
  tasks: TaskConnection;
  users: Array<User>;
};


export type QueryAuthorsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AuthorOrder>>;
  where?: InputMaybe<AuthorWhereInput>;
};


export type QueryBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};


export type QueryIdentifiersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<IdentifierOrder>>;
  where?: InputMaybe<IdentifierWhereInput>;
};


export type QueryLanguagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<LanguageOrder>>;
  where?: InputMaybe<LanguageWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryPublishersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PublisherOrder>>;
  where?: InputMaybe<PublisherWhereInput>;
};


export type QuerySeriesSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SeriesOrder>>;
  where?: InputMaybe<SeriesWhereInput>;
};


export type QueryShelvesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ShelfOrder>>;
  where?: InputMaybe<ShelfWhereInput>;
};


export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TagOrder>>;
  where?: InputMaybe<TagWhereInput>;
};


export type QueryTasksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TaskOrder>>;
  where?: InputMaybe<TaskWhereInput>;
};

export type Series = Node & {
  __typename?: 'Series';
  books?: Maybe<Array<Book>>;
  calibreID?: Maybe<Scalars['Int']['output']>;
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  sort: Scalars['String']['output'];
  updateTime: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type SeriesConnection = {
  __typename?: 'SeriesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SeriesEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SeriesEdge = {
  __typename?: 'SeriesEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Series>;
};

/** Ordering options for Series connections */
export type SeriesOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SeriesSlice. */
  field: SeriesOrderField;
};

/** Properties by which Series connections can be ordered. */
export enum SeriesOrderField {
  Name = 'NAME'
}

/**
 * SeriesWhereInput is used for filtering Series objects.
 * Input was generated by ent.
 */
export type SeriesWhereInput = {
  and?: InputMaybe<Array<SeriesWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SeriesWhereInput>;
  or?: InputMaybe<Array<SeriesWhereInput>>;
  /** sort field predicates */
  sort?: InputMaybe<Scalars['String']['input']>;
  sortContains?: InputMaybe<Scalars['String']['input']>;
  sortContainsFold?: InputMaybe<Scalars['String']['input']>;
  sortEqualFold?: InputMaybe<Scalars['String']['input']>;
  sortGT?: InputMaybe<Scalars['String']['input']>;
  sortGTE?: InputMaybe<Scalars['String']['input']>;
  sortHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sortHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sortIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sortLT?: InputMaybe<Scalars['String']['input']>;
  sortLTE?: InputMaybe<Scalars['String']['input']>;
  sortNEQ?: InputMaybe<Scalars['String']['input']>;
  sortNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Shelf = Node & {
  __typename?: 'Shelf';
  books: BookConnection;
  createTime: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  public: Scalars['Boolean']['output'];
  updateTime: Scalars['Time']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};


export type ShelfBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};

/** A connection to a list of items. */
export type ShelfConnection = {
  __typename?: 'ShelfConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShelfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ShelfEdge = {
  __typename?: 'ShelfEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Shelf>;
};

/** Ordering options for Shelf connections */
export type ShelfOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Shelves. */
  field: ShelfOrderField;
};

/** Properties by which Shelf connections can be ordered. */
export enum ShelfOrderField {
  BooksCount = 'BOOKS_COUNT',
  Name = 'NAME'
}

/**
 * ShelfWhereInput is used for filtering Shelf objects.
 * Input was generated by ent.
 */
export type ShelfWhereInput = {
  and?: InputMaybe<Array<ShelfWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ShelfWhereInput>;
  or?: InputMaybe<Array<ShelfWhereInput>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']['input']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDContains?: InputMaybe<Scalars['ID']['input']>;
  userIDContainsFold?: InputMaybe<Scalars['ID']['input']>;
  userIDEqualFold?: InputMaybe<Scalars['ID']['input']>;
  userIDGT?: InputMaybe<Scalars['ID']['input']>;
  userIDGTE?: InputMaybe<Scalars['ID']['input']>;
  userIDHasPrefix?: InputMaybe<Scalars['ID']['input']>;
  userIDHasSuffix?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDLT?: InputMaybe<Scalars['ID']['input']>;
  userIDLTE?: InputMaybe<Scalars['ID']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type Tag = Node & {
  __typename?: 'Tag';
  books: BookConnection;
  calibreID?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};


export type TagBooksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<BookOrder>>;
  where?: InputMaybe<BookWhereInput>;
};

/** A connection to a list of items. */
export type TagConnection = {
  __typename?: 'TagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Tag>;
};

/** Ordering options for Tag connections */
export type TagOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Tags. */
  field: TagOrderField;
};

/** Properties by which Tag connections can be ordered. */
export enum TagOrderField {
  BooksCount = 'BOOKS_COUNT',
  Name = 'NAME'
}

/**
 * TagWhereInput is used for filtering Tag objects.
 * Input was generated by ent.
 */
export type TagWhereInput = {
  and?: InputMaybe<Array<TagWhereInput>>;
  /** calibre_id field predicates */
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDGTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  calibreIDLT?: InputMaybe<Scalars['Int']['input']>;
  calibreIDLTE?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  calibreIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  calibreIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** books edge predicates */
  hasBooks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBooksWith?: InputMaybe<Array<BookWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TagWhereInput>;
  or?: InputMaybe<Array<TagWhereInput>>;
};

export type Task = Node & {
  __typename?: 'Task';
  createTime: Scalars['Time']['output'];
  /** Error message of the task */
  error?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Whether this task is created by the system */
  isSystemTask: Scalars['Boolean']['output'];
  /** Message of the task */
  message?: Maybe<Scalars['String']['output']>;
  /** Progress of the task. 0-1 */
  progress: Scalars['Float']['output'];
  status: TaskStatus;
  type: TaskTaskType;
  updateTime: Scalars['Time']['output'];
  user?: Maybe<User>;
  /** The user who created this task. Empty for System Task */
  userID?: Maybe<Scalars['ID']['output']>;
};

/** A connection to a list of items. */
export type TaskConnection = {
  __typename?: 'TaskConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TaskEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TaskEdge = {
  __typename?: 'TaskEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Task>;
};

/** Ordering options for Task connections */
export type TaskOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Tasks. */
  field: TaskOrderField;
};

/** Properties by which Task connections can be ordered. */
export enum TaskOrderField {
  Status = 'STATUS',
  Type = 'TYPE'
}

/** TaskStatus is enum for the field status */
export enum TaskStatus {
  Failure = 'failure',
  InProgress = 'in_progress',
  Pending = 'pending',
  Success = 'success'
}

/** TaskTaskType is enum for the field type */
export enum TaskTaskType {
  CalibreImport = 'calibre_import',
  Noop = 'noop'
}

/**
 * TaskWhereInput is used for filtering Task objects.
 * Input was generated by ent.
 */
export type TaskWhereInput = {
  and?: InputMaybe<Array<TaskWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** error field predicates */
  error?: InputMaybe<Scalars['String']['input']>;
  errorContains?: InputMaybe<Scalars['String']['input']>;
  errorContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorGT?: InputMaybe<Scalars['String']['input']>;
  errorGTE?: InputMaybe<Scalars['String']['input']>;
  errorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorLT?: InputMaybe<Scalars['String']['input']>;
  errorLTE?: InputMaybe<Scalars['String']['input']>;
  errorNEQ?: InputMaybe<Scalars['String']['input']>;
  errorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_system_task field predicates */
  isSystemTask?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemTaskNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** message field predicates */
  message?: InputMaybe<Scalars['String']['input']>;
  messageContains?: InputMaybe<Scalars['String']['input']>;
  messageContainsFold?: InputMaybe<Scalars['String']['input']>;
  messageEqualFold?: InputMaybe<Scalars['String']['input']>;
  messageGT?: InputMaybe<Scalars['String']['input']>;
  messageGTE?: InputMaybe<Scalars['String']['input']>;
  messageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  messageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  messageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  messageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  messageLT?: InputMaybe<Scalars['String']['input']>;
  messageLTE?: InputMaybe<Scalars['String']['input']>;
  messageNEQ?: InputMaybe<Scalars['String']['input']>;
  messageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  messageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TaskWhereInput>;
  or?: InputMaybe<Array<TaskWhereInput>>;
  /** progress field predicates */
  progress?: InputMaybe<Scalars['Float']['input']>;
  progressGT?: InputMaybe<Scalars['Float']['input']>;
  progressGTE?: InputMaybe<Scalars['Float']['input']>;
  progressIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  progressLT?: InputMaybe<Scalars['Float']['input']>;
  progressLTE?: InputMaybe<Scalars['Float']['input']>;
  progressNEQ?: InputMaybe<Scalars['Float']['input']>;
  progressNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** status field predicates */
  status?: InputMaybe<TaskStatus>;
  statusIn?: InputMaybe<Array<TaskStatus>>;
  statusNEQ?: InputMaybe<TaskStatus>;
  statusNotIn?: InputMaybe<Array<TaskStatus>>;
  /** type field predicates */
  type?: InputMaybe<TaskTaskType>;
  typeIn?: InputMaybe<Array<TaskTaskType>>;
  typeNEQ?: InputMaybe<TaskTaskType>;
  typeNotIn?: InputMaybe<Array<TaskTaskType>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDContains?: InputMaybe<Scalars['ID']['input']>;
  userIDContainsFold?: InputMaybe<Scalars['ID']['input']>;
  userIDEqualFold?: InputMaybe<Scalars['ID']['input']>;
  userIDGT?: InputMaybe<Scalars['ID']['input']>;
  userIDGTE?: InputMaybe<Scalars['ID']['input']>;
  userIDHasPrefix?: InputMaybe<Scalars['ID']['input']>;
  userIDHasSuffix?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  userIDLT?: InputMaybe<Scalars['ID']['input']>;
  userIDLTE?: InputMaybe<Scalars['ID']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * UpdateAuthorInput is used for update Author object.
 * Input was generated by ent.
 */
export type UpdateAuthorInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  clearLink?: InputMaybe<Scalars['Boolean']['input']>;
  link?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<Scalars['String']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBookInput is used for update Book object.
 * Input was generated by ent.
 */
export type UpdateBookInput = {
  addAuthorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFileIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addIdentifierIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLanguageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPublisherIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSeriesIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addShelfIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearAuthors?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearFiles?: InputMaybe<Scalars['Boolean']['input']>;
  clearIdentifiers?: InputMaybe<Scalars['Boolean']['input']>;
  clearIsbn?: InputMaybe<Scalars['Boolean']['input']>;
  clearLanguage?: InputMaybe<Scalars['Boolean']['input']>;
  clearPublishedDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearPublisher?: InputMaybe<Scalars['Boolean']['input']>;
  clearSeries?: InputMaybe<Scalars['Boolean']['input']>;
  clearSeriesIndex?: InputMaybe<Scalars['Boolean']['input']>;
  clearShelf?: InputMaybe<Scalars['Boolean']['input']>;
  clearTags?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  isbn?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  publishedDate?: InputMaybe<Scalars['Time']['input']>;
  removeAuthorIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFileIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeIdentifierIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLanguageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePublisherIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSeriesIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeShelfIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  seriesIndex?: InputMaybe<Scalars['Float']['input']>;
  sort?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateIdentifierInput is used for update Identifier object.
 * Input was generated by ent.
 */
export type UpdateIdentifierInput = {
  bookID?: InputMaybe<Scalars['ID']['input']>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateLanguageInput is used for update Language object.
 * Input was generated by ent.
 */
export type UpdateLanguageInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdatePublisherInput is used for update Publisher object.
 * Input was generated by ent.
 */
export type UpdatePublisherInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateSeriesInput is used for update Series object.
 * Input was generated by ent.
 */
export type UpdateSeriesInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sort?: InputMaybe<Scalars['String']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateShelfInput is used for update Shelf object.
 * Input was generated by ent.
 */
export type UpdateShelfInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  public?: InputMaybe<Scalars['Boolean']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateTagInput is used for update Tag object.
 * Input was generated by ent.
 */
export type UpdateTagInput = {
  addBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  calibreID?: InputMaybe<Scalars['Int']['input']>;
  clearBooks?: InputMaybe<Scalars['Boolean']['input']>;
  clearCalibreID?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeBookIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** UpdateUserInput is used for update User object. */
export type UpdateUserInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateUserPermissionsInput is used for update UserPermissions object.
 * Input was generated by ent.
 */
export type UpdateUserPermissionsInput = {
  admin?: InputMaybe<Scalars['Boolean']['input']>;
  cancreatepublic?: InputMaybe<Scalars['Boolean']['input']>;
  canedit?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  createTime: Scalars['Time']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  shelves?: Maybe<Array<Shelf>>;
  updateTime: Scalars['Time']['output'];
  userPermissions: UserPermissions;
  username: Scalars['String']['output'];
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  Username = 'USERNAME'
}

export type UserPermissions = Node & {
  __typename?: 'UserPermissions';
  admin: Scalars['Boolean']['output'];
  cancreatepublic: Scalars['Boolean']['output'];
  canedit: Scalars['Boolean']['output'];
  createTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updateTime: Scalars['Time']['output'];
  user?: Maybe<User>;
  userID?: Maybe<Scalars['ID']['output']>;
};

/**
 * UserPermissionsWhereInput is used for filtering UserPermissions objects.
 * Input was generated by ent.
 */
export type UserPermissionsWhereInput = {
  /** Admin field predicates */
  admin?: InputMaybe<Scalars['Boolean']['input']>;
  adminNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<UserPermissionsWhereInput>>;
  /** CanCreatePublic field predicates */
  cancreatepublic?: InputMaybe<Scalars['Boolean']['input']>;
  cancreatepublicNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** CanEdit field predicates */
  canedit?: InputMaybe<Scalars['Boolean']['input']>;
  caneditNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserPermissionsWhereInput>;
  or?: InputMaybe<Array<UserPermissionsWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDContains?: InputMaybe<Scalars['ID']['input']>;
  userIDContainsFold?: InputMaybe<Scalars['ID']['input']>;
  userIDEqualFold?: InputMaybe<Scalars['ID']['input']>;
  userIDGT?: InputMaybe<Scalars['ID']['input']>;
  userIDGTE?: InputMaybe<Scalars['ID']['input']>;
  userIDHasPrefix?: InputMaybe<Scalars['ID']['input']>;
  userIDHasSuffix?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  userIDLT?: InputMaybe<Scalars['ID']['input']>;
  userIDLTE?: InputMaybe<Scalars['ID']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']['input']>;
  createTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** shelves edge predicates */
  hasShelves?: InputMaybe<Scalars['Boolean']['input']>;
  hasShelvesWith?: InputMaybe<Array<ShelfWhereInput>>;
  /** user_permissions edge predicates */
  hasUserPermissions?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserPermissionsWith?: InputMaybe<Array<UserPermissionsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']['input']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']['input']>;
  usernameContains?: InputMaybe<Scalars['String']['input']>;
  usernameContainsFold?: InputMaybe<Scalars['String']['input']>;
  usernameEqualFold?: InputMaybe<Scalars['String']['input']>;
  usernameGT?: InputMaybe<Scalars['String']['input']>;
  usernameGTE?: InputMaybe<Scalars['String']['input']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  usernameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameLT?: InputMaybe<Scalars['String']['input']>;
  usernameLTE?: InputMaybe<Scalars['String']['input']>;
  usernameNEQ?: InputMaybe<Scalars['String']['input']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type BookItemFragment = { __typename?: 'Book', id: string, title: string, description?: string | null, authors?: Array<{ __typename?: 'Author', name: string }> | null } & { ' $fragmentName'?: 'BookItemFragment' };

export type AllBooksQueryVariables = Exact<{
  first: Scalars['Int']['input'];
}>;


export type AllBooksQuery = { __typename?: 'Query', books: { __typename?: 'BookConnection', edges?: Array<{ __typename?: 'BookEdge', node?: (
        { __typename?: 'Book' }
        & { ' $fragmentRefs'?: { 'BookItemFragment': BookItemFragment } }
      ) | null } | null> | null } };

export const BookItemFragmentDoc = {"kind":"Document","definitions":[{"kind":"FragmentDefinition","name":{"kind":"Name","value":"BookItem"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Book"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"authors"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}}]} as unknown as DocumentNode<BookItemFragment, unknown>;
export const AllBooksDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"allBooks"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"first"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"Int"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"books"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"first"},"value":{"kind":"Variable","name":{"kind":"Name","value":"first"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"edges"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"node"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"FragmentSpread","name":{"kind":"Name","value":"BookItem"}}]}}]}}]}}]}},{"kind":"FragmentDefinition","name":{"kind":"Name","value":"BookItem"},"typeCondition":{"kind":"NamedType","name":{"kind":"Name","value":"Book"}},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"title"}},{"kind":"Field","name":{"kind":"Name","value":"authors"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"name"}}]}},{"kind":"Field","name":{"kind":"Name","value":"description"}}]}}]} as unknown as DocumentNode<AllBooksQuery, AllBooksQueryVariables>;